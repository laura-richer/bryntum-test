import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/BetterMixin.js'
import { CalculationIterator } from "../../../../ChronoGraph/primitives/Calculation.js"
import { calculate } from "../../../../ChronoGraph/replica/Entity.js"
import { DateInterval } from '../../../scheduling/DateInterval.js'
import { ConstraintIntervalSide, Direction, EffectiveDirection } from '../../../scheduling/Types.js'
import { ConstrainedLateScheduleMixin } from "./ConstrainedLateScheduleMixin.js"
import { GanttProjectMixin } from "./GanttProjectMixin.js"


export class GanttProjectScheduleMixin extends Mixin(
    [
        ConstrainedLateScheduleMixin
    ],
    (base : AnyConstructor<
        ConstrainedLateScheduleMixin
        ,
        typeof ConstrainedLateScheduleMixin
    >) => {

    const superProto : InstanceType<typeof base> = base.prototype


    class GanttProjectScheduleMixin extends base {
        event : GanttProjectMixin


        // need to have at least one "entity" decorator in the class, otherwise the entity infrastructure won't be setup
        @calculate('startDateConstraintIntervals')
        * calculateStartDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            const intervals : DateInterval[]    = yield* superProto.calculateStartDateConstraintIntervals.call(this)

            if (this.direction === Direction.Forward) {
                const event     = this.event

                const direction : EffectiveDirection    = yield event.$.effectiveDirection

                if (direction.direction === Direction.Forward) {
                    const startDate : Date              = yield event.$.startDate

                    startDate && intervals.push(event.projectConstraintIntervalClass.new({
                        owner : event,
                        side  : ConstraintIntervalSide.Start,
                        startDate
                    }))
                }
                else if (direction.direction === Direction.Backward) {
                    const endDate : Date                = yield event.$.endDate

                    if (endDate) {
                        const startDate : Date          = yield event.latePreSchedule.$.startDate

                        startDate && intervals.push(event.projectConstraintIntervalClass.new({
                            owner : event,
                            side  : ConstraintIntervalSide.Start,
                            startDate
                        }))
                    }
                }
            }

            return intervals
        }


        // need to have at least one "entity" decorator in the class, otherwise the entity infrastructure won't be setup
        @calculate('endDateConstraintIntervals')
        * calculateEndDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            const intervals : DateInterval[]    = yield* superProto.calculateEndDateConstraintIntervals.call(this)

            if (this.direction === Direction.Backward) {
                const event     = this.event
                const direction : EffectiveDirection     = yield event.$.effectiveDirection

                if (direction.direction === Direction.Forward) {
                    const startDate : Date              = yield event.$.startDate

                    if (startDate) {
                        const endDate : Date                = yield event.earlyPreSchedule.$.endDate

                        endDate && intervals.push(event.projectConstraintIntervalClass.new({
                            owner : event,
                            side  : ConstraintIntervalSide.End,
                            endDate
                        }))
                    }
                }
                else if (direction.direction === Direction.Backward) {
                    const endDate : Date              = yield event.$.endDate

                    endDate && intervals.push(event.projectConstraintIntervalClass.new({
                        owner : event,
                        side  : ConstraintIntervalSide.End,
                        endDate
                    }))
                }
            }

            return intervals
        }
    }

    return GanttProjectScheduleMixin
}) {}
