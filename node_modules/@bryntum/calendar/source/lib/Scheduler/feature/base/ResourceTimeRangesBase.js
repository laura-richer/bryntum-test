import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';
import AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';
import StringHelper from '../../../Core/helper/StringHelper.js';
import EventHelper from '../../../Core/helper/EventHelper.js';
import DomHelper from '../../../Core/helper/DomHelper.js';

/**
 * @module Scheduler/feature/base/ResourceTimeRangesBase
 */

/**
 * Abstract base class for ResourceTimeRanges and ResourceNonWorkingTime features.
 * You should not use this class directly.
 *
 * @extends Core/mixin/InstancePlugin
 * @abstract
 */
export default class ResourceTimeRangesBase extends InstancePlugin.mixin(AttachToProjectMixin) {
    //region Config

    static configurable = {
        /**
         * Specify value to use for the tabIndex attribute of range elements
         * @config {Number}
         * @category Misc
         */
        tabIndex : null,

        entityName : 'resourceTimeRange'
    };

    static get pluginConfig()  {
        return {
            before   : ['onInternalPaint'],
            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],
            override : ['matchScheduleCell', 'resolveResourceRecord']
        };
    }

    // Let Scheduler know if we have ResourceTimeRanges in view or not
    noFeatureElementsInAxis() {
        const { timeAxis } = this.client;
        return !this.needsRefresh && this.store && !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));
    }

    //endregion

    //region Init

    doDisable(disable) {
        if (this.client.isPainted) {
            this.client.refresh();
        }

        super.doDisable(disable);
    }

    updateTabIndex() {
        if (!this.isConfiguring) {
            this.client.refresh();
        }
    }

    onInternalPaint({ firstPaint }) {
        firstPaint && this.setupCanvas();
    }

    setupCanvas() {
        const { entityName, client } = this;
        if (!this.canvas) {
            this.canvas = client.canvases[entityName] = DomHelper.createElement({
                className     : `b-${StringHelper.hyphenate(entityName)}-canvas b-sch-canvas`,
                parent        : client.timeAxisSubGridElement,
                retainElement : true
            });
        }
    }

    //endregion

    getEventsToRender(resource, events) {
        throw new Error('Implement in subclass');
    }

    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges
    // (chained function from Scheduler)
    onEventDataGenerated(renderData) {
        const
            me                       = this,
            { client }               = me,
            { eventRecord, iconCls } = renderData;

        if (me.shouldInclude(eventRecord)) {
            if (client.isVertical) {
                renderData.width = client.getResourceWidth(renderData.resourceRecord);
            }
            else {
                renderData.top = 0;
            }
            // Used to render to the correct canvas
            renderData.entityName = me.entityName;
            // Flag that we should fill entire row/col
            renderData.fillSize = true;
            // Add our own cls
            renderData.wrapperCls['b-sch-resourcetimerange'] = 1;
            if (me.rangeCls) {
                renderData.wrapperCls[me.rangeCls] = 1;
            }
            renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;

            me.renderContent(eventRecord, renderData);
            renderData.children.push(renderData.eventContent);

            // Allow configuring tabIndex
            renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;

            // Add icon
            if (iconCls?.length > 0) {
                renderData.children.unshift({
                    tag       : 'i',
                    className : iconCls.toString()
                });
            }

            // Event data for DOMSync comparison
            renderData.eventId = me.generateElementId(eventRecord);
        }
    }

    renderContent(eventRecord, renderData) {
        renderData.eventContent.text = eventRecord.name;
    }

    /**
     * Generates ID from the passed time range record
     * @param {Scheduler.model.TimeSpan} record
     * @returns {String} Generated ID for the DOM element
     * @internal
     */
    generateElementId(record) {
        return record.domId;
    }

    resolveResourceTimeRangeRecord(rangeElement) {
        return rangeElement?.closest(`.${this.rangeCls}`)?.elementData.eventRecord;
    }

    getElementFromResourceTimeRangeRecord(record) {
        return this.canvas.syncIdMap[record.domId];
    }

    resolveResourceRecord(event) {
        const record = this.overridden.resolveResourceRecord(...arguments);

        return record || this.resolveResourceTimeRangeRecord(event.target || event)?.resource;
    }

    shouldInclude(eventRecord) {
        throw new Error('Implement in subclass');
    }

    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI
    onStoreChange(event) {
        // Edge case for scheduler not using any events, it has to refresh anyway to get rid of ResourceTimeRanges
        if (event.action === 'removeall' || event.action === 'dataset') {
            this.needsRefresh = true;
        }

        this.client.onInternalEventStoreChange(event);

        this.needsRefresh = false;
    }

    // Override to let scheduler find the time cell from a resource time range element
    matchScheduleCell(target) {
        let cell = this.overridden.matchScheduleCell(target);

        if (!cell && this.enableMouseEvents) {
            const
                { client }   = this,
                rangeElement = target.closest(`.${this.rangeCls}`);

            cell = rangeElement && client.getCell({
                record : client.isHorizontal ? rangeElement.elementData.resource : client.store.first,
                column : client.timeAxisColumn
            });
        }

        return cell;
    }

    handleRangeMouseEvent(domEvent) {
        const
            me           = this,
            rangeElement = domEvent.target.closest(`.${me.rangeCls}`);

        if (rangeElement) {
            const
                eventName               = EventHelper.eventNameMap[domEvent.type] ?? StringHelper.capitalize(domEvent.type),
                resourceTimeRangeRecord = me.resolveResourceTimeRangeRecord(rangeElement);

            me.client.trigger(me.entityName + eventName, {
                feature                    : me,
                [`${me.entityName}Record`] : resourceTimeRangeRecord,
                resourceRecord             : me.client.resourceStore.getById(resourceTimeRangeRecord.resourceId),
                startDate                  : resourceTimeRangeRecord.startDate,
                endDate                    : resourceTimeRangeRecord.endDate,
                domEvent
            });
        }
    }

    updateEnableMouseEvents(enable) {
        const
            me         = this,
            { client } = me;

        me.mouseEventsDetacher?.();
        me.mouseEventsDetacher = null;

        client.whenVisible(() => {
            if (enable) {
                me.mouseEventsDetacher = EventHelper.on({
                    element     : client.canvases[me.entityName],
                    delegate    : `.${me.rangeCls}`,
                    mousedown   : 'handleRangeMouseEvent',
                    mouseup     : 'handleRangeMouseEvent',
                    click       : 'handleRangeMouseEvent',
                    dblclick    : 'handleRangeMouseEvent',
                    contextmenu : 'handleRangeMouseEvent',
                    mouseover   : 'handleRangeMouseEvent',
                    mouseout    : 'handleRangeMouseEvent',
                    thisObj     : me
                });
            }

            me.canvas.classList.toggle('b-interactive', Boolean(enable));
        });
    }
}

// No feature based styling needed, do not add a cls to Scheduler
ResourceTimeRangesBase.featureClass = '';
