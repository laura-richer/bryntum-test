import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/Mixin.js'
import { CalculationIterator } from '../../../../ChronoGraph/primitives/Calculation.js'
import { calculate } from "../../../../ChronoGraph/replica/Entity.js"
import { DateInterval } from "../../../scheduling/DateInterval.js"
import { ConstraintIntervalSide, Direction } from "../../../scheduling/Types.js"
import { HasChildrenMixin } from '../scheduler_basic/HasChildrenMixin.js'
import { ConstrainedEarlyEventMixin } from '../scheduler_pro/ConstrainedEarlyEventMixin.js'
import { ConstrainedScheduleMixin } from "../scheduler_pro/ConstrainedScheduleMixin.js"
import { ConstrainedByParentMixin, ManuallyScheduledParentConstraintInterval } from "./ConstrainedByParentMixin.js"
import { GanttProjectMixin } from "./GanttProjectMixin.js"

//---------------------------------------------------------------------------------------------------------------------
/**
 * This mixin makes the event to "inherit" the constraints from its parent event.
 */
export class ConstrainedByParentScheduleMixin extends Mixin(
    [
        ConstrainedScheduleMixin
    ],
    (base : AnyConstructor<
        ConstrainedScheduleMixin
        ,
        typeof ConstrainedScheduleMixin
    >) => {

    const superProto : InstanceType<typeof base> = base.prototype


    class ConstrainedByParentScheduleMixin extends base {
        event : ConstrainedEarlyEventMixin & HasChildrenMixin

        project : GanttProjectMixin


        // need to have at least one "entity" decorator in the class, otherwise the entity infrastructure won't be setup
        @calculate('startDateConstraintIntervals')
        * calculateStartDateConstraintIntervals () : CalculationIterator<this[ 'startDateConstraintIntervals' ]> {
            const intervals : DateInterval[] = yield* superProto.calculateStartDateConstraintIntervals.call(this)

            const parentEvent : HasChildrenMixin & ConstrainedByParentMixin = yield this.event.$.parentEvent

            if (parentEvent?.graph) {
                const applyConstraint : boolean = (yield* parentEvent.isManuallyScheduled())
                    && (yield this.event.$.effectiveDirection).direction === this.direction

                if (!this.project.manuallyScheduledParentBreaksConstraintInheritance || !applyConstraint) {
                    const parentIntervals = yield this.pick(parentEvent).$.startDateConstraintIntervals

                    intervals.push.apply(intervals, parentIntervals)
                }

                // If the parent is scheduled manually it restricts its children (even though it has no a constraint set)
                // so we append an artificial constraining interval
                if (applyConstraint && this.direction === Direction.Forward) {
                    intervals.push(ManuallyScheduledParentConstraintInterval.new({
                        owner       : parentEvent,
                        side        : ConstraintIntervalSide.Start,
                        startDate   : yield parentEvent.$.startDate
                    }))
                }
            }

            return intervals
        }


        * calculateEndDateConstraintIntervals () : CalculationIterator<this[ 'endDateConstraintIntervals' ]> {
            const intervals : DateInterval[] = yield* superProto.calculateEndDateConstraintIntervals.call(this)

            const parentEvent : HasChildrenMixin & ConstrainedByParentMixin = yield this.event.$.parentEvent

            if (parentEvent?.graph) {
                const applyConstraint : boolean = (yield* parentEvent.isManuallyScheduled())
                    && (yield this.event.$.effectiveDirection).direction === this.direction

                // Child inherits its parent tasks constraints
                // except the parent is manually scheduled (in this case the parent break constraints inheritance)
                if (!this.project.manuallyScheduledParentBreaksConstraintInheritance || !applyConstraint) {
                    const parentIntervals = yield this.pick(parentEvent).$.endDateConstraintIntervals

                    intervals.push.apply(intervals, parentIntervals)
                }

                // If the parent is scheduled manually it restricts its children (even though it has no a constraint set)
                // so we append an artificial constraining interval
                if (applyConstraint && this.direction === Direction.Backward) {
                    intervals.push(ManuallyScheduledParentConstraintInterval.new({
                        owner       : parentEvent,
                        side        : ConstraintIntervalSide.End,
                        endDate     : yield parentEvent.$.endDate
                    }))
                }
            }

            return intervals
        }
    }

    return ConstrainedByParentScheduleMixin
}){}
