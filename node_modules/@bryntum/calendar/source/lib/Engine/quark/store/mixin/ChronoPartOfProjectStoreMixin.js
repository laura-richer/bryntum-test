import { Mixin } from "../../../../ChronoGraph/class/BetterMixin.js";
import { ChronoPartOfProjectGenericMixin } from "../../ChronoPartOfProjectGenericMixin.js";
import { ChronoStoreMixin } from "./ChronoStoreMixin.js";
import { AbstractPartOfProjectStoreMixin } from "./AbstractPartOfProjectStoreMixin.js";
import { CalculatedValueGen } from "../../../../ChronoGraph/chrono/Identifier.js";
import { ProposedOrPrevious } from "../../../../ChronoGraph/chrono/Effect.js";
const uniqueValue = Symbol('uniqueValue');
/**
 * This a base mixin for every Store, that belongs to a ChronoGraph powered project.
 */
export class ChronoPartOfProjectStoreMixin extends Mixin([
    AbstractPartOfProjectStoreMixin,
    ChronoPartOfProjectGenericMixin,
    ChronoStoreMixin
], (base) => {
    const superProto = base.prototype;
    class ChronoPartOfProjectStoreMixin extends base {
        constructor() {
            super(...arguments);
            this.removalOrder = 0;
        }
        setStoreData(data) {
            // Inform project that a store is being repopulated, to avoid expensive unjoins.
            // Should not repopulate when using syncDataOnLoad
            this.project?.repopulateStore(this);
            superProto.setStoreData.call(this, data);
            // Store loaded during delayed calculation. Temporary indices used to mimic buckets during delay will likely
            // not be valid, invalidate them to be sure up-to-date ones are used
            if (this.project?.delayedCalculationPromise) {
                this.project.invalidateTemporaryIndices();
            }
        }
        register(record) {
            superProto.register.call(this, record);
            // NOTE: Remove check for `this.project.graph` if we want records added after the initial calculations to also have
            //       delayed entry into the replica
            // @ts-ignore
            !record.isRoot && !this.project?.graph && this.project?.scheduleDelayedCalculation();
        }
        onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
            // 1. call will forward value to the chrono, leaving model.data intact
            // 2. value was changed, so model.afterChange is called too, triggering `update` event on store
            // 3. autoCommit is scheduled
            // 4. autoCommit finalizes, calling endBatch
            // 5. endBatch calls `set` again, passing argument `skipAccessors = true`, which means data will be set to
            // the `model.data` now
            // 6. since value differs in chrono and in model.data, `afterChange` will be called once again
            // Naturally this leads to two identical events being fired for this call:
            // `dependency.set('type', 0)`
            //
            // Idea of the fix is to mute events for the first call IF chrono field is in the `wasSet` object
            // Covered by DependencyEdit.t.js
            if (!skipAccessors
                && !(this.syncDataOnLoad && this.isLoadingData)
                && Object.keys(wasSet).some(key => key !== 'intervals' && record.$entity.getField(key))
                // https://github.com/bryntum/support/issues/6347
                // it seems this workaround with `silent = true` was purposed for the change initiated by user
                // the comment above suggest `dependency.set('type', 0)` call
                // It is probably not applicable for the crudmanager "sync" phase
                // @ts-ignore
                && !this.project?.applyingSyncResponse) {
                silent = true;
            }
            //@ts-ignore
            super.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
        }
        async loadDataAsync(data) {
            // We want to be very sure that calculations are complete before we plug new data in.
            // For a scenario where a client plugged new datasets in on every store change, thus multiple times
            // during a single commit()
            while (this.project.replica?.isCommitting) {
                await this.project.commitAsync();
            }
            return super.loadDataAsync(data);
        }
        joinRecordsToProject(project, skipRoot = false) {
            const fn = (record) => {
                record.setProject(project);
                record.joinProject();
            };
            // Both iteration methods must pass includeFilteredOutRecords as true
            // so that we work on full, unfiltered dataset
            const rootNode = this.rootNode;
            if (rootNode) {
                rootNode.traverse(fn, skipRoot, true);
            }
            else {
                this.forEach(fn, null, {
                    includeFilteredOutRecords: true,
                    includeCollapsedGroupRecords: true
                });
            }
            if (this.$filtered) {
                project.getGraph()?.addIdentifier(this.$filtered);
            }
        }
        unjoinRecordsFromProject(project) {
            const fn = (record) => {
                record.leaveProject();
                record.setProject(project);
            };
            // Both iteration methods must pass includeFilteredOutRecords as true
            // so that we work on full, unfiltered dataset
            const rootNode = this.rootNode;
            if (rootNode) {
                rootNode.traverse(node => {
                    // do not unjoin/leave project for the root node, which is the project itself
                    if (node !== rootNode)
                        fn(node);
                }, false, true);
            }
            else {
                this.forEach(fn, null, {
                    includeFilteredOutRecords: true,
                    includeCollapsedGroupRecords: true
                });
            }
            if (this.$filtered) {
                this.getGraph()?.removeIdentifier(this.$filtered);
            }
        }
        // Setups a listener for the store update to track certain record changes
        setupRecordChangeTrackerListener() {
            const me = this;
            me.detachRecordChangeTracker?.();
            me.detachRecordChangeTracker = me.ion({
                detachable: true,
                update({ record, changes }) {
                    // if the record is tracked
                    if (me.recordsToTrackChanges.get(record)) {
                        const graph = me.getGraph();
                        // get the list of tracked fields
                        const trackers = record.fieldChangeTrackers;
                        if (graph && trackers) {
                            for (let [fieldName, identifier] of trackers) {
                                // if a tracked field is changed ping the identifier representing the field in the graph
                                if (fieldName in changes) {
                                    // write a value not equal to the field current value
                                    identifier.writeToGraph(graph, uniqueValue);
                                }
                            }
                        }
                    }
                }
            });
        }
        trackRecordFieldChanges(record, fieldName) {
            // setup "update" listener if not yet
            if (!this.detachRecordChangeTracker) {
                this.setupRecordChangeTrackerListener();
                this.recordsToTrackChanges = new Map();
            }
            this.recordsToTrackChanges.set(record, true);
            return record.trackFieldChanges(fieldName);
        }
        untrackRecordFieldChanges(record, fieldName = undefined) {
            const trackers = this.recordsToTrackChanges;
            if (trackers) {
                // process either provided record or all tracked ones
                const records = record ? [record] : trackers.keys();
                for (const record of records) {
                    record.untrackFieldChanges(fieldName);
                }
                // untrack the record if no tracked fields left
                if (!record.fieldChangeTrackers) {
                    trackers.delete(record);
                }
            }
        }
        setupStoreFilterListener() {
            this.detachListeners('storeFilteredIdentifier');
            this.ion({
                name: 'storeFilteredIdentifier',
                filter() {
                    const graph = this.getGraph();
                    this.$filtered.writeToGraph(graph, true);
                }
            });
        }
        // Makes a special identifier triggering when the store gets filtered
        // and yields the identifier
        *trackStoreFilter() {
            if (!this.$filtered) {
                this.setupStoreFilterListener();
                const graph = this.getGraph();
                // make the identifier
                this.$filtered = graph.addIdentifier(CalculatedValueGen.new({
                    *calculation(Y) {
                        return !(yield ProposedOrPrevious);
                    },
                }));
            }
            yield this.$filtered;
        }
        setProject(project) {
            if (project !== this.project) {
                const graph = this.getGraph();
                // cleanup #filtered identified if any
                if (this.$filtered && graph) {
                    graph.removeIdentifier(this.$filtered);
                    this.$filtered = null;
                    this.detachListeners('storeFilteredIdentifier');
                }
            }
            return super.setProject(project);
        }
    }
    return ChronoPartOfProjectStoreMixin;
}) {
}
