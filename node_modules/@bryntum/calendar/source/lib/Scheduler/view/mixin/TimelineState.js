import Base from '../../../Core/Base.js';
import ObjectHelper from '../../../Core/helper/ObjectHelper.js';

/**
 * @module Scheduler/view/mixin/TimelineState
 */

const copyProperties = [
    'barMargin'
];

/**
 * Mixin for Timeline base that handles state. It serializes the following timeline properties:
 *
 * * barMargin
 * * zoomLevel
 *
 * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.
 *
 * @mixin
 */
export default Target => class TimelineState extends (Target || Base) {
    static $name = 'TimelineState';

    /**
     * Gets or sets timeline's state. Check out {@link Scheduler.view.mixin.TimelineState} mixin for details.
     * @member {Object} state
     * @property {Object[]} state.columns
     * @property {Number} state.rowHeight
     * @property {Object} state.scroll
     * @property {Number} state.scroll.scrollLeft
     * @property {Number} state.scroll.scrollTop
     * @property {Array} state.selectedRecords
     * @property {String} state.style
     * @property {String} state.selectedCell
     * @property {String[]} state.treeGroupLevels
     * @property {Object} state.store
     * @property {Object} state.store.sorters
     * @property {Object} state.store.groupers
     * @property {Object} state.store.filters
     * @property {Object} state.subGrids
     * @property {Number} state.barMargin
     * @property {Number} state.zoomLevel
     * @category State
     */

    /**
     * Get timeline's current state for serialization. See {@link #property-state} for a list of the state variables.
     * @returns {Object} State object to be serialized
     * @private
     */
    getState() {
        const
            me    = this,
            state = ObjectHelper.copyProperties(super.getState(), me, copyProperties);

        state.zoomLevel = me.zoomLevel;

        state.zoomLevelOptions = {
            startDate  : me.startDate,
            endDate    : me.endDate,
            // With infinite scroll reading viewportCenterDate too early will lead to exception
            centerDate : !me.infiniteScroll || me.timeAxisViewModel.availableSpace ? me.viewportCenterDate : undefined,
            width      : me.tickSize
        };

        return state;
    }

    /**
     * Apply previously stored state.
     * @param {Object} state
     * @private
     */
    applyState(state) {
        const me = this;

        state = Object.assign({}, state);

        me.suspendRefresh();

        if (state.zoomLevel != null) {
            delete state.startDate;
            delete state.endDate;
            me.timeAxis.suspendEvents();
        }

        // Zoom is restored separately below
        const { zoomLevel, zoomLevelOptions } = state;
        delete state.zoomLevel;
        delete state.zoomLevelOptions;

        super.applyState(state);

        if (zoomLevel != null) {
            me.timeAxis.resumeEvents();
            // Do not restore left scroll, infinite scroll should do all the work
            if (me.infiniteScroll && state?.scroll?.scrollLeft) {
                state.scroll.scrollLeft = {};
            }

            me.whenVisible(() => me.zoomToLevel(zoomLevel, zoomLevelOptions));
        }

        me.resumeRefresh(true, false);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement this.
    get widgetClass() {}
};
