import EventRenderer from './mixin/EventRenderer.js';
import SchedulerDatePicker from '../../Scheduler/widget/SchedulerDatePicker.js';
import DateHelper from '../../Core/helper/DateHelper.js';
import DomHelper from '../../Core/helper/DomHelper.js';
import VersionHelper from '../../Core/helper/VersionHelper.js';

/**
 * @module Calendar/widget/CalendarDatePicker
 */

const emptyString = new String(); // Need a truthy string here, so use the Object form.

/**
 * A subclass of {@link Core.widget.DatePicker} which is able to show the presence of
 * events in its cells if contained in a Calendar, and {@link #config-showEvents} is set
 * to a truthy value.
 *
 * The `datepicker` Widget type is implemented by this class when this class is imported, or built
 * into a bundle, and so any {@link Core.widget.DateField} may have its
 * {@link Core.widget.PickerField#config-picker} configured to use its capabilities of showing
 * the presence of events in its date cells.
 *
 * @extends Scheduler/widget/SchedulerDatePicker
 * @mixes Calendar/widget/mixin/EventRenderer
 * @classtype datepicker
 * @widget
 */
export default class CalendarDatePicker extends SchedulerDatePicker.mixin(EventRenderer) {
    static $name = 'CalendarDatePicker';

    // Factoryable type name
    static type = 'datepicker';

    static configurable = {
        /**
         * How to show presence of events in the configured {@link #config-eventStore} in the
         * day cells. Values may be:
         *
         * * `false` - Do not show events in cells.
         * * `true` - Show a themeable bullet to indicate the presence of events for a date.
         * * `'count'` - Show a themeable badge containing the event count for a date.
         * * `'dots'` - Show small event-coloured bullets up to a maximum of `{@link #config-eventDots}.max`
         *   to indicate event presence.
         * * `'heatmap'` - show warmer background colors the more events are present for a date
         * @prp {Boolean|'count'|'dots'|'heatmap'}
         * @default false
         */
        showEvents : null,

        /**
         * When {@link #config-showEvents} is `'dots'`, this is the maximum number of dots to show
         * below the date number in the cell.
         *
         * The default is four. Note that increasing this may lead to a cluttered UI in which the dots
         * obscure the date figure in the cell.
         * @deprecated 6.1.2 Use {@link #property-eventDots} instead.
         *
         * @prp {Number}
         * @default 4
         */
        maxDots : null,

        /**
         * When {@link #config-showEvents} is `'dots'`, this controls the layout of the dots
         * below the day number.
         *
         * If the `max` property is 1, the dots will be coloured using the default event colour,
         * *not* the colour of the event. This is to create a consistent appearance.
         *
         * @prp {Object}
         * @property {Number} marginTop The margin above the dots. Default is 4.
         * @property {Number} max The maximum number of dots to show. Default is 4.
         * @property {Number} gap The gap between dots. Default is 3.
         * @property {Number} size The size of the dots. Default is 5.
         * @property {Boolean} stripe If `true`, the dots will be striped, meaning they will be
         * joined together with _no gap_ between them and rounded at each end. Default is `false`.
         */
        eventDots : {
            marginTop : 4,
            max       : 4,
            gap       : 3,
            size      : 5
        },

        /**
         * When {@link #config-showEvents} is __not__ `'count'`, setting this to
         * `true` means that a tooltip containing the event count will be shown on hover of
         * a day cell.
         *
         * @prp {Boolean}
         * @default
         */
        eventCountTip : null,

        alwaysRefreshOnMonthChange : true
    };

    construct(config) {
        const calendar = this.calendar = (config.owner || config.parent)?.up('calendar');

        if (calendar && !config.eventStore) {
            config.eventStore = calendar.eventStore;
        }

        super.construct(...arguments);
    }

    changeEventDots(eventDots) {
        const me = this;
        return new Proxy(eventDots, {
            set(target) {
                const result = Reflect.set(...arguments);
                me.updateEventDots(target);
                return result;
            }
        });
    }

    updateEventDots({ marginTop, gap, size, stripe }) {
        const { style, classList } = this.weeksElement;

        style.setProperty('--event-count-margin-top', `${marginTop}px`);
        style.setProperty('--event-count-dot-size', `${size}px`);
        style.setProperty('--event-count-dot-gap', `${gap}px`);
        classList[stripe ? 'add' : 'remove']('b-event-count-dots-striped');
        if (!this.isConfiguring) {
            this.refresh();
        }
    }

    updatemaxDots(maxDots) {
        VersionHelper.deprecate('calendar', '7.0.0', 'maxDots property is deprecated in favor of eventDots');
        this.eventDots.max = maxDots;
        this.updateEventDots(this.eventDots);
    }

    refreshEventsMap() {
        const
            me          = this,

            // Event order should match that seen in active view unless configured otherwise.
            // Colours of dots should match those seen in active view by default.
            eventSorter = me.eventSorter || me.calendar?.activeView?.eventSorter;

        if (me.showEvents) {
            me.cellMap = me.eventStore[me.showEvents === 'dots' ? 'getEvents' : 'getEventCounts']({
                startDate : me.startDate,
                endDate   : me.endDate,
                dateMap   : me.cellMap || (me.cellMap = new Map()),
                filter    : me.eventFilter
            });
            // Sort the events in the cells
            if (me.showEvents === 'dots' && eventSorter) {
                for (const eventInfo of me.cellMap.values()) {
                    eventInfo.sort(eventSorter);
                }
            }
        }
    }

    cellRenderer({ cell, date }) {
        const
            me             = this,
            { showEvents } = me,
            isCount        = showEvents === 'count',
            isDots         = showEvents === 'dots',
            eventInfo      = me.cellMap?.get?.(DateHelper.makeKey(date)),
            count          = isDots ? eventInfo?.length : eventInfo,
            countCls       = isCount ? 'b-cell-events-badge' : isDots ? 'b-cal-minimal-event-container' : 'b-icon b-icon-circle';

        if (isDots) {
            // We replace the text-only date with an element so it can carry the background
            // and the background will not obscure the dots.
            cell.innerHTML = '';
            DomHelper.createElement({
                class  : 'b-date-cell-inner',
                text   : date.getDate(),
                parent : cell
            });
        }

        cell.parentNode.setAttribute('aria-label', `${DateHelper.format(date, 'dddd MMMM Do YYYY')}${showEvents ? `, ${me.L('L{ResourceInfoColumn.eventCountText}', count || 0)}` : ''}.`);
        delete cell.parentNode.dataset.btip;
        if (count) {
            if (!isCount && me.eventCountTip) {
                cell.parentNode.dataset.btip = me.L('L{ResourceInfoColumn.eventCountText}', count);
            }
            const cellContent = {
                dataset : {
                    count
                },
                class : {
                    [countCls]                                      : showEvents !== 'heatmap',
                    [SchedulerDatePicker.getEventCountClass(count)] : 1
                },
                parent                  : cell,
                [isCount ? 'text' : ''] : count
            };

            if (isDots) {
                const
                    { max }  = me.eventDots,
                    children = cellContent.children = [];

                for (let i = 0; i < Math.min(eventInfo?.length || 0, max); i++) {
                    // If there's only one dot, make it use the default colour
                    // By passing an empty string as the color, the EventRenderer will use the default colour
                    const eventDomConfig = me.createEventDomConfig({
                        date,
                        eventRecord : eventInfo[i],

                        // If we only show one dot, we don't want to show whatever
                        // the event colour is, we want to show the default dot colour.
                        eventColor : max > 1 ? null : emptyString,

                        // renders without content with just background colour
                        minimal : true
                    });
                    children.push(eventDomConfig);
                }
            }

            DomHelper.createElement(cellContent);
        }
    }

    static setupClass(meta) {
        // We take over the type name 'datepicker' when we are in the app
        meta.replaceType = true;

        super.setupClass(meta);
    }
}

CalendarDatePicker.initClass();
