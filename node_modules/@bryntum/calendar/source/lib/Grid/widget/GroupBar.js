import ChipView from '../../Core/widget/ChipView.js';
import Store from '../../Core/data/Store.js';
import StringHelper from '../../Core/helper/StringHelper.js';

/**
 * @module Grid/widget/GroupBar
 */

/**
 * A widget used to manage grouping of a grid using {@link Grid.feature.Group} feature or a tree using the
 * {@link Grid.feature.TreeGroup} feature. Column headers can be drag-dropped on this widget to regroup the data in the
 * grid store. This widget only handles column-based grouping, and doesn't handle custom group functions.
 *
 * ```javascript
 * const tree = new TreeGrid({
 *     appendTo : 'container',
 *     features : {
 *         treeGroup : {
 *             hideGroupedColumns : true,
 *             levels             : [
 *                 'manager',
 *                 'airline'
 *             ],
 *             parentRenderer : (field, data) => `${StringHelper.capitalize(field)}: ${data.name}`
 *         }
 *     },
 *
 *     columns : [
 *         {
 *             text  : 'Name',
 *             field : 'name',
 *             flex  : 3,
 *             type  : 'tree'
 *         },
 *         {
 *             text   : 'Airline',
 *             field  : 'airline',
 *             align  : 'center',
 *             flex   : 2,
 *         },
 *         {
 *             type  : 'check',
 *             text  : 'Domestic',
 *             field : 'domestic',
 *             align : 'left',
 *             flex  : 1
 *         },
 *         {
 *             type  : 'number',
 *             text  : 'Capacity',
 *             field : 'capacity',
 *             flex  : 1
 *         },
 *         {
 *             type  : 'number',
 *             text  : 'Crew',
 *             field : 'crew',
 *             flex  : 1
 *         }
 *     ],
 *
 *     tbar : [
 *         'Group by',
 *         {
 *             type : 'groupbar'
 *         }
 *     ]
 * ```
 * @classtype groupbar
 * @extends Core/widget/ChipView
 * @demo Grid/tree-grouping
 * @widget
 */
export default class GroupBar extends ChipView {
    static type  = 'groupbar';
    static $name = 'GroupBar';

    static configurable = {
        selectedCls : 'not-used',
        ariaLabel   : 'L{TreeGroup.group}',
        itemTpl(record) {
            return StringHelper.encodeHtml(StringHelper.capitalize(record.getValue(this.displayField)));
        }
    };

    construct() {
        super.construct(...arguments);

        const grid = this.grid = this.up('gridbase', true);

        if (!grid) {
            throw new Error('GroupBar must be used inside a Grid component');
        }
        grid.ion({
            paint   : this.onGridPaint,
            once    : true,
            thisObj : this
        });
    }

    onGridPaint() {
        const
            me       = this,
            { grid } = me,
            {
                treeGroup,
                group,
                columnReorder,
                tree
            } = grid.features;

        if (!treeGroup && !group) {
            throw new Error('GroupBar widget requires the TreeGroup or Group feature to be present');
        }

        columnReorder.usingGroupBarWidget = true;

        me.store = new Store({
            fields            : ['cls', 'ascending'],
            internalListeners : {
                add     : me.onStoreChanged,
                remove  : me.onStoreChanged,
                thisObj : me
            }
        });

        grid.ion({
            [tree ? 'treeGroupChange' : undefined] : me.onTreeGroupChanged,
            beforeColumnDropFinalize               : me.onBeforeColumnDropFinalize,
            columnDrag                             : me.onColumnDrag,
            columnDragStart                        : me.onColumnDragStart,
            columnDrop                             : me.onColumnDrop,
            thisObj                                : me
        });

        if (tree) {
            me.onTreeGroupChanged({ levels : treeGroup.levels });
        }
        else {
            grid.store.ion({
                group   : me.onGroupChanged,
                thisObj : me
            });
            me.onGroupChanged();
        }
    }

    onStoreChanged({ records }) {
        const
            me       = this,
            { grid } = me;

        if (!grid.isConstructing && records?.[0]?.cls !== 'b-drop-target') {
            me.ignoreGroupChange               = true;
            if (grid.features.treeGroup) {
                grid.features.treeGroup.levels = me.store.map(({ field }) => field);
            }
            else if (me.store.count > 0) {
                grid.store.group(me.store.records[0].field);
            }
            else {
                grid.store.clearGroupers();
            }
            me.ignoreGroupChange               = false;
        }
    }

    onGroupChanged() {
        const { groupers } = this.grid.store;
        this.store.data = groupers ? groupers.map(grouper => this.grid.columns.get(grouper.field)) : [];
    }

    onTreeGroupChanged({ levels }) {
        if (!this.ignoreGroupChange) {
            if (levels.some(level => level instanceof Function && !level.fieldName)) {
                throw new Error('GroupBar only supports column grouping');
            }

            this.store.data = (levels || []).map(level => {
                level = level.fieldName || level;
                return this.grid.columns.get(level);
            });
        }
    }

    onColumnDragStart({ column }) {
        this.store.add({ id : 'placeholder', cls : 'b-drop-target', text : this.grid.features.treeGroup ? undefined : column.text }); 
    }

    onColumnDrag({ context, column, event }) {
        const overGroupBar = event.target.closest('.b-groupbar');

        if (overGroupBar) {
            context.valid = column.groupable;
        }
    }

    onBeforeColumnDropFinalize({ column, event }) {
        const
            isTree = this.grid.features.tree,
            droppedOnGroupBar = event.target.closest('.b-groupbar');

        if (droppedOnGroupBar && column.groupable) {
            if (!isTree || !column.isTreeColumn) {
                this.store.getById('placeholder').remove();

                // Only one level of grouping supported with Group feature
                if (!isTree) {
                    this.store.removeAll(true);
                }
                this.store.add(column);
            }
        }
    }

    onColumnDrop() {
        this.store.getById('placeholder')?.remove();
    }
}

GroupBar.initClass();
