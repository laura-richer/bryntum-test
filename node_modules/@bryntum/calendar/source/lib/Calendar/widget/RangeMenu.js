import DateHelper from '../../Core/helper/DateHelper.js';
import StringHelper from '../../Core/helper/StringHelper.js';
import Menu from '../../Core/widget/Menu.js';

/**
 * @module Calendar/widget/RangeMenu
 */
const hasEventStore = w => w?.eventStore;

/**
 * A menu for selecting a time range for a Calendar mode.
 *
 * This is not intended to be used directly, but is instead used by the Calendar component.
 * @extends Core/widget/Menu
 * @classType rangemenu
 * @widget
 */
export default class RangeMenu extends Menu {
    static $name = 'RangeMenu';

    static type = 'rangemenu';

    static configurable = {
        autoShow   : false,
        view       : null,
        floating   : false,
        positioned : true,
        anchor     : true,
        defaults   : {
            checked : false
        },
        items : {
            listRangeDayItem : {
                range : 'day',
                text  : 'L{EventEdit.day}',
                _unit : 'day'
            },
            listRangeWeekItem : {
                range : 'week',
                text  : 'L{EventEdit.week}',
                _unit : 'week'
            },
            listRangeMonthItem : {
                range : 'month',
                text  : 'L{EventEdit.month}',
                _unit : 'month'
            },
            listRangeYearItem : {
                range : 'year',
                text  : 'L{EventEdit.year}',
                _unit : 'year'
            },
            listRangeDecadeItem : {
                range : 'decade',
                text  : 'L{EventEdit.decade}',
                _unit : 'decade'
            }
        }
    };

    construct() {
        super.construct(...arguments);
        this.ion({
            beforeShow : 'syncRangeOptions',
            toggle     : 'syncViewRange',
            thisObj    : this
        });
    }

    syncViewRange(e) {
        if (e.checked) {
            const
                { view } = this,
                { date } = view;

            // If our view is in startDate->endDate date mode, clear the values so that
            // reconfiguring will refresh
            if (!view.range) {
                view._date = view._endDate = null;
            }
            view.setConfig({
                range : e.item.range,
                date
            });
            e.bubbles = false;
        }
    }

    syncRangeOptions() {
        const
            { view }  = this,
            { range } = view;

        if (range) {
            const { unit, magnitude } = range;

            for (const menuItem of Object.values(this.items)) {
                if (menuItem) {
                    const itemConfig = {};

                    // Sync the menu with reality in case the view's range was changed.
                    // The Sidebar now does this if its DatePicker is multiselect.
                    // The cooperating views' ranges are set to the selection's encapsulating range.
                    if (menuItem._unit === unit) {
                        itemConfig.checked = true;
                        itemConfig.range = { unit, magnitude };
                        itemConfig.text = magnitude === 1 ? StringHelper.capitalize(DateHelper.getLocalizedNameOfUnit(unit)) : DateHelper.formatDelta(itemConfig.range);
                    }
                    else {
                        itemConfig.checked = false;
                        itemConfig.text = StringHelper.capitalize(DateHelper.getLocalizedNameOfUnit(menuItem._unit));
                        itemConfig.range = menuItem._unit;
                    }
                    menuItem.setConfig(itemConfig);
                }
            }
        }
    }

    changeItems(items) {
        const
            me          = this,
            view        = me.view || (me.view = me.up(hasEventStore)),
            toggleGroup = `${view.id}-range-items`;

        Object.values(items).forEach(item => {
            item && (item.toggleGroup = toggleGroup);
        });
        return super.changeItems(items);
    }

    updateView(view) {
        view?.scrollable.ion({
            overflowChange : () => this.realign?.()
        });
    }
}

// Register this widget type with its Factory
RangeMenu.initClass();
