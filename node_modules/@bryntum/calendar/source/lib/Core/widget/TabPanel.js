import ArrayHelper from '../helper/ArrayHelper.js';
import ObjectHelper from '../helper/ObjectHelper.js';
import Panel from './Panel.js';
import Tab from './Tab.js';

import './TabBar.js';
import './layout/Card.js';
import GlobalEvents from '../GlobalEvents.js';

/**
 * @module Core/widget/TabPanel
 */

const isMaximized = w => w.maximized;

/**
 * A tab panel widget which displays a collection of tabs, each of which can contain other widgets or HTML/text. This
 * widget has a {@link Core.widget.TabBar tab bar} on top of its contents, and each {@link Core.widget.Tab} can be
 * customized using the {@link Core.widget.Tab#config-tab} config.
 *
 * ```javascript
 * let tabPanel = new TabPanel({
 *  items: [
 *      {
 *          title: 'First',
 *          items: [
 *              { type: 'textfield', label: 'Name' },
 *              ...
 *          ]
 *      }, {
 *          title: 'Settings',
 *          tab : {
 *              // Show an icon in the tab
 *              icon : 'b-fa b-fa-cog'
 *          },
 *          items: [
 *              ...
 *          ]
 *      }
 *  ]
 * });
 *```
 *
 * The tab selector buttons are focusable elements. `Enter` or `Space` activates a tab, and moves
 * focus into the newly visible tab item.
 *
 * {@inlineexample Core/widget/TabPanel.js}
 *
 * ## Adding non tab items to the tab bar
 *
 * The {@link Core/widget/TabBar} is a subclass of the Toolbar, meaning you can add additional widgets to it. You can
 * add either {@link Core/widget/Container#config-tabBarItems tab-specific items} only shown for the active tab, or you
 * can add static extra items that are shown for all tabs.
 *
 * Demo showing tab-specific extra items using {@link Core/widget/Container#config-tabBarItems}.
 * {@inlineexample Core/widget/TabPanel2.js}
 *
 * Demo showing static extra items using {@link Core/widget/TabBar#config-items}
 * {@inlineexample Core/widget/TabPanelExtraTabItems.js}
 *
 * ## Tabs can be drag-dropped
 *
 * You can easily let users reorder the tabs by setting {@link Core/widget/TabBar#config-enableReordering} to `true`.
 *
 * {@inlineexample Core/widget/TabPanelDraggableTabs.js}
 *
 * @extends Core/widget/Panel
 * @classtype tabpanel
 * @classtypealias tabs
 * @widget
 */
export default class TabPanel extends Panel {
    //region Config

    static $name = 'TabPanel';

    static type = 'tabpanel';

    static alias = 'tabs';

    static configurable = {
        /**
         * The index of the initially active tab.
         * @member {Number} activeTab
         * @accepts {Number|Core.widget.Widget}
         */
        /**
         * The index of the initially active tab.
         * @config {Number}
         * @default
         */
        activeTab : 0,

        /**
         * Specifies whether to slide tabs in and out of visibility.
         * @config {Boolean}
         * @default
         */
        animateTabChange : true,

        /**
         * Set the height of all tabs to match the tab with the highest content.
         * @config {Boolean}
         * @default
         */
        autoHeight : false,

        defaultType : 'container',

        focusable : false,

        itemCls : 'b-tabpanel-item',

        layout : {
            type : 'card'
        },

        // Prevent child panels from displaying a header unless explicitly configured with one
        suppressChildHeaders : true,

        /**
         * Additional configuration for the tab bar.
         *
         * Use this to add more non-tab items to the bar:
         * ```javascript
         * new TabPanel({
         *    tabBar : {
         *       items : [
         *          '->', // Spacer which moves next item to the right
         *          { type : 'button', text : 'MyButton' }
         *       ]
         *    }
         * });
         * ```
         * @config {TabBarConfig}
         */
        tabBar : {
            type   : 'tabbar',
            weight : -2000
        },

        /**
         * Min width of a tab title. 0 means no minimum width. This is default.
         * @config {Number}
         * @default
         */
        tabMinWidth : null,

        /**
         * Max width of a tab title. 0 means no maximum width. This is default.
         * @config {Number}
         * @default
         */
        tabMaxWidth : null
    };

    //endregion

    //region Init

    /**
     * The active tab index. Setting must be done through {@link #property-activeTab}
     * @property {Number}
     * @readonly
     */
    get activeIndex() {
        return this.layout.activeIndex;
    }

    /**
     * The active child widget. Setting must be done through {@link #property-activeTab}
     * @property {Core.widget.Widget}
     * @readonly
     */
    get activeItem() {
        return this.layout.activeItem;
    }

    get activeTabItemIndex() {
        const { activeTab, items, tabBar } = this;

        return items.indexOf(tabBar.tabs[activeTab]?.item);
    }

    get bodyConfig() {
        return ObjectHelper.merge({
            className : {
                'b-tabpanel-body' : 1
            }
        }, super.bodyConfig);
    }

    get focusElement() {
        const activeTab = this.items[this.activeTab || 0];

        return activeTab?.focusElement || activeTab?.tab?.focusElement;
    }

    get tabPanelBody() {
        return this.bodyElement;
    }

    finalizeInit() {
        super.finalizeInit();

        const
            me                    = this,
            { activeTab, layout } = me,
            { activeIndex }       = layout,
            { tabs }              = me.tabBar,
            activeTabItemIndex    = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);

        if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {
            throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);
        }

        if (activeTabItemIndex !== activeIndex) {
            // Since we are responding to configuration, we need to sync activeIndex to activeTab as if it were the
            // initial value of activeIndex. This cannot be done (reasonably) during initialization of the card layout
            // because of the possibility of tabless items, so we wait until the dust settles on the items, the tabBar
            // and all other configs, but we must do the tab change silently (since the initial active item is set
            // without such ceremony) and without animation (to avoid the appearance of the initial tab animating in)
            layout.setActiveItem(activeTabItemIndex, activeIndex, {
                animation : false,
                silent    : true
            });
        }

        layout.animateCardChange = me.animateTabChange;
    }

    onChildAdd(child) {
        const me = this;

        // The layout will hide inactive new items.
        // And we must add our beforeHide listener *after* call super.
        super.onChildAdd(child);

        if (!me.initialItems) {
            const
                { tabBar }  = me,
                config      = me.makeTabConfig(child),
                // if child.tab === false, config will be null... no tab for this one
                firstTab    = config && tabBar?.firstTab,
                // if there are no tabs yet, this will be the first so we can skip all the indexing...
                tabBarItems = firstTab && tabBar._items,
                // not all items have tabs but the new child won't have one yet:
                tabItems    = firstTab && ArrayHelper.from(me._items, it => it.tab || it === child),
                // non-tabs could be in the tabBar, but the tabs must be contiguous:
                index       = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;

            if (config && tabBar) {
                if (firstTab && child.weight == null && index < tabBarItems.count - 1) {
                    tabBar.insert(config, index);
                }
                else {
                    tabBar.add(config);
                }
            }
        }
    }

    onChildRemove(child) {
        const
            me = this,
            { tab }   = child,
            { items } = me;

        if (tab) {
            me.tabBar.remove(tab);
            tab.destroy();
        }

        // Removing the active item, then show a sibling if any are left
        if (child === me.activeItem) {
            me._activeTab = null;
            if (items.length) {
                me.activeTab = items[Math.min(me.activeIndex, items.length - 1)];
            }
        }

        super.onChildRemove(child);

        if (child.tabBarItems) {
            me.tabBar.remove(child.tabBarItems);
        }
    }

    //endregion

    //region Tabs

    isDisabledOrHiddenTab(tabIndex) {
        const
            { tabs } = this.tabBar,
            tab      = tabs?.[tabIndex];
        return tab && (tab.disabled || tab.hidden);
    }

    findAvailableTab(item, delta = 1) {
        const
            { tabs }  = this.tabBar,
            tabCount  = tabs.length,
            itemIndex = Math.max(0, tabs.indexOf(item.tab));

        if (itemIndex) {
            delta = -delta;
        }

        let activeTab;

        for (let n = 1; n <= tabCount; ++n) {
            //  itemIndex=2, tabCount=5:
            //               n : 1, 2, 3, 4, 5
            //      delta =  1 : 3, 4, 0, 1, 2
            //      delta = -1 : 1, 0, 4, 3, 2
            activeTab = (itemIndex + ((delta < 0) ? tabCount : 0) + n * delta) % tabCount;
            if (!this.isDisabledOrHiddenTab(activeTab)) {
                break;
            }
        }
        return activeTab;
    }

    activateAvailableTab(item, delta = 1) {
        this.activeTab = this.findAvailableTab(item, delta);
    }

    changeActiveTab(activeTab, oldActiveTab) {
        const
            me           = this,
            {
                tabBar,
                layout
            }            = me,
            { tabCount } = tabBar;

        if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {
            // Must be a child widget, so add if it's not already in our items.
            if (me.items.indexOf(activeTab) === -1) {
                activeTab = me.add(activeTab);
            }

            activeTab = tabBar.indexOfTab(activeTab.tab);
        }
        else {
            activeTab = parseInt(activeTab, 10);
        }

        if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {
            throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);
        }

        if (me.isDisabledOrHiddenTab(activeTab)) {
            activeTab = me.findAvailableTab(activeTab);
        }

        // If we are animating, we must wait until any animation is finished
        // before we can go ahead and apply the change.
        if (layout.animateCardChange && layout.cardChangeAnimation) {
            layout.cardChangeAnimation.then(cardChange => {
                // If the animation resulted in not where we want, update the activeTab
                if (cardChange?.activeIndex !== activeTab) {
                    me._activeTab = activeTab;
                    me.updateActiveTab(activeTab, oldActiveTab);
                }
            });
        }
        else {
            return activeTab;
        }
    }

    async updateActiveTab(activeTab, was) {
        const me = this;

        if (!me.initialItems) {
            const { activeTabItemIndex, layout } = me;

            if (activeTabItemIndex > -1) {
                const newActiveItem = me.items[activeTabItemIndex];

                // Avoid no-change
                if (layout.activeItem !== newActiveItem) {
                    if (layout.animateCardChange) {
                        await me.tabSelectionPromise;
                    }
                    me.tabSelectionPromise = layout.setActiveItem(newActiveItem)?.promise;
                }
            }

            me.tabBar.remove(me.tabBar.items.filter(item => !item.isTab && item.trueOwner));
        }

        const activeItem = me.items[activeTab];

        if (activeItem?.tabBarItems) {
            activeItem.tabBarItems = me.tabBar.add(activeItem.tabBarItems);
            activeItem.tabBarItems.forEach(item => item.trueOwner = activeItem);
        }
    }

    changeTabBar(bar) {
        this.getConfig('strips');

        this.strips = {
            tabBar : bar
        };

        return this.strips.tabBar;
    }

    makeTabConfig(item) {
        const
            { tab } = item,
            config  = {
                item,

                type              : 'tab',
                active            : !item.hidden,
                tabPanel          : this,
                disabled          : Boolean(item.disabled),
                hidden            : item.initialConfig.hidden,
                weight            : item.weight || 0,
                internalListeners : {
                    click   : 'onTabClick',
                    thisObj : this
                },
                localizableProperties : {
                    // our tabs copy their text from the item's title and so are not directly localized
                    text : false
                }
            };

        if (tab === false) {
            return null;
        }

        return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;
    }

    updateAnimateTabChange(animateTabChange) {
        if (!this.isConfiguring) {
            this.layout.animateCardChange = animateTabChange;
        }
    }

    updateItems(items, was) {
        const
            me                          = this,
            { activeTab, initialItems } = me;

        let index = 0,
            tabs;

        super.updateItems(items, was);

        if (initialItems) {
            tabs = Array.from(items, it => me.makeTabConfig(it)).filter(it => {
                if (it) {
                    it.index = index++;
                    return true;
                }
            });

            if (index) {
                tabs[activeTab].active = true;

                me.tabBar.add(tabs);
                me.activeTab = activeTab;  // now we can validate the activeTab value
            }
        }
    }

    updateTabMinWidth(tabMinWidth) {
        this.tabBar?.items.forEach(tab => {
            if (tab.isTab) {
                tab.minWidth = tabMinWidth;
            }
        });
    }

    updateTabMaxWidth(tabMaxWidth) {
        this.tabBar?.items.forEach(tab => {
            if (tab.isTab) {
                tab.maxWidth = tabMaxWidth;
            }
        });
    }

    //endregion

    //region Auto height

    updateAutoHeight(autoHeight) {
        this.detachListeners('themeAutoHeight');

        autoHeight && GlobalEvents.ion({
            name    : 'themeAutoHeight',
            theme   : 'internalOnThemeChange',
            thisObj : this
        });
    }

    applyAutoHeight() {
        const
            me                             = this,
            { layout, activeTab, element } = me,
            { animateCardChange }          = layout;

        // stop animate to change tabs on back stage.
        layout.animateCardChange = false;

        // override any previously applied height when measuring
        me.flex = '0 0 0%';

        // Only actually apply a measured height if we are not inside a maximized widget
        if (!me.up(isMaximized)) {
            // get the max height comparing all tabs and apply to the tab
            const maxContentHeight = me.height = Math.max(...me.items.map(tab => {
                me.activeTab = tab;
                return element.clientHeight;
            })) + 1;

            me.flex = `1 1 ${maxContentHeight}px`;

        }

        // Go back to initial configs
        me.activeTab = activeTab;
        layout.animateCardChange = animateCardChange;
    }

    internalOnThemeChange() {
        if (this.isVisible) {
            this.applyAutoHeight();
        }
    }

    //endregion

    //region Events

    // Called after beforeActiveItemChange has fired and not been vetoed before animation and activeItemChange
    onBeginActiveItemChange(activeItemChangeEvent) {
        const
            tabs                           = this.tabBar.tabs,
            { activeItem, prevActiveItem } = activeItemChangeEvent;

        // Our UI changes immediately, our state must be accurate
        this.activeTab = tabs.indexOf(activeItem?.tab);

        // Deactivate previous active tab
        if (prevActiveItem?.tab) {
            prevActiveItem.tab.active = false;
        }

        if (activeItem?.tab) {
            activeItem.tab.active = true;
            activeItem.tab.show();
        }
    }

    // Auto called because Card layout triggers the beforeActiveItemChange on its owner
    onBeforeActiveItemChange(activeItemChangeEvent) {
        /**
         * The active tab is about to be changed. Return `false` to prevent this.
         * @event beforeTabChange
         * @preventable
         * @param {Number} activeIndex - The new active index.
         * @param {Core.widget.Widget} activeItem - The new active child widget.
         * @param {Number} prevActiveIndex - The previous active index.
         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.
         */
        return this.trigger('beforeTabChange', activeItemChangeEvent);
    }

    // Auto called because Card layout triggers the activeItemChange on its owner
    onActiveItemChange(activeItemChangeEvent) {
        /**
         * The active tab has changed.
         * @event tabChange
         * @param {Number} activeIndex - The new active index.
         * @param {Core.widget.Widget} activeItem - The new active child widget.
         * @param {Number} prevActiveIndex - The previous active index.
         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.
         */
        this.trigger('tabChange', activeItemChangeEvent);
    }

    onTabClick(event) {
        const { item } = event.source;

        if (item.tab.closable && event.event.target.classList.contains('b-tab-close')) {
            this.remove(item);
        }
        else {
            this.activeTab = item;
        }
    }

    onInternalPaint() {
        super.onInternalPaint(...arguments);

        // Measure tabs on every paint if configured to do so
        if (this.autoHeight) {
            this.applyAutoHeight();
        }
    }

    onValidityChange({ source, valid }) {
        const
            owningTab = source.closest(widget => widget.element.classList.contains('b-tabpanel-item')),
            { tab } = owningTab;

        tab.element.classList.toggle('b-invalid', !valid);

        tab.ariaLabel = valid ? '' : this.L('L{TabPanel.containsInvalidFields}');
    }

    //endregion
}

// Register this widget type with its Factory
TabPanel.initClass();
