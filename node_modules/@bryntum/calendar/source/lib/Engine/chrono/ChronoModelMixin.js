import { Mixin } from "../../ChronoGraph/class/BetterMixin.js";
import { Entity } from "../../ChronoGraph/replica/Entity.js";
import Model from "../../Core/data/Model.js";
import ObjectHelper from "../../Core/helper/ObjectHelper.js";
import { ProposedOrPrevious } from "../../ChronoGraph/chrono/Effect.js";
import { ChronoModelReferenceBucketFieldIdentifier, ChronoModelReferenceFieldIdentifier, ModelReferenceField } from "./ModelFieldAtom.js";
import { CalculatedValueGen } from "../../ChronoGraph/chrono/Identifier.js";
/**
 * This is a base mixin, which mixes together the ChronoGraph's [Entity](https://bryntum.com/products/gantt/docs/engine/modules/_lib_chronograph_replica_entity_.html)
 * and the Bryntum Core [Model](https://bryntum.com/products/grid/docs/api/Core/data/Model)
 *
 * It is used as a very base mixin for all other entities in the project.
 */
export class ChronoModelMixin extends Mixin([Entity, Model], (base) => {
    const superProto = base.prototype;
    class ChronoModelMixin extends base {
        // This is a marker for Models which have the Engine API available.
        get isEntity() {
            return true;
        }
        /**
         * Calculation function that simply returns current ([[ProposedOrPrevious|proposed or previous]]) value of
         * an identifier.
         */
        *userProvidedValue() {
            return yield ProposedOrPrevious;
        }
        copy(newId = null, deep = null) {
            const copy = superProto.copy.call(this, newId, deep);
            const { creatingOccurrence } = deep ?? {};
            // If deep is everything but object - use default behavior, which is to invoke accessors
            // If deep is an object, check if it has certain field disabled
            if ((ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers) || !ObjectHelper.isObject(deep)) {
                this.forEachFieldIdentifier((identifier, fieldName, field) => {
                    if (!field.lazy &&
                        // @ts-ignore
                        this.getFieldDefinition(fieldName)?.type !== 'store' && (
                    // Do not copy buckets for non-occurrences (for example task.incomingDeps, since it contains
                    // records related to the original, not the copy)
                    (!creatingOccurrence && !(identifier instanceof ChronoModelReferenceBucketFieldIdentifier))
                        // Only include buckets and references for occurrences, they will not be part of graph and
                        // will handle their own dates etc
                        || (creatingOccurrence && (identifier instanceof ChronoModelReferenceBucketFieldIdentifier
                            || identifier instanceof ChronoModelReferenceFieldIdentifier)))) {
                        copy[fieldName] = this[fieldName];
                    }
                });
            }
            return copy;
        }
        applyValue(useProp, key, value, skipAccessors, field) {
            // key is the dataSource, we need to check for the field name instead
            const chronoField = this.$entity.getField(field?.name || key);
            if (chronoField)
                useProp = true;
            if (skipAccessors)
                useProp = false;
            superProto.applyValue.call(this, useProp, useProp ? field?.name ?? key : key, value, skipAccessors, field);
        }
        get isInActiveTransaction() {
            // Might not have joined graph when using delayed calculation
            const activeTransaction = this.graph?.activeTransaction;
            return Boolean(activeTransaction?.getLatestEntryFor(this.$$));
        }
        get $entityName() {
            const className = this.constructor.name || this.$entity.name;
            const id = this.internalId;
            return `${className}${id != null ? '-' + String(id) : ''}`;
        }
        trackFieldChanges(fieldName) {
            if (!this.fieldChangeTrackers) {
                this.fieldChangeTrackers = new Map();
            }
            const trackers = this.fieldChangeTrackers;
            let identifier = trackers.get(fieldName);
            if (!identifier) {
                // make a special identifier for tracking
                identifier = this.graph.addIdentifier(CalculatedValueGen.new({
                    context: this,
                    *calculation() {
                        // return the field value
                        return this[fieldName];
                    },
                }));
                trackers.set(fieldName, identifier);
            }
            return identifier;
        }
        untrackFieldChanges(fieldName) {
            const graph = this.graph;
            const trackers = this.fieldChangeTrackers;
            if (trackers) {
                if (fieldName) {
                    const identifier = trackers.get(fieldName);
                    if (identifier && graph) {
                        graph.removeIdentifier(identifier);
                    }
                    trackers.delete(fieldName);
                }
                else {
                    if (graph) {
                        for (const [, identifier] of trackers) {
                            graph.removeIdentifier(identifier);
                        }
                    }
                    trackers.clear();
                }
                if (!trackers.size) {
                    this.fieldChangeTrackers = undefined;
                }
            }
        }
        enterGraph(replica) {
            super.enterGraph(replica);
            if (this.fieldChangeTrackers) {
                for (const identifier of this.fieldChangeTrackers.values()) {
                    replica.addIdentifier(identifier);
                }
            }
        }
        leaveGraph(replica) {
            super.leaveGraph(replica);
            if (this.fieldChangeTrackers) {
                for (const identifier of this.fieldChangeTrackers.values()) {
                    replica.removeIdentifier(identifier);
                }
            }
        }
        unlink() {
            // Might not have entered replica yet when using delayed calculation
            if (this.graph) {
                const { activeTransaction } = this.graph;
                const { $ } = this;
                const keys = Object.keys($);
                // Write current values to identifier.DATA, to have correct value entering new replica later
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const identifier = $[key];
                    const entry = activeTransaction.getLatestStableOrProposedEntryFor(identifier);
                    if (entry) {
                        let value = entry.getValue();
                        if (value === undefined)
                            value = entry.proposedValue;
                        if (value !== undefined) {
                            identifier.DATA = identifier.field instanceof ModelReferenceField
                                ? value?.id ?? value
                                : value;
                        }
                    }
                }
                // Cut the link, to enable joining another replica
                this.graph = null;
            }
        }
    }
    return ChronoModelMixin;
}) {
}
