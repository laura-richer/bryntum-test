import DayView from './DayView.js';
import DayTime from '../../Core/util/DayTime.js';
import DH from '../../Core/helper/DateHelper.js';
import Rectangle from '../../Core/helper/util/Rectangle.js';
import DomHelper from '../../Core/helper/DomHelper.js';

/**
 * @module Calendar/widget/DayAgendaView
 */

const
    { MILLIS_PER_HOUR } = DayTime,
    zeroRect            = new Rectangle(0, 0, 0, 0),
    flowDirection       = {
        column     : 'column',
        vertical   : 'column',
        row        : 'row',
        horizontal : 'row'
    };

/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar (as seen in the live
 * demo below), but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Panel which displays one or more columns of days with events for each day arranged in ascending
 * time order in each column.
 *
 * Unlike the regular {@link Calendar.widget.DayView}, events are rendered as full width, auto heighted blocks,
 * flowing down each day column in ascending order, causing the hour row to expand to accommodate them.
 *
 * Events are placed into the hour row in which they *begin*
 *
 * Events may be dragged *between hours*. The drop granularity is in one hour increments, so you can move events to start
 * on an hour boundary. Edit the event to set the minutes.
 *
 * {@inlineexample Calendar/widget/CalendarDayAgendaView.js}
 *
 * This view is *not* limited to showing a single day. The {@link #config-date} and {@link #config-range}
 * or {@link #config-startDate} and {@link #config-endDate} may be configured to cover any range.
 *
 * When using {@link #config-range}, setting the {@link #config-date} snaps the view to the start of a range
 * (for example `'1 week'`) which encapsulates the requested date.
 *
 * When the {@link #config-startDate} is changed dynamically, the duration remains the same.
 *
 * This view can be configured to scroll to the specific time on first render, which defaults to 7 AM. This behavior
 * is controlled by the {@link #config-visibleStartTime} config.
 *
 * Event rendering can be customized using the {@link #config-eventRenderer} method.
 *
 * @demo Calendar/day-agenda
 * @extends Calendar/widget/DayView
 *
 * @classtype dayagenda
 * @typingswidget
 */
export default class DayAgendaView extends DayView {

    static $name = 'DayAgendaView';

    static type = 'dayagenda';

    static get delayable() {
        return {
            updateElementLayout : {
                type              : 'raf',
                cancelOutstanding : true
            },
            refreshDayBackground : {
                type              : 'raf',
                cancelOutstanding : true
            },
            scrollToVisibleStartTime : {
                type              : 'raf',
                cancelOutstanding : true
            }
        };
    }

    static configurable = {
        // region Hidden configs
        /**
         * @hideconfigs shortEventDuration, eventHeight, HourHeightBreakPoints, increment, eventLayout, increment
         * timeAxisTimeFormat, fitHours, zoomOnMouseWheel, sixMinuteTicks, timeSnapType, showCurrentTime, shortEventCls
         */

        // No such thing as a short event in this view.
        // Event blocks are intrinsically heighted by content.
        shortEventCls : '',

        // endRegion

        increment : '1 h',

        showCurrentTime : false,

        /**
         * The height __in pixels__ of an *empty* hour row.
         *
         * Hour rows grow to accommodate events when they contain events.
         * @prp {Number} hourHeight
         * @default
         */
        hourHeight : 55,

        showTime : {
            startTime : true,
            endTime   : true
        },

        /**
         * How much vertical whitespace between the hour cells.
         * @prp {Number|String}
         */
        hourSpacing : '0.5em',

        /**
         * Set this to true to hide empty hour rows in this day agenda.
         *
         * Note that if {@link #config-syncHourHeights} is set, then empy hours will show where any column
         * has events for that hour because all row meights must match in this case.
         * @prp {Boolean}
         */
        hideEmptyHours : null,

        /**
         * Set this to true to hide the time cells in the day columns.
         * @prp {Boolean}
         */
        hideTimeAxis : null,

        /**
         * The color of the borders (if any) between hour rows and day rows.
         * @prp {String}
         */
        borderColor : null,

        /**
         * Set this to true to hide the borders between cells.
         * @prp {Boolean}
         */
        hideBorders : null,

        title : 'L{dayAgenda}',

        timeSnapType : 'floor',

        /**
         * How much space to leave empty at the right side of day columns to allow interaction such as
         * double click or drag.
         * @prp {Number|String}
         * @default
         */
        gutterWidth : 10,

        /**
         * Which direction to flow events in an hour row, vertically (the default), or horizontally.
         * @prp {'column'|'row'}
         * @default 'column'
         */
        eventFlowDirection : null,

        /**
         * How much vertical space to leave between event bars in a cell.
         * @prp {Number|String}
         * @default
         */
        eventSpacing : 5,

        /**
         * By default the hours across a multiple day view may have different heights because of different
         * event loads.
         *
         * Soecify this as `true` to sync hour heights so that each spans the event load for the hour.
         * @prp {Boolean}
         */
        syncHourHeights : null,

        /**
         * The minimum event width when {@link #config-eventFlowDirection} is `'row'`.
         * @prp {Number|String}
         * @default
         */
        minEventWidth : null,

        overHour : null
    };

    // Topsy-turvey hour heights means durations cannot be accurately determined.
    // Drag *moving* is fine because a drop *position* can be acurately determined.
    allowDragCreate = false;
    allowDragResizee = false;

    // dayTime

    /**
     * Returns the pixel coordinate on the time axis for the passed time of day.
     * Because hour elements may be variable height in this view, this returns the bottom Y position for the passed hour.
     * @param {Date|Number|String} time The hour number, 'HH:MM' time or a `Date` instance.
     * @internal
     * @returns {Number}
     */
    getPositionFromTime(time) {
        // If it's not possible, return 0. DayTime returns the positive delta.
        if (DayTime.parse(time) < DayTime.parse(this.dayStartTime) - this.dayStartShift) {
            return 0;
        }
        const
            hour   = DayTime.parse(time) / (1000 * 60 * 60),
            hourEl = this.eventContentElement.querySelector('[data-date]')?.querySelector(`[data-hour="${hour}"]`);

        return hourEl ? hourEl.offsetTop + hourEl.offsetHeight : 0;
    }

    getDateFromDomEvent(domEvent, precise = false) {
        const
            me   = this,
            el   = DomHelper.getEventElement(domEvent),
            date = this.getDateFromElement(el);

        // Override to add a time component to the DOM event's date if we receive and event (not an element) and
        // the event was in the day container.
        if (date && el !== domEvent && me.dayContainerElement.contains(el)) {
            // Find closest hour element, or last hour element if none is found
            let hourEl = el.closest('[data-hour]'),
                hour   = parseInt(hourEl?.dataset.hour || 0);

            // If click is beyond the end of the *visible* hours, set the time to the next hour after the last visible hour.
            // But constrain that to be within the dayEndHour range
            if (!hourEl) {
                hourEl = [...el.querySelectorAll(`[data-hour]${me.hideEmptyHours ? '.b-has-events' : ''}`)].at(-1);
                hour   = Math.min(parseInt(hourEl?.dataset.hour || -1) + 1, me.dayEndHour - 1);
            }

            date.setHours(hour);
        }

        return date;
    }

    getDateFromPosition(clientX, clientY, local = false, keyParser) {
        const
            me       = this,
            {
                eventContentElement,
                allDayEvents
            }        = me,
            rect     = local ? zeroRect : Rectangle.fromScreen(eventContentElement).roundPx().translate(-eventContentElement.scrollLeft),
            width    = eventContentElement.scrollWidth,
            localX   = local ? clientX : clientX - rect.x,
            dx       = me.rtl ? me.eventContentElement.offsetWidth - localX : localX,
            dy       = clientY - rect.y,
            // We have to compare element position because day columns may have different widths
            overCell = me.getDayElementFromX(clientX),
            height   = overCell.offsetHeight,
            // Completely empty views must return their date.
            // DayView can hide empty days and DayResourceView can hide empty resources which can result
            // in no day cells being rendered. This method must yield a valid Date.
            date     = me.getDateFromElement(overCell, keyParser) || me.date;

        if (allDayEvents && (dx < 0 || width < dx || dy < 0 || height < dy)) {
            // CalendarDrag will pass this view's DayTime so pass it into CalendarRow
            return allDayEvents.getDateFromPosition(clientX, clientY, keyParser);
        }

        // DateHelper.add() operates in UTC and therefore does not respect DST, so we cannot do this:
        //   DH.add(DH.clearTime(date), me.dayStartMs + Math.floor(dy / height * me.getDayLength()), 'ms')

        // Instead, we leverage setMilliseconds()'s ability to handle denormalized values:
        DH.clearTime(date, /*clone = */false);

        const hourCells = [...overCell.querySelectorAll('.b-day-agenda-hour')];

        let hourCell, i;

        // See which hourCell we are over
        for (
            i = 0, hourCell = hourCells[i];
            i < hourCells.length && dy >= hourCell.offsetTop && dy > hourCell.offsetTop + hourCell.offsetHeight;
            hourCell = hourCells[i], i++
        );

        date.setHours(parseInt(hourCell.dataset.hour));

        const hourPosition = (dy - hourCell.offsetTop) / hourCell.offsetHeight;
        date.setMilliseconds(date.getMilliseconds() + hourPosition * MILLIS_PER_HOUR);

        return DH[me.timeSnapType](date, me.increment);
    }

    getBaseDayDomConfig(date) {
        const
            me             = this,
            {
                dateFilter,
                resource
            }              = me,
            key            = me.dayTime.dateKey(date),
            cellData       = me.cellMap.get(key) || (me.cellMap.set(key, me.createCellData(date))).get(key), // dayCellRenderer & timeRanges need one
            { day }        = cellData,
            // Skip hidden, nonworking days (unless we're a single day view).
            // Skip empty days if configured to do so.
            skipDay        = (me.hiddenNonWorkingDays[day] && me.duration !== 1) || (me.hideEmptyDays && !me.getEventsForDay(key).length) || (dateFilter && !me.callback(dateFilter, me, [cellData]));

        // Ingest lazy config
        me.getConfig('showCurrentTime');

        // Return nullish for skipped days.
        if (!skipDay) {
            const
                nonWorkingDays = me.nonWorkingDays || me.month.nonWorkingDays,
                children       = [];

            me.eachHour((hour, time) =>  {
                time.setHours(hour);

                children.push({
                    className : {
                        'b-day-agenda-hour' : 1,
                        'b-has-events'      : 0
                    },
                    dataset : {
                        hour
                    },
                    children : {
                        time : {
                            className : {
                                'b-day-agenda-hour-time' : 1
                            },
                            text : DH.format(time, me.timeAxisTimeFormat)
                        },
                        events : {
                            className : {
                                'b-day-agenda-hour-events' : 1
                            },
                            children : []
                        }
                    }
                });
            });

            return [cellData, {
                tabIndex     : -1,
                role         : 'gridcell',
                'aria-label' : `${DH.format(date, 'dddd Do MMMM')}${resource ? ` ${resource.name}` : ''}, ${me.L('L{eventCount}', cellData.events?.length || 0)}.`,
                dataset      : {
                    date : key
                },
                className : {
                    'b-dayview-day-detail'   : 1,
                    [me.dayCellCls]          : 1,
                    [me.nonWorkingDayCls]    : nonWorkingDays[day] || false,
                    [me.weekendCls]          : DH.weekends[day],
                    [me.todayCls]            : !(date - me.today),
                    'b-last-cell'            : !(date - me.lastVisibleDate),
                    [`b-day-of-week-${day}`] : 1
                },
                style : {},
                children,

                // Match existing data-event-id elements first and ensure DOM order matches
                // children order.
                syncOptions : {
                    syncIdField      : 'eventId',
                    releaseThreshold : 0,
                    strict           : true
                }
            }];
        }
    }

    getDayDomConfig(date) {
        const
            me   = this,
            base = me.getBaseDayDomConfig(date);

        if (base) {
            const
                { dayCellRenderer } = me,
                [cellData, dayDomConfig] = base;

            // Render events if any. Call even if we have no events to allow beforeLayoutEvents event to fire and
            // listeners to act (e.g., timeRanges)
            me.renderEvents(cellData, dayDomConfig);

            return DomHelper.normalizeChildren(
                dayCellRenderer ? me.callback(dayCellRenderer, me, [dayDomConfig, cellData]) : dayDomConfig);
        }
    }

    /**
     * Pushes event bar DomConfig definitions into the `children` property of the passed
     * `dayDomConfig` object
     * @param {DayCell} cellData An object containing information about the day cell being created.
     * @param {DomConfig} dayDomConfig The DomConfig element definition for the day cell.
     * @internal
     */
    renderEvents(cellData, dayDomConfig) {
        for (const eventRecord of cellData.events) {
            const hourDomConfig = dayDomConfig.children[eventRecord.startDate.getHours() - this.dayTime.startHour];

            // If its start hour is withon our visible day, add it to its start hour
            if (hourDomConfig) {
                const eventDomConfig = this.createEventDomConfig({ date : cellData.date, eventRecord });

                this.insertActionButtons(eventDomConfig.children[0].children[0].children, eventRecord, cellData);
                hourDomConfig.className['b-has-events'] = 1;
                hourDomConfig.children.events.children.push(eventDomConfig);
            }
        }
        this.trigger('renderEvents', cellData);
    }

    onInternalResize(element, width, height, oldWidth) {
        super.onInternalResize(...arguments);

        // Width change means that event bars may change height, so we need to sync hour heights
        if (width !== oldWidth && this.syncHourHeights) {
            this.syncHeights();
        }
    }

    // This view can't do this
    changeShowCurrentTime() {
        return false;
    }

    onDayContentMousewheel() {}

    /**
     * Does nothig in this class
     * @private
     */
    zoomBy() { }

    /**
     * Does nothig in this class
     * @private
     */
    zoomTo() {}

    /**
     * Does nothig in this class
     * @private
     */
    async zoomToFit() {}

    /**
     * This is invalid for this view
     * @private
     */
    get dayStartOffset() {
        return 0;
    }

    changeEventLayout() {}

    syncCurrentTimeIndicators() {}

    updateEventSpacing(eventSpacing) {
        this.element.style.setProperty('--event-spacing', DomHelper.setLength(eventSpacing));
        this.refreshDayBackground();
    }

    updateMinEventWidth(minEventWidth) {
        this.element.style.setProperty('--min-event-width', DomHelper.setLength(minEventWidth));
        this.refreshDayBackground();
    }

    updateHourSpacing(hourSpacing) {
        this.element.style.setProperty('--hour-event-padding-top', DomHelper.setLength(hourSpacing));
        this.refreshDayBackground();
    }

    updateGutterWidth(gutterWidth) {
        this.element.style.setProperty('--gutter-width', DomHelper.setLength(gutterWidth));
        this.refreshDayBackground();
    }

    updateHideEmptyHours(hideEmptyHours) {
        this.element.classList.toggle('b-hide-empty-hours', Boolean(hideEmptyHours));
        this.refreshDayBackground();
    }

    updateHideTimeAxis(hideTimeAxis) {
        this.element.classList.toggle('b-hide-timeaxis', Boolean(hideTimeAxis));
        this.refreshDayBackground();
    }

    updateHideBorders(hideBorders) {
        this.element.classList.toggle('b-hide-borders', Boolean(hideBorders));
        this.refreshDayBackground();
    }

    updateBorderColor(borderColor) {
        this.element.style.setProperty('--hour-border-color', borderColor);
    }

    changeEventFlowDirection(eventFlowDirection) {
        return flowDirection[eventFlowDirection];
    }

    updateEventFlowDirection(eventFlowDirection) {
        this.element.style.setProperty('--event-flow-direction', eventFlowDirection);
        this.element.classList.toggle('b-event-flow-row', eventFlowDirection === 'row');
        this.refreshDayBackground();
    }

    updateSyncHourHeights(syncHourHeights) {
        this.element.classList.toggle('b-synced-hour-heights', Boolean(syncHourHeights));
        this.refresh();
    }

    updateOverHour(overHourDate, lastOverHourDate) {
        lastOverHourDate && this.getHourElement(lastOverHourDate)?.classList.toggle('b-hover-hour', false);
        overHourDate && this.getHourElement(overHourDate)?.classList.toggle('b-hover-hour', true);
    }

    getHourElement(date) {
        return this.getDayElement(date)?.querySelector(`[data-hour="${date.getHours()}"]`);
    }

    // Template method from DayView
    onDayCellConfigGenerated(dayCells) {
        // If we are syncing hour heights, then if any hour has events, all hours have events
        if (this.syncHourHeights) {
            const { timeAxisElement } = this;

            this.eachHour((hour, date, i) => {
                const
                    hasEvents = dayCells.some(dayCell => dayCell.children[i].className['b-has-events']),
                    tick      = timeAxisElement.querySelector(`[data-hour="${hour}"]`);

                dayCells.forEach(dayCell => dayCell.children[i].className['b-has-events'] = hasEvents);
                tick.classList.toggle('b-has-events', hasEvents);
            });
        }
    }

    onRefreshDayBackground() {
        super.onRefreshDayBackground?.();
        this.whenVisible('syncHeights');
    }

    syncHeights() {
        const
            me = this,
            {
                timeAxisElement,
                dayContainerElement,
                syncHourHeights
            }  = me;

        // If the use case of this view is to show an unseparated list of events for the day, then don't
        // pad up the hour height to the configured value.
        me.contentElement.style.setProperty('--hour-height', (me.hideEmptyHours && me.hideBorders) ? 'auto' : `${me.hourHeight}px`);

        // Remove all set heights
        dayContainerElement.querySelectorAll('.b-day-agenda-hour').forEach(h => h.style.minHeight = '');

        me.eachHour(hour => {
            const
                hourCells = [...dayContainerElement.querySelectorAll(`.b-day-agenda-hour[data-hour="${hour}"]`)],
                maxHeight = syncHourHeights ? `${Math.max(...hourCells.map(h => h.offsetHeight))}px` : '',
                tick      = timeAxisElement.querySelector(`[data-hour="${hour}"]`);

            // Sync the height of the hour cells
            hourCells.forEach(h => {
                h.style.minHeight = maxHeight;
            });

            // Sync the height of the time axis time cells
            tick.style.minHeight = maxHeight;
        });
    }

    getTimeElementConfigs() {
        const result = [];

        this.eachHour((hour, time) => {
            result.push({
                className : {
                    'b-day-agenda-hour' : 1
                },
                dataset : {
                    hour
                },
                children : [{
                    className : 'b-day-agenda-hour-time',
                    text      : DH.format(time, this.timeAxisTimeFormat)
                }]
            });
        });
        return result;
    }
}

DayAgendaView.initClass();
