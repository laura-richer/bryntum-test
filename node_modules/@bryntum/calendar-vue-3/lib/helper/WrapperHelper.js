import { nextTick as E } from "vue";
import { Widget as C } from "@bryntum/calendar";
class l {
  /**
   * Development warning. Showed when environment is set to 'development'
   * @param {String} clsName vue component instance
   * @param {String} msg console message
   */
  static devWarning(t, e) {
    var s;
    ((s = window.bryntum) != null && s.isTestEnv || process.env.NODE_ENV === "development") && console.warn(
      `Bryntum${t}Component development warning!
${e}
Please check Vue integration guide: https://bryntum.com/products/grid/docs/guide/Grid/integration/vue/guide`
    );
  }
  static devWarningContainer(t, e) {
    l.devWarning(
      t,
      `Using "${e}" parameter for configuration is not recommended.
Widget is placed automatically inside it's container element.
Solution: remove "${e}" parameter from configuration.`
    );
  }
  static devWarningConfigProp(t, e) {
    l.devWarning(
      t,
      `Using "${e}" parameter for configuration is not recommended.
Solution: Use separate parameter for each "${e}" value to enable reactive updates of the API instance`
    );
  }
  static devWarningUpdateProp(t, e) {
    l.devWarning(
      t,
      `"${e}" is a static config option for component constructor only. No runtime changes are supported!`
    );
  }
  static camelize(t) {
    return t.replace(/-./g, (e) => e[1].toUpperCase());
  }
  static capitalize(t) {
    return t.charAt(0).toUpperCase() + t.slice(1);
  }
  /**
   * Returns `true` if the provided configuration object is valid for Vue processing.
   * @param {*} config
   * @returns {Boolean}
   */
  static isVueConfig(t) {
    return !!(t != null && t.vue);
  }
  /**
   * Creates bryntum component config from vue component
   * @param {Object} context
   * @param {Object} context.me vue component instance
   * @param {Object} context.widgetData reference to data
   * @param {Function} context.emit reference to emit
   * @param {Object} context.element HTML element
   * @param {Function} context.processCellContent cell renderer method
   * @param {Function} context.processEventContent event renderer method
   * @param {Function} context.processWidgetContent widget renderer method
   * @param {Function} context.hasFrameworkRenderer checks presence of vue renderer
   * @param {Function} context.toRaw Vue fn to unwrap reactive object
   * @returns {Object} config object
   */
  static createConfig({
    me: t,
    widgetData: e,
    emit: s,
    element: i,
    processCellContent: n,
    processEventContent: o,
    processWidgetContent: r,
    hasFrameworkRenderer: a,
    toRaw: u
  }) {
    const f = {}, d = t.vnode.props || {};
    for (const c of Object.keys(d))
      f[this.camelize(c)] = d[c];
    const {
      instanceClass: m,
      instanceName: b
    } = e, y = (c) => f[c] !== void 0, $ = (e.configNames || []).filter(y), v = (e.propertyConfigNames || []).filter(y), h = (e.propertyNames || []).filter(y), N = (e.featureNames || []).filter(y), V = e.eventNames.filter((c) => !y(c) && !f[`on${this.capitalize(c)}`]), p = {
      vueComponent: t,
      listeners: {},
      features: {},
      processCellContent: n,
      processEventContent: o,
      processWidgetContent: r,
      hasFrameworkRenderer: a
    };
    V.forEach((c) => p.listeners[c] = (P) => s(c, P)), [
      ...$,
      ...v,
      ...N
    ].forEach((c) => {
      l.applyPropValue(p, c, f[c], !0, u), ["features", "config"].includes(c) && l.devWarningConfigProp(m.$name, c);
    }), p.cls = (p.cls || "") + ` b-vue-${m.$name.toLowerCase()}-container`, e.configNames = $, e.propertyNames = [
      ...$,
      ...h,
      ...v,
      ...N
    ], e.eventNames = [], e.propertyConfigNames = [], e.featureNames = [];
    const g = [
      "adopt",
      "appendTo",
      "insertAfter",
      "insertBefore"
    ].find((c) => p[c]);
    return g ? l.devWarningContainer(m.$name, g) : b === "Button" ? p.appendTo = i : p.adopt = i, p;
  }
  /**
   * Setup store events relay
   * @param {Object} data reference to data
   * @param {Object} instance bryntum widget instance
   */
  static relayStores(t, e) {
    const { dataStores: s, projectStores: i } = t;
    s && (Object.keys(s).forEach((n) => {
      const o = i ? e.project[n] : e[n];
      o && (o.syncDataOnLoad = o.syncDataOnLoad == null ? !0 : o.syncDataOnLoad, e && e.relayStoreEvents && o.relayAll(e, s[n]));
    }), delete t.dataStores);
  }
  /**
   * Creates bryntum Widget from vue component
   * @param {Object} config
   * @param {Object} config.me vue component instance
   * @param {Object} config.widgetData reference to data
   * @param {Function} config.emit reference to emit
   * @param {Object} config.element HTML element
   * @param {Function} config.processCellContent cell renderer method
   * @param {Function} config.hasFrameworkRenderer check the presence of vue renderer
   * @param {Function} config.toRaw Vue fn to unwrap reactive object
   * @returns {Object} widget object
   */
  static createWidget(t) {
    const { instanceClass: e } = t.widgetData, s = l.createConfig(t);
    return e.$name === "Widget" ? C.create(s) : new e(s);
  }
  /**
   * Applies property value to Bryntum config or instance.
   * @param {Object} configOrInstance target object
   * @param {String} prop property name
   * @param {Object} value value
   * @param {Boolean} [isConfig] config setting mode
   * @param {Function} [toRaw] Vue fn to unwrap reactive object
   */
  static applyPropValue(t, e, s, i = !0, n) {
    if (e === "project")
      s && typeof s == "object" && (t[e] = s.instance ? s.instance.value || s.instance : s);
    else if (e === "features" && typeof s == "object")
      Object.keys(s).forEach((o) => l.applyPropValue(t, `${o}Feature`, s[o], i, n));
    else if (e === "config" && typeof s == "object")
      Object.keys(s).forEach((o) => l.applyPropValue(t, o, s[o], i, n));
    else if (e === "columns" && !i)
      t.columns.data = s;
    else if (e.endsWith("Feature")) {
      const o = t.features, r = e.replace("Feature", "");
      if (i)
        o[r] = s;
      else {
        const a = o[r];
        a && a.setConfig(s);
      }
    } else
      t[e] = n ? n(s) : s;
  }
  /**
   * Creates watches for vue component properties
   * @param {Object} me vue component instance
   * @param {Object} instance bryntum widget instance
   * @param {Object} props reference to props
   * @param {Object} data reference to data
   * @param {Function} watcher watch method reference (Accepts: prop and newValue)
   */
  static watchProps(t, e, s) {
    const {
      configNames: i,
      propertyNames: n,
      instanceClass: o
    } = e;
    n.forEach((r) => s(r, (a) => {
      const u = Array.isArray(a) ? a.slice() : a;
      l.applyPropValue(t, r, u, !1), i.includes(r) && l.devWarningUpdateProp(o.$name, r);
    })), e.configNames = [], e.propertyNames = [];
  }
  /**
   * Called from Widget.js to add the Vue component to teleports
   * @param {Object} context
   * @param {Widget} context.widget Widget which content is rendered by the Vue component
   * @param {Object} context.html Object containing the Vue component properties and event listeners
   */
  static processWidgetContent({ widget: t, html: e }) {
    const { is: s, bind: i = {}, vue: n, on: o = {} } = e, { vueComponent: r } = this, { teleports: { value: a } } = r.provides, { contentElement: u, id: f } = t;
    if (n) {
      const d = `key-${f}`;
      a.has(d) && a.delete(d), E(() => {
        a.set(d, { bind: i, on: o, key: d, is: s, to: u });
      });
    }
  }
  /**
   * Handles the content provided by a Vue component for the widget.
   * @param {Widget} widget Owner widget
   * @param {String} html The HTML content to be processed
   */
  static handleVueContent(t, e) {
    var o;
    const s = (r) => {
      var a, u;
      return !!((u = (a = r.vueComponent) == null ? void 0 : a.provides) != null && u.teleports);
    }, i = t.closest(s), n = i != null && i.vueComponent ? i : C.query(s);
    (o = n == null ? void 0 : n.processWidgetContent) == null || o.call(n, { widget: t, html: e });
  }
  /**
   * Event renderer method
   * @param {Object} context
   * @param {*} context.jsx
   * @param {DomConfig} context.domConfig
   * @param {HTMLElement} context.targetElement
   * @param {Boolean} context.isRelease
   * @returns {Boolean}
   */
  static processEventContent({
    // Core passes it as jsx for React wrappers.
    // Let's rename it to a more appropriate name.
    jsx: t,
    domConfig: e,
    targetElement: s,
    isRelease: i
  }) {
    var a, u;
    let n = s, o = !1;
    const r = this.isVertical ? (a = e == null ? void 0 : e.elementData) == null ? void 0 : a.renderData : e == null ? void 0 : e.elementData;
    if (l.isVueConfig(t) && (t != null && t.is)) {
      (u = e == null ? void 0 : e.dataset) != null && u.isMilestone ? n = s.parentElement.parentElement.parentElement : n = s.parentElement.parentElement;
      const f = this.isVertical ? n.elementData.renderData : n.elementData, { assignmentRecord: d } = i ? r : f, { eventRecord: m } = f, { vueComponent: b } = this, { teleports: { value: y } } = b.provides, $ = m.isRecurring || m.isOccurrence, v = `assignment-${d == null ? void 0 : d.id}${$ ? "-" + m.id : ""}`;
      n.vueKey && y.delete(n.vueKey);
      const h = { ...t }, { is: N, on: V = {} } = h;
      delete h.is, delete h.on, E(() => {
        y.set(v, {
          bind: h,
          key: v,
          is: N,
          on: V,
          to: s,
          generation: d.generation
        });
      }), n.vueKey = v, o = !0;
    }
    return o;
  }
  /**
   * Cell renderer method
   * @param {Object} context
   * @param {RenderData} context.rendererData
   * @param {*} context.rendererHtml
   * @returns {Boolean}
   */
  static processCellContent({ rendererData: t, rendererHtml: e }) {
    var r;
    const { record: s, column: i, cellElement: n, row: o } = t;
    if (l.isVueConfig(i.data) && ((r = i.data) != null && r.renderer)) {
      const { vueComponent: a } = this, { teleports: { value: u } } = a.provides, f = `${i.id}-${s.id}`, d = i.tree ? n.querySelector(".b-tree-cell-value") : n;
      n.vueKey && u.delete(n.vueKey);
      const m = { ...e }, { is: b, on: y = {} } = m;
      delete m.is, delete m.on, E(() => {
        o.id === s.id && u.set(f, {
          bind: m,
          key: f,
          is: b,
          on: y,
          to: d,
          generation: s.generation
        });
      }), n.vueKey = f;
    }
  }
  /**
   *
   * @param {Object} context
   * @param {*} context.cellContent Content to be rendered in cell (set by renderer)
   * @param {*} context.column Column being rendered
   * @returns {Boolean} `true` if there is a Vue Renderer in this cell, `false` otherwise
   */
  static hasFrameworkRenderer({ cellContent: t, column: e }) {
    return t && typeof t == "object" && l.isVueConfig(e == null ? void 0 : e.data);
  }
}
window.bryntum = window.bryntum || {};
window.bryntum.vue = {
  isVueConfig: l.isVueConfig,
  handleVueContent: l.handleVueContent
};
export {
  l as WrapperHelper
};
//# sourceMappingURL=WrapperHelper.js.map
