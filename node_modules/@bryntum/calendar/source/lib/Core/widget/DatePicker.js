import CalendarPanel from './CalendarPanel.js';
import MonthPicker from './MonthPicker.js';
import YearPicker from './YearPicker.js';
import DateHelper from '../helper/DateHelper.js';
import EventHelper from '../helper/EventHelper.js';
import ObjectHelper from '../helper/ObjectHelper.js';
import BrowserHelper from '../helper/BrowserHelper.js';
import DomHelper from '../helper/DomHelper.js';
import './DisplayField.js';

const
    dateSort           = (lhs, rhs) => lhs.valueOf() - rhs.valueOf(),
    { DateSet }        = DateHelper,
    emptyArray         = Object.freeze([]),
    consecutiveDates   = selection => selection.every((date, i) => !i || !(DateHelper.add(selection[i - 1], 1, 'd') - date));

/**
 * @module Core/widget/DatePicker
 */

/**
 * A Panel which can display a month of date cells, which navigates between the cells, fires events upon user selection
 * actions, optionally navigates to other months in response to UI gestures, and optionally displays information about
 * each date cell.
 *
 * A date is selected (meaning a single value is selected if {@link #config-multiSelect} is not set, or
 * added to the {@link #property-selection} if {@link #config-multiSelect if set}) by clicking a cell
 * or by pressing `ENTER` when focused on a cell.
 *
 * The `SHIFT` and `CTRL` keys modify selection behaviour depending on the value of {@link #config-multiSelect}.
 *
 * This class is used as a {@link Core.widget.DateField#config-picker} by the {@link Core.widget.DateField} class.
 *
 * {@inlineexample Core/widget/DatePicker.js}
 *
 * ## Custom cell rendering
 * You can easily control the content of each date cell using the {@link #config-cellRenderer}. The example below shows
 * a view typically seen when booking hotel rooms or apartments.
 *
 * {@inlineexample Core/widget/DatePickerCellRenderer.js}
 *
 * ## Multi selection
 * You can select multiple date ranges or a single date range using the {@link #config-multiSelect} config.
 *
 * {@inlineexample Core/widget/DatePickerMulti.js}
 *
 * ## Configuring toolbar buttons
 *
 * The datepicker includes a few useful navigation buttons by default. Through the DatePicker´s {@link #config-tbar toolbar},
 * you can manipulate these, via the toolbar´s {@link Core/widget/Toolbar#config-items} config.
 *
 * There are four buttons by default, each of which can be reconfigured using
 * an object, or disabled by configuring them as `null`.
 *
 * ```javascript
 * new DatePicker({
 *    tbar : {
 *       // Remove all navigation buttons
 *       items : {
 *           prevYear  : null,
 *           prevMonth : null,
 *           nextYear  : null,
 *           nextMonth : null
 *       }
 *    }
 * })
 * ```
 *
 * Provided toolbar widgets include:
 *
 * - `prevMonth` Navigates to previous month
 * - `nextMonth` Navigates to next month
 * - `prevYear` Navigates to previous year
 * - `nextYear` Navigates to next year
 *
 * @extends Core/widget/CalendarPanel
 * @classtype datepicker
 * @widget
 */
export default class DatePicker extends CalendarPanel {

    static $name = 'DatePicker';

    static type = 'datepicker';

    static get delayable() {
        return {
            refresh : 'raf'
        };
    }

    static get configurable() {
        return {
            /**
             * The date that the user has navigated to using the UI *prior* to setting the widget's
             * value by selecting. The initial default is today's date. Can also be supplied as a `YYYY-MM-DD` date
             * string.
             *
             * This may be changed using keyboard navigation. The {@link Core.widget.CalendarPanel#property-date} is set
             * by pressing `ENTER` when the desired date is reached.
             *
             * Programmatically setting the {@link Core.widget.CalendarPanel#config-date}, or using the UI to select the
             * date by clicking it also sets the `activeDate`
             * @config {Date|'today'|String}
             */
            activeDate : {
                $config : 'date',
                value   : 'today'
            },

            focusable   : true,
            textContent : false,
            tbar        : {
                overflow : null,
                items    : {
                    prevYear : {
                        cls      : 'b-icon b-icon-first b-datepicker-nav-button',
                        onAction : 'up.gotoPrevYear',
                        tooltip  : 'L{DatePicker.gotoPrevYear}',
                        weight   : 100
                    },
                    prevMonth : {
                        cls      : 'b-icon b-icon-previous b-datepicker-nav-button',
                        onAction : 'up.gotoPrevMonth',
                        tooltip  : 'L{DatePicker.gotoPrevMonth}',
                        weight   : 200
                    },
                    fields : {
                        type  : 'container',
                        cls   : 'b-datepicker-title',
                        items : {
                            monthButton : {
                                type              : 'button',
                                cls               : 'b-datepicker-monthbutton',
                                internalListeners : {
                                    click : 'up.onMonthPickerRequested'
                                }
                            },
                            yearButton : {
                                type              : 'button',
                                cls               : 'b-datepicker-yearbutton',
                                internalListeners : {
                                    click : 'up.onYearPickerRequested'
                                }
                            }
                        },
                        weight : 300
                    },
                    nextMonth : {
                        cls      : 'b-icon b-icon-next b-datepicker-nav-button',
                        onAction : 'up.gotoNextMonth',
                        tooltip  : 'L{DatePicker.gotoNextMonth}',
                        weight   : 400
                    },
                    nextYear : {
                        cls      : 'b-icon b-icon-last b-datepicker-nav-button',
                        onAction : 'up.gotoNextYear',
                        tooltip  : 'L{DatePicker.gotoNextYear}',
                        weight   : 500
                    }
                }
            },

            monthPicker : {
                value : {
                    type              : 'MonthPicker',
                    trapFocus         : true,
                    positioned        : true,
                    hidden            : true,
                    internalListeners : {
                        titleClick : 'up.onMonthPickerTitleClick',
                        select     : 'up.onMonthPicked',
                        Escape     : 'up.onMonthPickerTitleClick'
                    }
                },
                $config : 'lazy'
            },

            yearPicker : {
                value : {
                    type              : 'YearPicker',
                    yearButtonCount   : 16,
                    trapFocus         : true,
                    positioned        : true,
                    hidden            : true,
                    internalListeners : {
                        titleClick : 'up.onYearPickerTitleClick',
                        select     : 'up.onYearPicked'
                    }
                },
                $config : 'lazy'
            },

            /**
             * The initially selected date (or a `YYYY-MM-DD` date string).
             * @config {Date|String}
             */
            date : null,

            /**
             * The minimum selectable date. Selection of and navigation to dates prior
             * to this date will not be possible.
             * @config {Date}
             */
            minDate : {
                $config : 'date',
                value   : null
            },

            /**
             * The maximum selectable date. Selection of and navigation to dates after
             * this date will not be possible.
             * @config {Date}
             */
            maxDate : {
                $config : 'date',
                value   : null
            },

            /**
             * By default, disabled dates cannot be navigated to, and they are skipped over
             * during keyboard navigation. Configure this as `true` to enable navigation to
             * disabled dates.
             * @config {Boolean}
             * @default
             */
            focusDisabledDates : null,

            /**
             * Configure as `true` to enable selecting multiple discontiguous date ranges using
             * click and Shift+click to create ranges and Ctrl+click to select/deselect individual dates.
             *
             * Configure as `'simple'` to enable selecting a single date range by clicking a
             * start date followed by the end date. If you configure multiSelect `range` on touch-devices, `simple`
             * will be the mode used.
             *
             * Configure as `'range'` to enable selecting a single date range by selecting a
             * start and end date. Hold "SHIFT" button to select date range. Ctrl+click may add
             * or remove dates to/from either end of the range.
             * @config {Boolean|'range'|'simple'}
             * @default false
             */
            multiSelect : null,

            /**
             * If {@link #config-multiSelect} is configured as `true`, this is an array of dates
             * which are selected. There may be multiple, discontiguous date ranges.
             *
             * If {@link #config-multiSelect} is configured as `'range'`, this is a two element array
             * specifying the first and last selected dates in a range.
             *
             * You can also provide the selected dates as an array of `YYYY-MM-DD` date strings
             * @config {Date[]|String[]}
             */
            selection : {
                $config : {
                    equal : (v1, v2) => v1 && v1.equals(v2)
                },
                value : null
            },

            /**
             * By default, the month and year are editable. Configure this as `false` to prevent that.
             * @config {Boolean}
             * @default true
             */
            editMonth : {
                $config : 'lazy',
                value   : null
            },

            /**
             * By default, the year is visible. Configure this as `false` to prevent that.
             * @config {Boolean}
             * @default true
             */
            includeYear : {
                $config : 'lazy',
                value   : null
            },

            /**
             * The {@link Core.helper.DateHelper} format string to format the day names.
             * @config {String}
             * @default
             */
            dayNameFormat : 'dd',

            trapFocus : true,

            ariaElement : 'weeksElement',

            focusDescendant : true,

            /**
             * By default, when the {@link #property-date} changes, the UI will only refresh
             * if it doesn't contain a cell for that date, so as to keep a stable UI when
             * navigating.
             *
             * Configure this as `true` to refresh the UI whenever the month changes, even if
             * the UI already shows that date.
             * @config {Boolean}
             * @internal
             */
            alwaysRefreshOnMonthChange : null,

            /**
             * Configure as `true` to add a highlighted border and background to the week row which
             * encapsulates the selected date.
             * @prp {Boolean}
             * @default false
             */
            highlightSelectedWeek : null
        };
    }

    static get prototypeProperties() {
        return {
            /**
             * The class name to add to the calendar cell whose date which is outside the
             * {@link #config-minDate}/{@link #config-maxDate} range.
             * @config {String}
             * @private
             */
            outOfRangeCls : 'b-out-of-range',

            /**
             * The class name to add to the currently focused calendar cell.
             * @config {String}
             * @private
             */
            activeCls : 'b-active-date',

            /**
             * The class name to add to selected calendar cells.
             * @config {String}
             * @private
             */
            selectedCls : 'b-selected-date'
        };
    }

    static _monthNames = DateHelper.getMonthNames();

    // region Init

    construct(config) {
        const me = this;

        super.construct(config);

        const { widgetMap } = me;

        me.externalCellRenderer = me.cellRenderer;
        me.cellRenderer         = me.internalCellRenderer;

        me.element.removeAttribute('tabindex');
        me.ariaElement.setAttribute('aria-activedescendant', `${me.id}-active-day`);
        widgetMap.fields && !me.ariaLabel && me.element.setAttribute('aria-labelledby', widgetMap.fields.id);

        EventHelper.on({
            element : me.weeksElement,
            click   : {
                handler  : 'onCellClick',
                delegate : `.${me.dayCellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`
            },
            mousedown : {
                handler  : 'onCellMousedown',
                delegate : `.${me.dayCellCls}`
            },
            thisObj : me
        });

        me.getConfig('editMonth');
        me.getConfig('includeYear');

        // Ensure the DatePicker is immediately ready for use.
        me.refresh.flush();
    }

    get labelledElement() {
        return this.element;
    }

    afterHide() {
        this._monthPicker?.hide();
        this._yearPicker?.hide();
        super.afterHide(...arguments);
    }

    doDestroy() {
        this.yearButton?.destroy();
        this.monthButton?.destroy();
        super.doDestroy();
    }

    // endregion

    get activeDayCell() {
        return this.weeksElement.querySelector(`#${this.id}-active-day`);
    }

    get focusElement() {
        return (!this.disabled && this.activeDayCell) || this.element;
    }

    onMonthDateChange(info) {
        const ret = super.onMonthDateChange(info);

        this.ariaElement.setAttribute('aria-label', DateHelper.format(this.date, 'MMMM YYYY'));

        // Allowing the Month to be out-of-sync with our state can create race conditions if the Month were to change
        // again before the refresh (as in MultiDatePicker during animated scroll):
        this.refresh.flush();

        return ret;
    }

    updateEditMonth(editMonth) {
        const
            { monthButton, yearButton } = this.widgetMap,
            disallow = editMonth === false;

        monthButton && (monthButton.readOnly = disallow);
        yearButton && (yearButton.disabled = disallow);
    }

    updateIncludeYear(includeYear) {
        const { yearButton } = this.widgetMap;

        yearButton && (yearButton.hidden = includeYear === false);
    }

    updateReadOnly(readOnly) {
        if (readOnly) {
            this.element.setAttribute('inert', true);
        }
        else {
            this.element.removeAttribute('inert');
        }
    }

    doRefresh(...args) {
        const
            me             = this,
            {
                date,
                widgetMap
            }              = me,
            oldActiveCell  = me.activeDayCell,
            // Coerce the active date to be in the visible range.
            // Do not use the setter, the sync is done below
            activeDate     = DateHelper.betweenLesser(me.activeDate, me.month.startDate, me.month.endDate) ? me.activeDate : (me._activeDate = date);

        // toolbar widgets must have been instantiated.
        me.getConfig('tbar');

        super.doRefresh(...args);

        widgetMap.monthButton && (widgetMap.monthButton.text = me.constructor._monthNames[date.getMonth()]);
        widgetMap.yearButton && (widgetMap.yearButton.text  = date.getFullYear());

        // The focused cell will have been repurposed for a new date
        const dateOfOldActiveCell = DateHelper.parseKey(oldActiveCell?.dataset.date);

        // The position of the cell may have changed, so the "from" cell must
        // be identified by the date that is stamped into it *after* the refresh..
        if (activeDate - dateOfOldActiveCell) {
            me.syncActiveDate(activeDate, dateOfOldActiveCell);
        }
    }

    internalCellRenderer({ cell, date }) {
        const
            me            = this,
            {
                externalCellRenderer
            }             = me,
            isSelected    = me.isSelectedDate(date),
            cellClassList = me.getCellClassList(...arguments);

        if (isSelected) {
            // Fix up start/inner/end range classes
            if (me.multiSelect) {
                const
                    isStart = !me.isSelectedDate(DateHelper.add(date, -1, 'd')),
                    isEnd   = !me.isSelectedDate(DateHelper.add(date, 1, 'd'));

                cellClassList['b-range-start'] = isStart;
                cellClassList['b-range-end'] = isEnd;
                cellClassList['b-in-range'] = !isStart && !isEnd;
            }
        }

        DomHelper.updateClassList(cell, cellClassList);

        // Must replace entire content in case we have an externalCellRenderer
        cell.innerHTML = `<div class="b-datepicker-cell-inner">${date.getDate()}</div>`;
        cell.setAttribute('role', 'gridcell');
        // Add an aria label that's easy to understand when spoken
        cell.setAttribute('aria-label', DateHelper.format(date, 'dddd MMMM Do, YYYY'));
        // Locker Service does not support toggleAttribute
        DomHelper.toggleAttribute(cell, 'aria-selected', isSelected);

        if (me.isActiveDate(date)) {
            cell.id = `${me.id}-active-day`;
        }
        else {
            cell.removeAttribute('id');
        }

        if (externalCellRenderer) {
            arguments[0].cell = cell.firstChild;
            me.callback(externalCellRenderer, this, arguments);
        }
    }

    getCellClassList({ date }) {
        const
            me = this,
            {
                activeCls,
                selectedCls
            }  = me;

        return {
            [activeCls]        : activeCls && me.isActiveDate(date),
            [selectedCls]      : me.isSelectedDate(date),
            [me.outOfRangeCls] : (me.minDate && date < me.minDate) || (me.maxDate && date > me.maxDate)
        };
    }

    onCellMousedown(event) {
        const cell = event.target.closest('[data-date]');

        if (this.focusable) {
            cell.focus();

            if (DomHelper.getActiveElement(cell) === cell) {
                // Only preventDefault if we succeeded in ingesting focus.
                event.preventDefault();
            }
        }
        else {
            // Swallow focus change in this case (e.g., multidatepicker / daterangepicker)
            event.preventDefault();
        }

        this.activeDate = DateHelper.parseKey(cell.dataset.date);
    }

    onCellClick(event) {
        const cell = event.target.closest('[data-date]');
        this.onUIDateSelect(DateHelper.parseKey(cell.dataset.date), event);
    }

    /**
     * Called when the user uses the UI to select the current activeDate. So ENTER when focused
     * or clicking a date cell.
     * @param {Date} date The active date to select
     * @param {Event} event the instigating event, either a `click` event or a `keydown` event.
     * @internal
     */
    onUIDateSelect(date, event) {
        const
            me = this,
            {
                lastClickedDate,
                multiSelect
            }  = me;

        if (!me.isDisabledDate(date)) {
            if (me.trigger('beforeDateSelect', { date, event }) !== false) {
                me.lastClickedDate = date;
                me.activatingEvent = event;

                // Handle multi selecting.
                // * single contiguous date range, eg: an event start and end
                // * multiple discontiguous ranges
                if (multiSelect) {
                    me.handleMultiSelect(lastClickedDate, date, event);
                }
                else {
                    // First set the selection. That *may* set the date.
                    // If it doesn't, we set it here. If done, this is a no-op
                    me.date = me.selection = date;
                    if (me.floating) {
                        me.hide();
                    }
                }

                me.activatingEvent = null;
            }
        }
    }

    // Calls updateSelection if the selection is mutated
    handleMultiSelect(lastClickedDate, date, event) {
        const
            me          = this,
            {
                multiSelect
            }           = me,
            _selection  = me._selection || (me._selection = new DateSet()),
            selection   = _selection.dates,
            singleRange = multiSelect === 'range' || multiSelect === 'simple',
            isSimpleMultiSelect = multiSelect === 'simple' || DomHelper.isTouchEvent,
            {
                size,
                generation
            }           = _selection,
            rangeEnds   = size && {
                [DateHelper.makeKey(DateHelper.add(selection[0], -1, 'd'))]                   : 1,
                [DateHelper.makeKey(selection[0])]                                            : 1,
                [DateHelper.makeKey(selection[selection.length - 1])]                         : 1,
                [DateHelper.makeKey(DateHelper.add(selection[selection.length - 1], 1, 'd'))] : 1
            },
            isSelected  = _selection.has(date),
            toggleFn    = isSelected ? 'delete' : 'add';

        // If we're allowed to create one range and they clicked on a togglable date of a range
        const clickedRangeEnd = singleRange && rangeEnds?.[DateHelper.makeKey(date)];

        // In simple mode, if we select a new date with a range present - clear previous range then select single date
        if (isSimpleMultiSelect && size > 1) {
            _selection.clear();
            _selection.add(date);
        }
        else {
            // Ctrl+click means toggle the date, leaving remaining selection unchanged
            if (event.ctrlKey) {
            // Allow individual date toggling if we are allowing multi ranges
            // or there's no current selection, or they are on, or adjacent to the range end
                if (multiSelect === true || !size || clickedRangeEnd) {
                    _selection[toggleFn](date);

                    // Check that the start hasn't been deselected
                    if (singleRange && !_selection.has(me.rangeStartDate)) {
                        me.rangeStartDate.setDate(me.rangeStartDate.getDate() + (date < selection[1] ? 1 : -1));
                    }
                }
            }
            // Shift+click means add a range, or tapping using touch
            else if ((isSimpleMultiSelect || event.shiftKey) && size) {
                const [start, end] = [
                    new Date(singleRange ? (me.rangeStartDate || (me.rangeStartDate = selection[0])) : lastClickedDate),
                    date
                ].sort(dateSort);

                // If we can only have one range
                if (singleRange) {
                    _selection.clear();
                }

                // Add all dates in the range
                for (const d = start; d <= end; d.setDate(d.getDate() + 1)) {
                    _selection.add(d);
                }
            }
            // Make the clicked date the only selected date.
            // Avoid a no-op which would still cause a generation change
            else if (!(_selection.has(date) && _selection.size === 1)) {
                _selection.clear();
                _selection.add(date);
            }
        }

        const newSize = _selection.size;

        // Keep track of the range start date. The first selected date is the start and the end then
        // can move to either side of that.
        if (newSize === 1) {
            me.rangeStartDate = date;
        }
        else if (!newSize) {
            me.rangeStartDate = null;
        }

        // Process selection change if we changed the selection.
        if (_selection.generation !== generation) {
            me.updateSelection(_selection);
        }
    }

    updateHighlightSelectedWeek(highlightSelectedWeek) {
        this.element.classList.toggle('b-highlight-selected-week', Boolean(highlightSelectedWeek));
    }

    updateMultiSelect(multiSelect) {
        this.element.classList.toggle('b-multiselect', Boolean(multiSelect));
        if (!multiSelect) {
            this.selection = [...this.selection][0];
        }
    }

    /**
     * The selected Date(s).
     *
     * When {@link #config-multiSelect} is `'range'`, then this yields a two element array
     * representing the start and end of the selected range.
     *
     * When {@link #config-multiSelect} is `true`, this yields an array containing every selected
     * Date.
     * @member {Date[]} selection
     */
    get selection() {
        const
            { _selection } = this,
            dates          = _selection ? _selection.dates : emptyArray;

        return this.multiSelect === 'range' && dates.length ? [dates[0], dates[dates.length - 1]] : dates;
    }

    getRange(snapToWeeks) {
        if (this.multiSelect) {
            const
                { selection } = this,
                startDate     = selection[0],
                endDate       = selection[selection.length - 1];

            // If the dates span a range of months, eg 15th April to 14th May, then the increment
            // unit is one month. The wholeMonth flag is set if *all* dates are selected.
            if (selection.length > 1 && DateHelper.add(endDate, 1, 'd').getDate() === startDate.getDate()) {
                return {
                    unit      : 'month',
                    magnitude : DateHelper.diff(startDate, DateHelper.add(endDate, 1, 'd'), 'month'),
                    wholeMonth :
                        startDate.getDate() === 1 &&
                        endDate.getDate() === DateHelper.getLastDateOfMonth(endDate).getDate() &&
                        consecutiveDates(selection),
                    startDate,
                    endDate
                };
            }

            // The dates span precisely a range of weeks.
            if (startDate.getDay() == DateHelper.weekStartDay && endDate.getDay() === (DateHelper.weekStartDay + 6) % 7) {
                return {
                    unit      : 'week',
                    magnitude : DateHelper.diff(startDate, DateHelper.add(endDate, 1, 'd'), 'week'),
                    startDate,
                    endDate
                };
            }

            // Expand the range to be a range of week rows which encapsulates all selected dates
            if (snapToWeeks) {
                const
                    weekSpan  = Math.max(Math.ceil(DateHelper.diff(startDate, DateHelper.add(endDate, 1, 'd'), 'w')), 1),
                    dayOfWeek = (startDate.getDay() - DateHelper.weekStartDay + 7) % 7,

                    // Convert range to cover the encapsulated weeks
                    snappedStartDate = DateHelper.add(startDate, -dayOfWeek, 'd'),
                    snappedEndDate   = DateHelper.add(snappedStartDate, weekSpan * 7 - 1, 'd');

                // Create a larger range, measured in weeks which encompasses all the selected dates
                return {
                    unit      : 'week',
                    magnitude : weekSpan,
                    startDate : snappedStartDate,
                    endDate   : snappedEndDate
                };
            }

            // The default is that we span a range of days
            return {
                unit      : 'day',
                magnitude : DateHelper.diff(startDate, endDate, 'd') + 1,
                startDate,
                endDate
            };
        }
    }

    get snappedRange() {

    }

    changeSelection(selection, was) {
        // We always need a _selection property to be a DateSet.
        // Falsy selection value means empty DateSet.
        const me = this;

        let result, rangeStartDate;

        if (!selection) {
            result = new DateSet();
        }
        else if (selection.isDateSet) {
            if (was === selection || was?.equals(selection)) {
                return was;
            }

            rangeStartDate = ObjectHelper.first(selection);
            result = selection;
        }
        else {
            // Convert single Date into Array
            if (!selection.forEach) {
                selection = [selection];
            }

            // Clamp selection into range. May duplicate, but the Set will dedupe.
            selection.forEach((d, i) => selection[i] = me.changeDate(d));

            // Cache the first date, regardless of sort order for use as the "clicked date"
            // around which the range revolves when shift+click is used.
            rangeStartDate = selection[0];
            selection.sort(dateSort);

            // A two element array means a start and end
            if (me.multiSelect === 'range' && selection.length === 2) {
                result = new DateSet();
                for (const d = new Date(selection[0]); d <= selection[1]; d.setDate(d.getDate() + 1)) {
                    result.add(d);
                }
            }
            else {
                // Multi dates may be in any order, so use the temporally first date as range start
                rangeStartDate = selection[0];
                result = new DateSet(selection);
            }
        }

        if (rangeStartDate) {
            me.rangeStartDate = DateHelper.clearTime(rangeStartDate);
        }

        return result;
    }

    updateSelection(dateSet, oldDateSet) {
        const
            me              = this,
            { multiSelect } = me,
            { dates }       = dateSet,
            selection       = multiSelect === 'range' ? [dates[0], dates[dates.length - 1]] : dates;

        if (!me.isConfiguring) {
            // If we are *single* selecting and there is no `date` incoming, the current `date`
            // must be set *first* to ensure that any refresh and selectionChange event handlers
            // see the new value. By doing it here, *before* onUIDateSelect sets it, event handlers
            // will also see the new `selection` value.
            if (!multiSelect && dates.length && !me.peekConfig('date') && dates[0].getMonth() === me.month.month) {
                me.date = dates[0];
            }

            // We're going to announce the change. UI must be up to date
            me.refresh.now();

            const event = {
                selection,
                userAction : Boolean(me.activatingEvent)
            };
            if (oldDateSet) {
                const { dates } = oldDateSet;

                event.oldSelection =  multiSelect === 'range' ? [dates[0], dates[dates.length - 1]] : dates;
            }

            /**
             * Fires when a date or date range is selected. If {@link #config-multiSelect} is specified,
             * this will fire upon deselection and selection of dates.
             * @event selectionChange
             * @param {Date[]} selection The selected dates. If {@link #config-multiSelect} is specified
             * this may be a two element array specifying start and end dates.
             * @param {Date[]} oldSelection The previously selected dates. If {@link #config-multiSelect} is specified
             * this may be a two element array specifying start and end dates.
             * @param {Boolean} userAction This will be `true` if the change was caused by user interaction
             * as opposed to programmatic setting.
             */
            me.trigger('selectionChange', event);
        }
    }

    /**
     * Checks whether a date is selected.
     * @param {Date} date The date
     * @returns {Boolean}
     */
    isSelected(date) {
        return this.selection.some(d => DateHelper.isSameDate(d, date));
    }

    onInternalKeyDown(keyEvent) {
        const
            me         = this,
            keyName    = keyEvent.key.trim() || keyEvent.code,
            activeDate = me.activeDate;

        let newDate    = new Date(activeDate);

        if (keyName === 'Escape') {
            if (me.monthPicker.isVisible) {
                return me.monthPicker.hide();
            }
            if (me.yearPicker.isVisible) {
                return me.yearPicker.hide();
            }

            if (me.floating) {
                return me.hide();
            }
        }

        // Only navigate if not focused on one of our child widgets.
        // We have a prevMonth and nextMonth tool and possibly month and year pickers.
        if (activeDate && me.weeksElement.contains(keyEvent.target)) {
            do {
                switch (keyName) {
                    case 'ArrowLeft':
                        // Disable browser use of this key.
                        // Ctrl+ArrowLeft navigates back.
                        // ArrowLeft scrolls if there is horizontal scroll.
                        keyEvent.preventDefault();

                        if (keyEvent.ctrlKey) {
                            newDate = me.gotoPrevMonth();
                        }
                        else {
                            newDate.setDate(newDate.getDate() - 1);
                        }
                        break;
                    case 'ArrowUp':
                        // Disable browser use of this key.
                        // ArrowUp scrolls if there is vertical scroll.
                        keyEvent.preventDefault();

                        newDate.setDate(newDate.getDate() - 7);
                        break;
                    case 'ArrowRight':
                        // Disable browser use of this key.
                        // Ctrl+ArrowRight navigates forwards.
                        // ArrowRight scrolls if there is horizontal scroll.
                        keyEvent.preventDefault();

                        if (keyEvent.ctrlKey) {
                            newDate = me.gotoNextMonth();
                        }
                        else {
                            newDate.setDate(newDate.getDate() + 1);
                        }
                        break;
                    case 'ArrowDown':
                        // Disable browser use of this key.
                        // ArrowDown scrolls if there is vertical scroll.
                        keyEvent.preventDefault();

                        newDate.setDate(newDate.getDate() + 7);
                        break;
                    case 'Enter':
                        return me.onUIDateSelect(activeDate, keyEvent);
                }
            } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);

            // Don't allow navigation to outside of date bounds.
            if (me.minDate && newDate < me.minDate) {
                return;
            }
            if (me.maxDate && newDate > me.maxDate) {
                return;
            }
            me.activeDate = newDate;
        }
    }

    changeMinDate(minDate) {
        // Avoid changeDate which clamps incoming value into current allowable range
        return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
    }

    updateMinDate(minDate) {
        this._yearPicker && (this._yearPicker.minYear = minDate?.getFullYear());
        this.refresh();
    }

    changeMaxDate(minDate) {
        // Avoid changeDate which clamps incoming value into current allowable range
        return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
    }

    updateMaxDate(maxDate) {
        this._yearPicker && (this._yearPicker.maxYear = maxDate?.getFullYear());
        this.refresh();
    }

    changeDate(date) {
        return DateHelper.clamp(super.changeDate(date), this.minDate, this.maxDate);
    }

    updateDate(date, oldDate) {
        const
            me        = this,
            { month } = me;

        // Directly configuring a date creates the selection
        if (me.isConfiguring && !me.initializingActiveDate) {
            if (!('selection' in me.initialConfig)) {
                me.selection = date;
            }

            if (!('activeDate' in me.initialConfig)) {
                me.activeDate = date;
            }
        }

        // Only change the month's date if it is within our current month
        // or we have to because we don't have a cell for it.
        // If it's a date in the "otherMonth" part of the grid, do not update.
        if (!month.date || date.getMonth() === month.month || !me.getCell(date) || me.alwaysRefreshOnMonthChange || me.isNavigating) {
            super.updateDate(date);
        }
        else {
            const
                newMonth = month.getOtherMonth(date),
                // Collect changes as bitwise flags:
                // 0001 = date has changed.
                // 0010 = week has changed.
                // 0100 = month has changed.
                // 1000 = year has changed.
                // We need this because 10/1/2010 -> 10/1/2011 must fire a dateChange
                // and a monthChange in addition to the yearChange.
                // And 10/1/2010 -> 10/2/2010 must fire a dateChange in addition to the monthChange.
                changes  = me.eventListeners && (oldDate ? (
                    date.getDate()            !== oldDate.getDate())             |
                    (newMonth.getWeekId(date) !== month.getWeekId(oldDate)) << 1 |
                    (date.getMonth()          !== oldDate?.getMonth())      << 2 |
                    (date.getFullYear()       !== oldDate?.getFullYear())   << 3 : 15);

            me.trigger('dateChange', {
                changes : {
                    d : true,
                    w : Boolean(changes & 2),
                    m : Boolean(changes & 12),
                    y : Boolean(changes & 8),
                    r : newMonth.weekCount !== month.weekCount
                },
                value    : date,
                oldValue : oldDate
            });
        }
    }

    changeActiveDate(activeDate, oldActiveDate) {
        const me = this;

        if (activeDate === 'today') {
            activeDate = new Date();
        }

        if (me.trigger('beforeActiveDateChange', { activeDate, oldActiveDate }) === false) {
            return;
        }

        activeDate = activeDate ? me.changeDate(activeDate) : me.date || (me.date = DateHelper.clearTime(new Date()));

        if (isNaN(activeDate)) {
            throw new Error('DatePicker activeDate must be passed a Date, or a YYYY-MM-DD date string');
        }

        return DateHelper.clamp(activeDate, me.minDate, me.maxDate);
    }

    updateActiveDate(activeDate, wasActiveDate) {
        const
            me                = this,
            { isConfiguring } = me;

        if (isConfiguring || !me.getCell(activeDate)) {
            me.initializingActiveDate = isConfiguring;
            me.date = activeDate;
            me.initializingActiveDate = false;
        }

        if (!isConfiguring && !me.refresh.isPending) {
            me.syncActiveDate(activeDate, wasActiveDate);
        }
    }

    syncActiveDate(activeDate, wasActiveDate) {
        const
            me            = this,
            { activeCls } = me,
            activeCell    = me.getCell(activeDate),
            wasActiveCell = wasActiveDate && me.getCell(wasActiveDate),
            activeElement = DomHelper.getActiveElement(me.element);

        if (activeCell) {
            me.focusable && activeCell.setAttribute('tabIndex', '0');
            activeCls && activeCell.classList.add(activeCls);
            activeCell.id = `${me.id}-active-day`;

            if (me.weeksElement.contains(activeElement) /*|| me.owner?.element.contains(activeElement)*/) {
                activeCell.focus();
            }
        }

        if (wasActiveCell && wasActiveCell !== activeCell) {
            me.focusable && wasActiveCell.removeAttribute('tabIndex');
            activeCls && wasActiveCell.classList.remove(activeCls);
            wasActiveCell.removeAttribute('id');
        }
    }

    set value(value) {
        const
            me = this,
            {
                selection,
                duration
            }  = me;

        // Setting the value must navigate to the encapsulating month even if we have
        // a cell for the date.
        // updateDate always calls super and CalendarPanel will refresh
        me.isNavigating = true;

        if (value) {
            value = me.changeDate(value, me.value);

            // If we're maintaining a single date range, move the range
            if (me.multiSelect === 'range' && selection?.length === 2) {
                if (!DateHelper.betweenLesserEqual(value, ...selection)) {
                    // Move range back to encapsulate date
                    if (value < selection[0]) {
                        me.selection = [value, DateHelper.add(value, duration - 1, 'd')];
                    }
                    // Move range forwards to encapsulate date
                    else {
                        me.selection = [DateHelper.add(value, -(duration - 1), 'd'), value];
                    }
                }
                me.date = me.activeDate = value;
                return;
            }

            // Undefined return value means no change
            if (value !== undefined) {
                me.selection = value;
                me.date = me.activeDate = value;
            }
        }
        else {
            // Clearing the value - go to today's calendar
            me.date = me.activeDate = new Date();
            me.selection = null;
        }
        me.isNavigating = false;
    }

    get value() {
        const
            { selection } = this,
            n = selection?.length || null;

        return n && selection[n - 1];
    }

    get duration() {
        return this.multiSelect === 'range' ? DateHelper.diff(...this.selection, 'd') + 1 : 1;
    }

    gotoPrevYear() {
        return this.goto(-1, 'year');
    }

    gotoPrevMonth() {
        return this.goto(-1, 'month');
    }

    gotoNextMonth() {
        return this.goto(1, 'month');
    }

    gotoNextYear() {
        return this.goto(1, 'year');
    }

    goto(direction, unit) {
        const
            me = this,
            { activeDate } = me,
            activeCell = activeDate && me.getCell(activeDate);

        let newDate;

        // If active date is already in the month we're going to, use it
        if (unit === 'month' && activeCell && activeDate?.getMonth() === me.month.month + direction) {
            newDate = activeDate;
        }
        // Move the date by the requested unit
        else {
            newDate = DateHelper.add(activeCell ? activeDate : me.date, direction, unit);
        }

        return me.gotoDate(newDate, direction, activeCell);
    }

    gotoDate(newDate, direction, activeCell = this.activeDate && this.getCell(this.activeDate)) {
        const
            me = this,
            firstDateOfNewMonth = new Date(newDate);

        firstDateOfNewMonth.setDate(1);

        const lastDateOfNewMonth  = DateHelper.add(DateHelper.add(firstDateOfNewMonth, 1, 'month'), -1, 'day');

        // Don't navigate if month is outside bounds
        if ((me.minDate && direction < 0 && lastDateOfNewMonth < me.minDate) || (me.maxDate && direction > 0 && firstDateOfNewMonth > me.maxDate)) {
            return;
        }

        // We need to force a UI change even if the UI contains the target date.
        // updateDate always calls super and CalendarPanel will refresh
        me.isNavigating = true;

        const result = me.date = newDate;
        me.widgetMap.monthButton.text = me.constructor._monthNames[newDate.getMonth()];

        if (activeCell) {
            me.activeDate = newDate;
        }
        me.isNavigating = false;
        return result;
    }

    isActiveDate(date) {
        return !(date - this.activeDate);
    }

    isSelectedDate(date) {
        return this._selection?.has(date);
    }

    onFocusIn(ev) {
        super.onFocusIn(ev);

        if (ev.toWidget === this && ev._target === this.element && !this.disabled) {
            this.focusElement?.focus();
        }
    }

    onMonthPickerRequested() {
        const { monthPicker } = this;

        if (monthPicker.isVisible) {
            monthPicker.hide();
        }
        else {
            monthPicker.month = this.activeDate.getMonth();
            monthPicker.show();
            monthPicker.focus();
        }
    }

    onYearPickerRequested() {
        const { yearPicker } = this;

        if (yearPicker.isVisible) {
            yearPicker.hide();
        }
        else {
            yearPicker.year = yearPicker.startYear = this.activeDate.getFullYear();
            yearPicker.show();
            yearPicker.focus();
        }
    }

    onMonthPickerTitleClick() {
        this.monthPicker.hide();
    }

    onYearPickerTitleClick() {
        this.yearPicker.hide();
    }

    onMonthPicked({ value, source }) {
        const me = this;

        me.gotoDate(DateHelper.add(me.activeDate, value - me.activeDate.getMonth(), 'month'));

        me.widgetMap.monthButton.text = me.constructor._monthNames[me.activeDate.getMonth()];

        // Move focus without scroll *before* focus reversion from the hide.
        // Browser behaviour of scrolling to focused element would break animation.
        me.focusElement?.focus({ preventScroll : true });
        source.hide();
    }

    onYearPicked({ value, source }) {
        const newDate = new Date(this.activeDate);

        newDate.setFullYear(value);
        this.activeDate = newDate;

        // Move focus without scroll *before* focus reversion from the hide.
        // Browser behaviour of scrolling to focused element would break animation.
        this.focusElement?.focus({ preventScroll : true });
        source.hide();
    }

    changeMonthPicker(monthPicker, oldMonthPicker) {
        return MonthPicker.reconfigure(oldMonthPicker, monthPicker ? MonthPicker.mergeConfigs({
            owner    : this,
            appendTo : this.element
        }, monthPicker) : null, this);
    }

    changeYearPicker(yearPicker, oldYearPicker) {
        return YearPicker.reconfigure(oldYearPicker, yearPicker ? YearPicker.mergeConfigs({
            owner    : this,
            appendTo : this.element,
            minYear  : this.minDate?.getFullYear(),
            maxYear  : this.maxDate?.getFullYear()
        }, yearPicker) : null, this);
    }

    get childItems() {
        const
            { _yearPicker, _monthPicker } = this,
            result          = super.childItems;

        if (_yearPicker) {
            result.push(_yearPicker);
        }

        if (_monthPicker) {
            result.push(_monthPicker);
        }

        return result;
    }

    updateLocalization() {
        const
            me = this,
            { monthButton } = me.widgetMap,
            monthNames      = me.constructor._monthNames = DateHelper.getMonthNames();

        if (monthButton && !me.isConfiguring) {
            monthButton.text = monthNames[me.monthPicker.month ?? me.date.getMonth()];
        }

        super.updateLocalization();
    }

    changeMultiSelect(value) {
        if (value === 'range' && BrowserHelper.isTouchDevice) {
            value = 'simple';
        }

        return value;
    }
}

// Register this widget type with its Factory
DatePicker.initClass();
