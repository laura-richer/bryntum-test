import DateHelper from '../../Core/helper/DateHelper.js';
import Responsive from '../../Core/widget/mixin/Responsive.js';
import Panel from '../../Core/widget/Panel.js';
import '../../Calendar/widget/CalendarDatePicker.js';
import '../../Scheduler/widget/ResourceFilter.js';
import '../../Core/widget/FilterField.js';

/**
 * @module Calendar/widget/Sidebar
 */

/**
 * This class is not supposed to be used directly. This widget provides the utility UI as the
 * {@link Calendar.view.Calendar#config-sidebar} of a {@link Calendar.view.Calendar} widget.
 *
 * Sidebar items provided by default:
 *
 * | Widget ref       | Type                                         | Weight | Description                                 |
 * |------------------|----------------------------------------------|--------|---------------------------------------------|
 * | `datePicker`     | {@link Calendar.widget.CalendarDatePicker}   | 100    | Used to pick Calendar's active date         |
 * | `eventFilter`    | {@link Core.widget.FilterField}              | 150    | Used to filter events by name               |
 * | `resourceFilter` | {@link Scheduler.widget.ResourceFilter}      | 200    | Used to select resources to show events for |
 *
 * The configuration of these items may be overridden:
 *
 * ```javascript
 * new Calendar({
 *     sidebar : {
 *         items : {
 *             datePicker : {
 *                 // Never go to dates in the past
 *                 minDate : new Date()
 *             },
 *             eventFilter : {
 *                 // Let's have this at the top
 *                 weight : 50
 *             },
 *             resourceFilter : {
 *                 store : {
 *                     sorters : [{
 *                         field     : 'name',
 *                         // By default this is in ascending name order
 *                         // Let's change that round.
 *                         ascending : false
 *                     }]
 *                 }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * The {@link #config-bbar} is used to hold the navigation buttons ("Today" and next/previous) when the owning
 * `Calendar` is configured with {@link Calendar.view.Calendar#config-navigatorPlacement} set to `'sidebar'`. The
 * location of the `bbar`, as well as other options, can be changed via the `bbar` config, like so:
 *
 * ```javascript
 *  new Calendar({
 *      sidebar : {
 *          bbar : {
 *              dock : 'top'
 *          }
 *      }
 *  });
 * ```
 *
 * {@inlineexample Calendar/widget/Sidebar.js}
 *
 * @extends Core/widget/Panel
 * @mixes Core/widget/mixin/Responsive
 * @classtype sidebar
 * @demo Calendar/sidebar-customization
 */
export default class Sidebar extends Panel.mixin(Responsive) {
    static $name = 'Sidebar';

    // Factoryable type name
    static type = 'sidebar';

    static configurable = {
        focusable            : false,
        ignoreParentReadOnly : true,
        ariaLabel            : 'Sidebar',

        bbar : {
            cls    : 'b-cal-nav-item',
            layout : {
                justify : 'center'
            },
            items : {
                todayButtonSidebar : {
                    text    : 'L{Calendar.Today}',
                    onClick : 'up.shiftToNow',
                    weight  : 200
                },
                prevButtonSidebar : {
                    onClick : 'up.shiftPrevious',
                    cls     : 'b-borderless',
                    icon    : 'b-icon-previous',
                    weight  : 300
                },
                nextButtonSidebar : {
                    onClick : 'up.shiftNext',
                    cls     : 'b-borderless',
                    icon    : 'b-icon-next',
                    weight  : 400
                }
            }
        },

        items : {
            datePicker : {
                type              : 'datepicker',
                ariaLabel         : 'L{Sidebar.selectDate}',
                weight            : 100,
                internalListeners : {
                    selectionChange : 'up.onDatePickerSelectionChange'
                }
            },

            eventFilter : {
                type        : 'filterfield',
                field       : 'name',
                // We want this in second position
                weight      : 150,
                placeholder : 'L{Sidebar.matchEvents}',
                ariaLabel   : 'L{Sidebar.filterEvents}',
                localeClass : this
            },

            resourceFilter : {
                ignoreParentReadOnly : true,
                ariaLabel            : 'L{Sidebar.filterResources}'
            }
        },

        date : {
            $config : {
                equal : 'date'
            },
            value : null
        },

        eventStore : null,
        responsive : {},  // brand us as responsive so "collapsed" is tracked per responsive state

        stepUnitText : null,

        /**
         * May be configured with `'left'` or `'right'` to dock the Sidebar to either side.
         *
         * Defaults to `'left'`.
         * @config {'left'|'right'}
         * @default
         */
        side : 'left',

        collapsible : {
            tool : null
        },

        /**
         * The resource filtering widget which hides and shows events based upon
         * whether they are assigned to the selected resources.
         * @member {Scheduler.widget.ResourceFilter} resourceFilter
         */
        /**
         * A configuration object specifying options to change how the sidebar's resourcefilter is configured.
         * @config {ResourceFilterConfig|null}
         */
        resourceFilter : {
            type       : 'resourcefilter',
            flex       : '1 1 auto',
            weight     : 200,
            minHeight  : 110,
            scrollable : {
                overflowY : 'auto'
            },
            store : {
                sorters : [{
                    field     : 'name',
                    ascending : true
                }]
            },

            // We must only see the resources that are filtered in
            masterFilter(r) {
                return this.eventStore.resourceStore.isAvailable(r);
            }
        },

        /**
         * If the {@link Calendar.view.Calendar#property-datePicker} is set to {@link Core.widget.DatePicker#config-multiSelect}, setting this
         * to `true` shows a background highlight effect on the week rows that your selected range encompasses to help
         * the end user visualze the time ranges being evaluated.
         * @prp {Boolean}
         */
        highlightMultiSelectSpan : {
            $config : 'lazy',
            value   : null
        },

        /**
         * If the {@link Calendar.view.Calendar#property-datePicker} is set to {@link Core.widget.DatePicker#config-multiSelect}, then
         * by default, cooperating views (See {@link Calendar.view.Calendar#config-datePicker}) will have their
         * navigation `shiftIncrement` set to navigate week-by-week when using the `Next` and `Previous` buttons.
         *
         * Configure this as `false` to have the views step forwards or backwards by exactly the length of the
         * selected range.
         * @prp {Boolean}
         */
        snapMultiSelectNavigation : true
    };

    setupWidgetConfig(widgetConfig, type) {
        const me = this;

        let result = super.setupWidgetConfig(...arguments);

        // A string becomes the defaultType (see below) with the html set to the string.
        if (result.ref === 'eventFilter') {
            result.store = me.initialConfig.eventStore;
        }

        // Apply our configuration to the resourceFilter if it has not been configured to be
        // a completely different type of widget
        if (result.ref === 'resourceFilter') {
            if (!result.type || result.type === me.resourceFilter.type) {
                result = Sidebar.mergeConfigs(me.resourceFilter, result);
            }
        }

        // Sidebar has to know these so it can set an optimum minWidth to prevent
        // the DatePicker from being crushed into a bad UX.
        if (result.type === 'datepicker') {
            me.element.classList.add('b-has-datepicker');
            me.element.classList.toggle('b-datepicker-with-events', Boolean(result.events));

            // Monitor rangeChange events from EventLists
            me.up('calendar')?.ion({
                rangeChange : 'onCalendarViewRangeChange',
                thisObj     : me
            });
        }

        return result;
    }

    // Process initial multiselection of DatePicker
    onInternalPaint({ firstPaint }) {
        const { datePicker } = this.widgetMap;

        if (firstPaint) {
            // Ingest lazy config now so that datePicker gets synced with value
            this.getConfig('highlightMultiSelectSpan');

            if (datePicker?.multiSelect) {
                this.owner?.eachView(view => {
                    if (view.isDateRangeOwner && !view.fixedDuration) {
                        // If it's a *discontiguous* range, we will need to filter out
                        // unselected dates between the range start and end.
                        if (datePicker.multiSelect === true) {
                            view.dateFilter = view.resourceDateFilter = ({ date }) => datePicker.isSelected(date);
                        }
                    }
                });
                // Ensure views are initialized with the starting range
                this.onDatePickerSelectionChange({ source : datePicker, selection : datePicker.selection }, true);

            }
        }

        super.onInternalPaint?.(...arguments);
    }

    updateHighlightMultiSelectSpan(highlightMultiSelectSpan) {
        const { datePicker } = this.widgetMap;

        datePicker && datePicker.element.classList.toggle('b-highlight-selection', Boolean(highlightMultiSelectSpan));
    }

    updateSide(side, oldSide) {
        const { classList } = this.element;

        classList.remove(`b-sidebar-${oldSide}`);
        classList.add(`b-sidebar-${side}`);

        if (this.collapsible) {
            this.collapsible.direction = side;
        }
    }

    updateStepUnitText(stepUnitText) {
        const
            me                                       = this,
            { prevButtonSidebar, nextButtonSidebar } = me.widgetMap;

        if (prevButtonSidebar) {
            prevButtonSidebar.tooltip = stepUnitText ? me.L('L{Calendar.previous}', stepUnitText) : '';
            prevButtonSidebar.disabled = !stepUnitText;
        }

        if (nextButtonSidebar) {
            nextButtonSidebar.tooltip = stepUnitText ? me.L('L{Calendar.next}', stepUnitText) : '';
            nextButtonSidebar.disabled = !stepUnitText;
        }
    }

    updateEventStore(eventStore) {
        const { resourceFilter, datePicker, eventFilter } = this.widgetMap;

        if (eventFilter) {
            eventFilter.store = eventStore;
        }
        if (resourceFilter) {
            resourceFilter.eventStore = eventStore;
        }
        if (datePicker) {
            datePicker.eventStore = eventStore;
        }
    }

    // Called when a DateRangeOwner mode changes its range. The event is relayed by the Calendar.
    // If the mode is an EventList in startDate->endDate mode, the date picker should match it
    onCalendarViewRangeChange({ source, new: { startDate, endDate } }) {
        const { datePicker } = this.widgetMap;

        // If the source is an event list, and *not* being driven by a fixed range around a date
        // and if datePicker is selecting a range, then datePicker must match the view's range.
        if (source.isEventList && !source.range && datePicker?.multiSelect === 'range') {
            datePicker.selection = [startDate, endDate];
        }
    }

    onDatePickerSelectionChange({ source, selection, oldSelection, userAction }, initialSelection) {
        const
            me              = this,
            { multiSelect } = source;

        const [startDate, endDate] = [selection[0], selection[selection.length - 1]];

        me.UIdateChange = userAction;

        // If they clear the date selection to nothing, we cannot upate our encapsulated date
        if (startDate) {
            const [min, max] = [
                    new Date(source.month.year, source.month.month, 1),
                    new Date(source.month.year, source.month.month + 1, 0)
                ],
                // Coerce a date to be within the source DatePicker's month so that it does not navigate
                // when the date reflects back to it when we set me.date later.
                visibleStartDate = multiSelect ? DateHelper.max(DateHelper.min(startDate, max), min) : startDate,
                viewConfig       = {};

            // If the datePicker is selecting a range, apply the range to any mode which is a DateRangeOwner
            if (multiSelect) {
                me.owner?.eachView(view => {
                    // WeekView is opinionated and sets its own fixedDuration property.
                    // The auto-created 'day' mode also gets this property set.
                    // So both these default views are protected from this.
                    // Any other DateRangeOwner view will have its range set from the DatePicker's selection.
                    if (view.isDateRangeOwner && !view.fixedDuration) {
                        const
                            { _hidden }    = view,
                            // Only snap the range up to week boundaries if we are selecting individual
                            // dates and filtering out unselected ones.
                            // If we are in range mode, the range *must* only be start->end
                            range          = source.getRange(multiSelect === true);

                        // What mode is the view in? startDate->endDate, or startDate:range?
                        if (view.hasConfig('endDate')) {
                            viewConfig.startDate = range.startDate;
                            // EventLists uses inclusive endDate
                            viewConfig.endDate = DateHelper.add(range.endDate, view.isEventList ? 0 : -1, 'd');
                        }
                        else {
                            viewConfig.range = range;
                        }

                        // The view prev/next methods navigate in single increments of the snapped-to-week range unit
                        // whether that is 'week' or 'month' unless the view was configured with its own shiftIncrement.
                        if (!view.initialConfig.shiftIncrement && me.snapMultiSelectNavigation) {
                            const snappedRange = multiSelect === true ? range : source.getRange(true);

                            viewConfig.shiftIncrement = { unit : snappedRange.unit, magnitude : 1 };
                        }

                        // If the view does not encapsulate the range, move it to do so.
                        // Not at startup time, only when the app starts changing selection.
                        if (!initialSelection && !DateHelper.betweenLesser(view.date, startDate, endDate)) {
                            viewConfig.date = visibleStartDate;
                        }
                        view._hidden = true;
                        view.setConfig(viewConfig);
                        view._hidden = _hidden;
                    }
                });

                // Fire data change event to keep UIs synced
                if (!me.isConfiguring) {
                    me.owner.eventStore.trigger('change');
                }
            }

            // Avoid recursion
            me.inOnDatePickerSelectionChange = true;
            me.date = visibleStartDate;
            me.inOnDatePickerSelectionChange = false;
            me.UIdateChange = false;
        }
    }

    changeDate(date, oldDate) {
        date = typeof date === 'string' ? DateHelper.parse(date) : new Date(date);
        if (isNaN(date)) {
            throw new Error('Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string');
        }

        date = DateHelper.clearTime(date);

        // Protect the setter from processing a no-change.
        if (!oldDate || (date - oldDate)) {
            return date;
        }
    }

    updateDate(date, oldDate) {
        const
            me             = this,
            { datePicker } = me.widgetMap;

        if (!me.isConfiguring && datePicker) {
            const
                { multiSelect, selection } = datePicker,
                clientView                 = me.owner.views.find(v => v.isDateRangeOwner && !v.fixedDuration && v.isVisible);

            if (multiSelect && clientView) {
                const
                    range      = datePicker.getRange(multiSelect === true),
                    config     = {
                        date
                    };
                let nextSelection;

                // we have to move the selection pattern in sync.
                if (!me.inOnDatePickerSelectionChange) {
                    // Potential discontiguous date range. Individual selections must all move forwards or backwards to match the view.
                    if (multiSelect === true) {
                        const
                            forwards       = date > oldDate,
                            shiftIncrement = { unit : 'day', magnitude : Math.abs(DateHelper.diff(range.startDate, clientView.startDate, 'd')) };

                        nextSelection = selection.map(d => DateHelper.add(d, shiftIncrement.magnitude * (forwards ? 1 : -1), shiftIncrement.unit));

                        // If a *contiguous* month range was selected from 1st to a month end, preserve this choice.
                        // For example when shifted, 1->30 April becomes 1->31 May, or 1->31 March becomes 1->28 Feb
                        if (range.wholeMonth) {
                            const endDate = nextSelection[nextSelection.length - 1];

                            let delta = DateHelper.getLastDateOfMonth(nextSelection[0]).getDate() - nextSelection.length;

                            // This is a 1-31 March moving to 1-28 Feb situation. We chop off 3 days.
                            if (delta < 0) {
                                nextSelection.length += delta;
                            }
                            // This is a 1-30 Apr moving to 1-31 May situation. We add the 31st.
                            else if (delta) {
                                for (let date = DateHelper.add(endDate, 1, 'd'); delta; delta--, date = DateHelper.add(date, 1, 'd')) {
                                    nextSelection.push(date);
                                }
                            }
                        }
                    }
                    // A simple [start, end] range. Move it to encapsulate the date
                    else {
                        // Interrogate our client view
                        // If it's in startDate:range mode, we have to step by range to cover the date.
                        // If it's in startDate->endDate mode, we just slide the date range enough to cover the date
                        // views are in startDate:range mode
                        if (clientView.range) {
                            date = clientView.snapDate(date);
                            nextSelection = [date, DateHelper.add(DateHelper.add(date, range), -1, 'd')];
                        }
                        // Views are in startDate->endDate mode
                        else {
                            // New selection range is in the future. Slide forwards just far enough to cover it.
                            if (date > selection[selection.length - 1]) {
                                range.magnitude *= -1;
                                nextSelection = [DateHelper.add(DateHelper.add(date, range), 1, 'd'), date];
                            }
                            // New selection range is in the past. Same deal, just backwards.
                            else if (date < selection[0]) {
                                nextSelection = [date, DateHelper.add(DateHelper.add(date, range), -1, 'd')];
                            }
                        }
                    }
                    if (nextSelection) {
                        config.selection = nextSelection;
                    }
                }

                datePicker.setConfig(config);
            }
            else {
                datePicker.value = date;
            }
        }

        me.trigger('dateChange', {
            date,
            oldDate,
            userAction : Boolean(me.UIdateChange)
        });
    }
}

Sidebar.initClass();
