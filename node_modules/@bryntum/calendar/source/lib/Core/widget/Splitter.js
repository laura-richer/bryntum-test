import Widget from './Widget.js';
import DomHelper from '../helper/DomHelper.js';
import EventHelper from '../helper/EventHelper.js';
import BrowserHelper from '../helper/BrowserHelper.js';

/**
 * @module Core/widget/Splitter
 */

const
    classesHV = ['b-horizontal', 'b-vertical'],
    hasFlex = el => DomHelper.getStyleValue(el.parentElement, 'display') === 'flex' &&
        (parseInt(DomHelper.getStyleValue(el, 'flex-basis'), 10) || parseInt(DomHelper.getStyleValue(el, 'flex-grow'), 10)),
    verticality = {
        horizontal : false,
        vertical   : true
    };

/**
 * A simple splitter widget that resizes the elements next to it or above/below it depending on orientation.
 *
 * Double click on the splitter to share the space evenly between the two neighboring elements.
 *
 * <kbd>CTRL</kbd> (<kbd>CMD</kbd> on Mac) double click to share the space evenly between *all* siblings in the parent container
 * {@inlineexample Core/widget/Splitter.js}
 *
 * @extends Core/widget/Widget
 * @classtype splitter
 * @widget
 */
export default class Splitter extends Widget {
    //region Config

    static $name = 'Splitter';

    static type = 'splitter';

    static get configurable() {
        return {
            /**
             * Fired when a drag starts
             * @event dragStart
             * @param {Core.widget.Splitter} source The Splitter
             * @param {MouseEvent|TouchEvent} event The DOM event
             */

            /**
             * Fired while dragging
             * @event drag
             * @param {Core.widget.Splitter} source The Splitter
             * @param {MouseEvent|TouchEvent} event The DOM event
             */

            /**
             * Fired after a drop
             * @event drop
             * @param {Core.widget.Splitter} source The Splitter
             * @param {MouseEvent|TouchEvent} event The DOM event
             */

            /**
             * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation
             * can be retrieved using {@link #property-currentOrientation}.
             * @member {'auto'|'horizontal'|'vertical'} orientation
             * @readonly
             */
            /**
             * The splitter's orientation, configurable with 'auto', 'horizontal' or 'vertical'.
             *
             * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element
             * or by comparing the positions of the closest sibling elements to the splitter. If they are above and
             * below 'horizontal' is used, if not it uses 'vertical'.
             *
             * ```
             * new Splitter({
             *    orientation : 'horizontal'
             * });
             * ```
             *
             * To receive the actually used orientation when configured with 'auto', see
             * {@link #property-currentOrientation}.
             *
             * @config {'auto'|'horizontal'|'vertical'}
             * @default
             */
            orientation : 'auto',

            /**
             * Set to `true` to show the splitter's collapse/expand buttons, or to 'start' or 'end' to only show
             * buttons pointing to the previous or next element respectively.
             *
             * Setting to `false` will hide the buttons.
             *
             * @config {Boolean|'start'|'end'}
             * @default
             */
            showButtons : false,

            vertical : null,

            containerElement : {
                $config : 'nullify',
                value   : null
            },

            nextNeighbor : {
                $config : 'nullify',
                value   : null
            },

            previousNeighbor : {
                $config : 'nullify',
                value   : null
            }
        };
    }

    static get delayable() {
        return {
            syncState : 'raf'
        };
    }

    //endregion

    //region Init & destroy

    doDestroy() {
        this.mouseDetacher?.();

        super.doDestroy();
    }

    //endregion

    //region Template & element

    compose() {
        return {
            class : {
                'b-splitter' : 1
            },
            children : this.showButtons ? [
                BrowserHelper.isTouchDevice ? { className : 'b-splitter-touch-area' } : null,
                {
                    className : 'b-splitter-inner',
                    children  : [
                        {
                            className : 'b-splitter-buttons',
                            reference : 'splitterButtons',
                            children  : [
                                {
                                    className : 'b-splitter-button-collapse',
                                    reference : 'collapseButton',
                                    children  : [
                                        BrowserHelper.isTouchDevice ? { className : 'b-splitter-button-touch-area' } : null,
                                        {
                                            tag       : 'i',
                                            className : 'b-icon b-icon-collapse-left b-splitter-collapse-arrow b-splitter-button-icon'
                                        }
                                    ]
                                },
                                {
                                    className : 'b-splitter-button-expand',
                                    reference : 'expandButton',
                                    children  : [
                                        BrowserHelper.isTouchDevice ? { className : 'b-splitter-button-touch-area' } : null,
                                        {
                                            tag       : 'i',
                                            className : 'b-icon b-icon-collapse-right b-splitter-expand-arrow b-splitter-button-icon'
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ] : null,
            // eslint-disable-next-line bryntum/no-listeners-in-lib
            listeners : {
                pointerdown : 'onMouseDown',
                mouseenter  : 'onMouseEnter',
                mouseleave  : 'onMouseLeave',
                mousewheel  : 'onScroll',
                dblclick    : 'onDoubleClick',

                ...(!BrowserHelper.supportsPointerEvents && {
                    mousedown  : 'onMouseDown',
                    touchstart : 'onMouseDown'
                })
            }
        };
    }

    //endregion

    //region Orientation

    /**
     * Get actually used orientation, which is either the configured value for `orientation` or if configured with
     * 'auto' the currently used orientation.
     * @property {String}
     * @readonly
     */
    get currentOrientation() {
        return this.vertical ? 'vertical' : 'horizontal';
    }

    getSibling(next = true) {
        let { element } = this,
            result;

        while (!result && (element = element[`${next ? 'next' : 'previous'}ElementSibling`])) {
            if (!element.isConnected || DomHelper.isVisible(element)) {
                result = element;
            }
        }

        return result;
    }

    get nextWidget() {
        let { element } = this,
            result;

        while (!result && (element = element.nextElementSibling)) {
            // Second arg used to be 1, but when used inside elements inside another widget (FiddlePanel), nextWidget &
            // previousWidget would both return the outer widget
            result = Widget.fromElement(element, this.element.parentElement);
        }

        return result;
    }

    get previousWidget() {
        let { element } = this,
            result;

        while (!result && (element = element.previousElementSibling)) {
            result = Widget.fromElement(element, this.element.parentElement);
        }

        return result;
    }

    get nextSplitter() {
        let { element } = this,
            result;

        while (!result && (element = element?.nextElementSibling)) {
            const widget = Widget.fromElement(element, this.element.parentElement);

            if (widget?.type === 'splitter') {
                result = widget;
            }
        }

        return result;
    }

    get previousSplitter() {
        let { element } = this,
            result;

        while (!result && (element = element?.previousElementSibling)) {
            const widget = Widget.fromElement(element, this.element.parentElement);

            if (widget?.type === 'splitter') {
                result = widget;
            }
        }

        return result;
    }

    updateContainerElement(containerElement) {
        const me = this;

        me.stateDetector = me.stateDetector?.disconnect();

        if (containerElement) {
            me.stateDetector = new MutationObserver(() => me.syncState());  // syncState runs on next raf

            me.stateDetector.observe(containerElement, {
                attributes : true,  // in case style changes flip our orientation (when == 'auto')
                childList  : true   // watch for our neighbors to render (so we can disable on hidden/collapsed state)
            });
        }
    }

    updateNextNeighbor(next) {
        this.watchNeighbor(next, 'next');
    }

    updatePreviousNeighbor(previous) {
        this.watchNeighbor(previous, 'previous');
    }

    watchNeighbor(neighbor, name) {
        this.detachListeners(name);

        neighbor?.ion({
            name,
            thisObj  : this,
            collapse : 'syncState',
            expand   : 'syncState',
            hide     : 'syncState',
            show     : 'syncState'
        });
    }

    updateOrientation() {
        this.syncState.now();
    }

    updateVertical(vertical) {
        const classList = this.element?.classList;

        classList?.add(classesHV[vertical ? 1 : 0]);
        classList?.remove(classesHV[vertical ? 0 : 1]);
    }

    /**
     * Determine orientation when set to `'auto'` and detects neighboring widgets to monitor their hidden/collapsed
     * states.
     * @private
     */
    syncState(context) {
        const
            me                                      = this,
            {
                element,
                nextWidget,
                previousWidget,
                nextSplitter,
                previousSplitter
            } = me;

        let vertical = verticality[me.orientation] ?? null;

        me.nextNeighbor     = nextWidget;
        me.previousNeighbor = previousWidget;

        me.disabled = !me.showButtons && (
            (
                nextWidget && ((nextWidget.collapsible && nextWidget.collapsed) || nextWidget.hidden)
            ) || (
                previousWidget && ((previousWidget.collapsible && previousWidget.collapsed) || previousWidget.hidden)
            )
        );

        if (
            nextSplitter?.collapseState?.status === 'collapsed' ||
            previousSplitter?.collapseState?.status === 'expanded' ||
            me.collapseState?.status === 'collapsed' ||
            me.collapseState?.status === 'expanded'
        ) {
            me.element.classList.add('b-drag-disabled');
        }
        else {
            me.element.classList.remove('b-drag-disabled');
        }

        if (context?.type === 'expand' && me.showButtons) {
            if (
                (context?.source === previousWidget && me.collapseState?.status === 'collapsed') ||
                (context?.source === nextWidget && me.collapseState?.status === 'expanded')
            ) {
                me.collapseState = null;
                element.classList.remove('b-drag-disabled', 'b-show-buttons');
            }

            me.setSplitterButtonPosition();
            me.setButtonVisibility();
        }
        else if (context?.type === 'collapse' && me.showButtons) {
            if (context.source === previousWidget && !me.collapseState) {
                me.collapseState = {
                    status : 'collapsed'
                };
            }
            else if (context.source === nextWidget && !me.collapseState) {
                me.collapseState = {
                    status : 'expanded'
                };
            }

            element.classList.add('b-drag-disabled', 'b-show-buttons');
            me.setSplitterButtonPosition();
            me.setButtonVisibility();
        }

        if (vertical !== null && nextWidget && previousWidget) {
            me.containerElement = null;
        }
        else {
            // we'll need to monitor parent element child list changes until our neighbors are added to the DOM
            me.containerElement = element.parentElement;

            // Orientation auto and already rendered, determine orientation to use
            if (me.rendered && element.offsetParent) {
                const flexDirection = DomHelper.getStyleValue(element.parentElement, 'flex-direction');

                // If used in a flex layout, determine orientation from flex-direction
                if (flexDirection) {
                    vertical = !flexDirection.startsWith('column');
                }
                // If used in some other layout, try to determine from sibling elements position
                else {
                    const
                        previous = element.previousElementSibling,
                        next = element.nextElementSibling;

                    if (!previous || !next) {
                        // To early in rendering, next sibling not rendered yet
                        return;
                    }

                    const
                        prevRect = previous.getBoundingClientRect(),
                        nextRect = next.getBoundingClientRect(),
                        topMost = prevRect.top < nextRect.top ? prevRect : nextRect,
                        bottomMost = topMost === nextRect ? prevRect : nextRect;

                    // orientation = topMost.top !== bottomMost.top ? 'horizontal' : 'vertical';
                    vertical = topMost.top === bottomMost.top;
                }
            }
        }

        me.vertical = vertical;
    }

    //endregion

    //region Collapse/Expand

    setButtonVisibility() {
        const
            {
                showButtons,
                collapseState,
                collapseButton,
                expandButton,
                nextWidget,
                previousWidget,
                nextSplitter,
                previousSplitter
            } = this;

        // If there is one-sided button config, toggle visibility based on collapse state and specific side of the button
        if (showButtons === 'start' || showButtons === 'end') {
            // If the collapse state is fully collapsed or expanded, show the opposite button to undo the collapse/expand
            if (collapseState?.status === 'collapsed' || collapseState?.status === 'expanded') {
                collapseButton.classList.toggle('b-disabled', collapseState.status === 'collapsed');
                expandButton.classList.toggle('b-disabled', collapseState.status === 'expanded');
            }
            // If the collapse state is neither collapsed nor expanded, show the buttons based on the side of the button config
            else {
                collapseButton.classList.toggle('b-disabled', (showButtons !== 'start' && !previousWidget?.collapsible) || previousSplitter?.collapseState?.status === 'expanded');
                expandButton.classList.toggle('b-disabled', (showButtons !== 'end' && !nextWidget?.collapsible) || nextSplitter?.collapseState?.status === 'collapsed');
            }
        }
        // If the button config is a boolean, toggle visibility based on collapse state
        else {
            collapseButton.classList.toggle('b-disabled', !showButtons || collapseState?.status === 'collapsed' || previousSplitter?.collapseState?.status === 'expanded');
            expandButton.classList.toggle('b-disabled', !showButtons || collapseState?.status === 'expanded' || nextSplitter?.collapseState?.status === 'collapsed');
        }

        // Notify neighboring splitters about the collapse state
        if (collapseState?.status !== 'expanded' && previousSplitter?.collapseState?.status === 'collapsed') {
            previousSplitter.setButtonVisibility();
        }
        else if (collapseState?.status !== 'collapsed' && nextSplitter?.collapseState?.status === 'expanded') {
            nextSplitter.setButtonVisibility();
        }
    }

    setSplitterButtonPosition(delta = 0) {
        const
            {
                vertical,
                splitterButtons,
                element: { parentElement }
            } = this;

        if (vertical) {
            const
                parentHeight = parentElement.clientHeight,
                parentScrollTop = parentElement.scrollTop + delta,
                newTop = Math.min(Math.max(0, parentScrollTop), parentElement.scrollHeight - parentHeight) + (parentHeight / 2);

            splitterButtons.style.top = `${newTop}px`;
        }
        else {
            const
                parentWidth = parentElement.clientWidth,
                parentScrollLeft = parentElement.scrollLeft + delta,
                newLeft = Math.min(Math.max(0, parentScrollLeft), parentElement.scrollWidth - parentWidth) + (parentWidth / 2);

            splitterButtons.style.left = `${newLeft}px`;
        }
    }

    restoreOriginalState() {
        const
            {
                nextNeighbor,
                previousNeighbor,
                collapseState,
                vertical
            } = this,
            prev        = previousNeighbor ? previousNeighbor.element : this.getSibling(false),
            next        = nextNeighbor ? nextNeighbor.element : this.getSibling();

        if (!collapseState) {
            return;
        }

        if (vertical) {
            if (collapseState.prevHasFlex) {
                prev.style.flexGrow = collapseState.prevFlexGrow;
            }
            else {
                prev.style.width = `${collapseState.prevWidth}px`;
            }

            if (collapseState.nextHasFlex) {
                next.style.flexGrow = collapseState.nextFlexGrow;
            }
            else {
                next.style.width = `${collapseState.nextWidth}px`;
            }
        }
        else {
            if (collapseState.prevHasFlex) {
                prev.style.flexGrow = collapseState.prevFlexGrow;
            }
            else {
                prev.style.height = `${collapseState.prevHeight}px`;
            }

            if (collapseState.nextHasFlex) {
                next.style.flexGrow = collapseState.nextFlexGrow;
            }
            else {
                next.style.height = `${collapseState.nextHeight}px`;
            }
        }
    }

    lockFlexedSiblings() {
        const corrections = [];

        for (const child of this.element.parentElement.children) {
            if (hasFlex(child) && child !== this.element && Widget.fromElement(child, this.element.parentElement)?.type !== 'splitter') {
                corrections.push({
                    child,
                    width  : child.offsetWidth,
                    height : child.offsetHeight
                });
            }
        }

        for (const correction of corrections) {
            correction.child.style.flexGrow = this.vertical ? correction.width : correction.height;
            correction.child.style.flexBasis = 0;
        }
    }

    //endregion

    //region Events

    onDoubleClick({ ctrlKey }) {
        // CtrlKey means even out all siblings, otherwise only the two immediate siblings
        const siblings = ctrlKey
            ? this.element.parentElement.querySelectorAll(':scope > :not(.b-splitter)')
            : [this.getSibling(false), this.getSibling()];

        // Double click shares the space evenly between the siblings
        siblings.forEach(e => e && (e.style.flex = '1 1 0px'));
    }

    onMouseDown(event) {
        const
            me = this,
            { target } = event;

        if (target.closest('.b-splitter-button-collapse')) {
            me.onCollapseClick(event);
        }
        else if (target.closest('.b-splitter-button-expand')) {
            me.onExpandClick(event);
        }
        else if (
            me.collapseState?.status !== 'collapsed' &&
            me.collapseState?.status !== 'expanded' &&
            me.nextSplitter?.collapseState?.status !== 'collapsed' &&
            me.previousSplitter?.collapseState?.status !== 'expanded'
        ) {
            me.startMove(event);
        }
    }

    startMove(event) {
        event.preventDefault();

        if (event.touches) {
            event = event.touches[0];
        }

        const
            me          = this,
            {
                element,
                nextNeighbor,
                previousNeighbor
            } = me,
            prev        = previousNeighbor ? previousNeighbor.element : me.getSibling(false),
            next        = nextNeighbor ? nextNeighbor.element : me.getSibling(),
            prevHasFlex = hasFlex(prev),
            nextHasFlex = hasFlex(next),
            flexed      = [];

        // First stop any ongoing drag operation, since we cannot trust that we always get the mouseup event
        me.mouseDetacher?.();

        // Clear any existing collapse state and show both splitter buttons
        if (me.showButtons) {
            me.collapseState = null;
            me.setButtonVisibility();
        }

        // Remember flexed children, to enable maintaining their proportions on resize
        for (const child of element.parentElement.children) {
            if (hasFlex(child) && child !== element && Widget.fromElement(child, element.parentElement)?.type !== 'splitter') {
                flexed.push({
                    element : child,
                    width   : child.offsetWidth,
                    height  : child.offsetHeight
                });
            }
        }

        me.context = {
            startX     : event.pageX,
            startY     : event.pageY,
            prevWidth  : prev.offsetWidth,
            prevHeight : prev.offsetHeight,
            nextWidth  : next.offsetWidth,
            nextHeight : next.offsetHeight,
            prevHasFlex,
            nextHasFlex,
            flexed,
            prev,
            next
        };

        const events = {
            element     : document,
            pointermove : 'onMouseMove',
            pointerup   : 'onMouseUp',
            thisObj     : me
        };


        if (!BrowserHelper.supportsPointerEvents) {
            events.mousemove = events.touchmove = 'onMouseMove';
            events.mouseup   = events.touchend  = 'onMouseUp';
        }

        element.classList.add('b-moving');
        me.mouseDetacher = EventHelper.on(events);

        me.trigger('splitterMouseDown', { event });
    }

    onMouseEnter(event) {
        const me = this;

        me.syncState();
        me.trigger('splitterMouseEnter', { event });

        if (me.showButtons) {
            me.setSplitterButtonPosition();
            me.setButtonVisibility();
        }

        me.element.classList.add('b-hover');
    }

    onMouseLeave(event) {
        this.trigger('splitterMouseLeave', { event });
        this.element.classList.remove('b-hover');
    }

    onMouseMove(event) {
        const
            {
                context,
                nextWidget,
                previousWidget,
                vertical,
                rtl
            }         = this,
            prevStyle = context.prev.style,
            nextStyle = context.next.style,
            deltaX    = (event.pageX - context.startX) * (rtl ? -1 : 1),
            deltaY    = event.pageY - context.startY;

        event.preventDefault();

        Object.assign(context, {
            deltaX,
            deltaY
        });

        if (!context.started) {
            context.started = true;

            this.trigger('dragStart', { context, event });

            // Convert heights/widths to flex for flexed elements to maintain proportions
            // 100px high -> flex-grow 100
            context.flexed.forEach(flexed => {
                flexed.element.style.flexGrow = vertical ? flexed.width : flexed.height;
                //Remove flex-basis, since it interferes with resizing
                flexed.element.style.flexBasis = '0';
            });
        }

        // Adjust flex-grow or width/height for splitter's closest siblings
        if (vertical) {
            const
                newPrevWidth = context.prevWidth + deltaX,
                newNextWidth = context.nextWidth - deltaX;

            if (context.prevHasFlex) {
                prevStyle.flexGrow = newPrevWidth;
            }
            else if (previousWidget) {
                previousWidget.width = newPrevWidth;
            }
            else {
                prevStyle.width = `${newPrevWidth}px`;
            }

            if (context.nextHasFlex) {
                nextStyle.flexGrow = newNextWidth;
            }
            else if (nextWidget) {
                nextWidget.width = newNextWidth;
            }
            else {
                nextStyle.width = `${newNextWidth}px`;
            }
        }
        else {
            const
                newPrevHeight = context.prevHeight + deltaY,
                newNextHeight = context.nextHeight - deltaY;

            if (context.prevHasFlex) {
                prevStyle.flexGrow = newPrevHeight;
            }
            else if (previousWidget) {
                previousWidget.height = newPrevHeight;
            }
            else {
                prevStyle.height = `${newPrevHeight}px`;
            }

            if (context.nextHasFlex) {
                nextStyle.flexGrow = newNextHeight;
            }
            else if (nextWidget) {
                nextWidget.height = newNextHeight;
            }
            else {
                nextStyle.height = `${newNextHeight}px`;
            }
        }

        this.trigger('drag', { context, event });
    }

    onMouseUp(event) {
        const me = this;

        me.mouseDetacher?.();
        me.mouseDetacher = null;
        me.element.classList.remove('b-moving');

        if (me.context.started) {
            me.trigger('drop', { context : me.context, event });
        }

        me.context = null;
    }

    onScroll(context) {
        const
            { deltaY, shiftKey } = context,
            { vertical } = this;

        if (shiftKey && !vertical || !shiftKey && vertical) {
            this.setSplitterButtonPosition(deltaY);
        }
    }

    onCollapseClick(event) {
        const
            me = this,
            {
                nextNeighbor,
                nextWidget,
                previousNeighbor,
                previousWidget,
                collapseState,
                showButtons,
                vertical
            } = me,
            prev        = previousNeighbor ? previousNeighbor.element : me.getSibling(false),
            next        = nextNeighbor ? nextNeighbor.element : me.getSibling(),
            prevHasFlex = hasFlex(prev),
            nextHasFlex = hasFlex(next);

        // If the splitter is already collapsed or the collapse button is disabled, do nothing,
        // except when the next neighbor is collapsible or the splitter is expanded
        if (
            (showButtons === 'end' && !previousWidget?.collapsible && collapseState?.status !== 'expanded') ||
            collapseState?.status === 'collapsed'
        ) {
            return;
        }

        event.stopPropagation();

        // create a new collapse state object to remember the original dimensions and flex-grow values
        let nextCollapseState = {
            status : 'collapsed'
        };

        // When the collapse state is not yet defined, we are in the initial state and will be moving to the collapsed state,
        // show the buttons
        me.element.classList.toggle('b-show-buttons', !collapseState);

        // If we're collapsing and the previous widget has a minWidth, remember and overwrite it with 0
        if (previousWidget && !collapseState?.status && vertical && previousWidget.minWidth > 0) {
            nextCollapseState = {
                ...nextCollapseState,
                prevMinWidth : previousWidget.minWidth
            };
            previousWidget.minWidth = 0;
        }
        else if (previousWidget && !collapseState?.status && !vertical && previousWidget.minHeight > 0) {
            nextCollapseState = {
                ...nextCollapseState,
                prevMinHeight : previousWidget.minHeight
            };
            previousWidget.minHeight = 0;
        }

        // If we're currently expanded and returning to the initial state and next widget has a stored minWidth/minHeight
        // restore the original minWidth/minHeight values
        if (nextWidget && collapseState?.status === 'expanded' && (collapseState?.nextMinWidth || collapseState?.nextMinHeight)) {
            if (vertical) {
                nextWidget.minWidth = collapseState.nextMinWidth;
            }
            else {
                nextWidget.minHeight = collapseState.nextMinHeight;
            }
        }

        // When:
        //  - there is no collapse state, meaning we are in the initial state
        //  - previous widget is collapsible
        //  - previous widget is not collapsed
        // then collapse the previous widget and listen for the expand event
        if (!collapseState && previousWidget?.collapsible && !previousWidget?.collapsed) {
            // Some components (like Gantt and Scheduler) use PanelCollapser to collapse the widget
            if (previousWidget.collapsible.isPanelCollapser) {
                previousWidget.collapsible.collapse();
            }
            else {
                previousWidget.collapse();
            }
        }
        // Else, when:
        //  - collapse state is defined
        //  - next widget is collapsible
        //  - next widget is collapsed
        // then expand the next widget
        else if (
            collapseState?.status === 'expanded' &&
            nextWidget?.collapsible &&
            (nextWidget?.collapsed || nextWidget?.collapsible?.collapsed)
        ) {
            // Some components (like Gantt and Scheduler) use PanelCollapser to collapse the widget
            if (nextWidget.collapsible.isPanelCollapser) {
                nextWidget.collapsible.collapse(false);
            }
            else {
                nextWidget.expand();
            }
        }
        else {
            // If the collapse state is expanded, restore the initial state defined by the collapse state
            if (collapseState?.status === 'expanded') {
                me.restoreOriginalState();
            }
            // If we are in the initial state,we need to take control of the splitter's flex-grow/height/width values
            else {
                // remember the flex-grow values of the flexed siblings
                me.lockFlexedSiblings();

                nextCollapseState = {
                    ...nextCollapseState,
                    prevWidth    : prev.offsetWidth,
                    prevHeight   : prev.offsetHeight,
                    prevHasFlex,
                    prevFlexGrow : prevHasFlex ? prev.style.flexGrow : null,
                    nextWidth    : next.offsetWidth,
                    nextHeight   : next.offsetHeight,
                    nextHasFlex,
                    nextFlexGrow : nextHasFlex ? next.style.flexGrow : null
                };

                if (me.vertical) {
                    const newWidth = prev.offsetWidth + next.offsetWidth;

                    if (prevHasFlex) {
                        prev.style.flexGrow = 1;
                    }
                    else {
                        prev.style.width = '0px';
                    }

                    if (me.nextSplitter?.collapseState?.status !== 'collapsed') {
                        if (nextHasFlex) {
                            next.style.flexGrow = newWidth;
                        }
                        else {
                            next.style.width = `${newWidth}px`;
                        }
                    }
                    else {
                        if (nextHasFlex) {
                            next.style.flexGrow = 1;
                        }
                        else {
                            next.style.width = '0px';
                        }
                    }
                }
                else {
                    const newHeight = prev.offsetHeight + next.offsetHeight;

                    if (prevHasFlex) {
                        prev.style.flexGrow = 1;
                    }
                    else {
                        prev.style.height = '0px';
                    }

                    if (me.nextSplitter?.collapseState?.status !== 'collapsed') {
                        if (nextHasFlex) {
                            next.style.flexGrow = newHeight;
                        }
                        else {
                            next.style.height = `${newHeight}px`;
                        }
                    }
                    else {
                        if (nextHasFlex) {
                            next.style.flexGrow = 1;
                        }
                        else {
                            next.style.height = '0px';
                        }
                    }
                }
            }
        }

        // If the collapse state is not defined (initial state, moving to collapsed state), set the next collapse state
        me.collapseState = collapseState ? null : nextCollapseState;
        me.element.classList.toggle('b-drag-disabled', !collapseState);
        me.setButtonVisibility();
    }

    onExpandClick(event) {
        const
            me = this,
            {
                nextNeighbor,
                nextWidget,
                previousNeighbor,
                previousWidget,
                collapseState,
                showButtons,
                vertical
            } = me,
            prev        = previousNeighbor ? previousNeighbor.element : me.getSibling(false),
            next        = nextNeighbor ? nextNeighbor.element : me.getSibling(),
            prevHasFlex = hasFlex(prev),
            nextHasFlex = hasFlex(next);

        // If the splitter is already expanded or the expand button is disabled, do nothing,
        // except when the next neighbor is collapsible or the splitter is collapsed
        if (
            (showButtons === 'start' && !nextWidget?.collapsible && collapseState?.status !== 'collapsed') ||
            collapseState?.status === 'expanded'
        ) {
            return;
        }

        event.stopPropagation();

        // create a new collapse state object to remember the original dimensions and flex-grow values
        let nextCollapseState = {
            status : 'expanded'
        };

        // When the collapse state is not yet defined, we are in the initial state and will be moving to the expanded state,
        // show the buttons
        me.element.classList.toggle('b-show-buttons', !collapseState);

        // If we're expanding and the previous widget has a minWidth, remember and overwrite it with 0
        if (!collapseState?.status && vertical && nextWidget.minWidth > 0) {
            nextCollapseState = {
                ...nextCollapseState,
                nextMinWidth : nextWidget.minWidth
            };
            nextWidget.minWidth = 0;
        }
        else if (!collapseState?.status && !vertical && nextWidget.minHeight > 0) {
            nextCollapseState = {
                ...nextCollapseState,
                nextMinHeight : nextWidget.minHeight
            };
            nextWidget.minHeight = 0;
        }

        // If we're currently expanded and returning to the initial state and next widget has a stored minWidth/minHeight
        // restore the original minWidth/minHeight values
        if (previousWidget && collapseState?.status === 'collapsed' && (collapseState?.prevMinWidth || collapseState?.prevMinHeight)) {
            if (vertical) {
                previousWidget.minWidth = collapseState.prevMinWidth;
            }
            else {
                previousWidget.minHeight = collapseState.prevMinHeight;
            }
        }

        // When:
        //  - collapse state is not defined, meaning we are in the initial state
        //  - next widget is collapsible
        //  - next widget is not collapsed
        // then collapse the next widget and listen for the expand event
        if (!collapseState && nextWidget?.collapsible && !nextWidget?.collapsed) {
            // Some components (like Gantt and Scheduler) use PanelCollapser to collapse the widget
            if (nextWidget.collapsible.isPanelCollapser) {
                nextWidget.collapsible.collapse();
            }
            else {
                nextWidget.collapse();
            }
        }
        // Else, when:
        //  - collapse state is defined
        //  - previous widget is collapsible
        //  - previous widget is collapsed
        // then expand the previous widget
        else if (
            collapseState?.status === 'collapsed' &&
            previousWidget?.collapsible &&
            (previousWidget?.collapsed || previousWidget?.collapsible?.collapsed)
        ) {
            // Some components (like Gantt and Scheduler) use PanelCollapser to collapse the widget
            if (previousWidget.collapsible.isPanelCollapser) {
                previousWidget.collapsible.collapse(false);
            }
            else {
                previousWidget.expand();
            }
        }
        else {
            // If the collapse state is collapsed, restore the initial state defined by the collapse state
            if (collapseState?.status === 'collapsed') {
                me.restoreOriginalState();
            }
            // Else, we need to take control of the splitter's flex-grow/height/width values
            else {
                // remember the flex-grow values of the flexed siblings
                me.lockFlexedSiblings();

                nextCollapseState = {
                    ...nextCollapseState,
                    prevWidth    : prev.offsetWidth,
                    prevHeight   : prev.offsetHeight,
                    prevHasFlex,
                    prevFlexGrow : prevHasFlex ? prev.style.flexGrow : null,
                    nextWidth    : next.offsetWidth,
                    nextHeight   : next.offsetHeight,
                    nextHasFlex,
                    nextFlexGrow : nextHasFlex ? next.style.flexGrow : null
                };

                if (me.vertical) {
                    const newWidth = prev.offsetWidth + next.offsetWidth;

                    if (me.previousSplitter?.collapseState?.status !== 'expanded') {
                        if (prevHasFlex) {
                            prev.style.flexGrow = newWidth;
                        }
                        else {
                            prev.style.width = `${newWidth}px`;
                        }
                    }
                    else {
                        if (prevHasFlex) {
                            prev.style.flexGrow = 1;
                        }
                        else {
                            prev.style.width = '0px';
                        }
                    }

                    if (nextHasFlex) {
                        next.style.flexGrow = 1;
                    }
                    else {
                        next.style.width = '0px';
                    }
                }
                else {
                    const newHeight = prev.offsetHeight + next.offsetHeight;

                    if (me.previousSplitter?.collapseState?.status !== 'expanded') {
                        if (prevHasFlex) {
                            prev.style.flexGrow = newHeight;
                        }
                        else {
                            prev.style.height = `${newHeight}px`;
                        }
                    }
                    else {
                        if (prevHasFlex) {
                            prev.style.flexGrow = 1;
                        }
                        else {
                            prev.style.height = '0px';
                        }
                    }

                    if (nextHasFlex) {
                        next.style.flexGrow = 1;
                    }
                    else {
                        next.style.height = '0px';
                    }
                }
            }
        }

        // If the collapse state is not defined (initial state, moving to expanded state), set the next collapse state
        me.collapseState = collapseState ? null : nextCollapseState;
        me.element.classList.toggle('b-drag-disabled', !collapseState);
        me.setButtonVisibility();
    }

    //endregion

    render() {
        super.render(...arguments);

        this.syncState.now();

        if (this.vertical === null) {
            this.syncState();  // try again on next raf
        }
    }
}

// Register this widget type with its Factory
Splitter.initClass();
