import { Reject } from "../../../../ChronoGraph/chrono/Effect.js"
import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/BetterMixin.js'
import { CalculationIterator } from '../../../../ChronoGraph/primitives/Calculation.js'
import { calculate, field } from '../../../../ChronoGraph/replica/Entity.js'
import { ConflictEffect, ConstraintInterval } from "../../../chrono/Conflict.js"
import { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js'
import { EngineReplica } from "../../../chrono/Replica.js"
import { EffectResolutionResult } from "../../../chrono/SchedulingIssueEffect.js"
import { DateInterval } from '../../../scheduling/DateInterval.js'
import { Direction, EffectiveDirection } from '../../../scheduling/Types.js'
import { isDateFinite } from "../../../util/Constants.js"
import { HasSubEventsMixin } from "../scheduler_basic/HasSubEventsMixin.js"
import { ConstrainedScheduleMixin } from "./ConstrainedScheduleMixin.js"
import { HasPercentDoneMixin } from './HasPercentDoneMixin.js'
import { SchedulerProProjectMixin } from "./SchedulerProProjectMixin.js"

//---------------------------------------------------------------------------------------------------------------------
/**
 * This mixin provides the constraint-based scheduling. Event is scheduled according to the set of _constraints_
 * which can be applied to start date or end date.
 *
 * Scheduling by constraints for an event can be disabled by setting its [[manuallyScheduled]] flag to `true`, which will delegate to previous behavior.
 *
 * The constraint is represented with the [[DateInterval]] class, which indicates the "allowed" interval for the
 * point being constrained.
 *
 * Scheduling by constraints algorithm
 * ---------------------------------
 *
 * Constraints for start date are accumulated in the [[startDateConstraintIntervals]] field of event itself and in the
 * [[ConstrainedScheduleMixin.startDateConstraintIntervals]] field of its [[earlySchedule]].
 * Constraints for end date are accumulated in the [[endDateConstraintIntervals]] field of event itself and in the
 * [[ConstrainedScheduleMixin.endDateConstraintIntervals]] field of its [[earlySchedule]].
 *
 * This mixin does not define where the constraints for the event comes from. The constraints are calculated in the event's schedule field
 * calculation methods, (like [[ConstrainedScheduleMixin.calculateStartDateConstraintIntervals]]) which just return empty arrays. Some other mixins
 * may override those methods and can generate actual constraints (the [[ConstrainedByDependenciesEventMixin]] is an example).

 * The "early" fields contains the constraints which are related to scheduling event in the as-soon-as-possible manner.
 * The fields w/o "early" prefix contains the constraints which do not relate to the ASAP scheduling.
 *
 * "Early" and "normal" constraints for every date are combined, then intersected, which gives "combined" constraining interval.
 *
 * So at this point we have a "combined" constraining interval for start date and for end date.
 *
 * Then, the interval for start date is shifted on the event duration to the right and this gives an additional constraint for the
 * end date. The similar operation is done with the interval for the end date.
 *
 * After intersection with those additional intervals we receive the final constraining interval for both dates. Since we
 * are using the ASAP scheduling, we just pick the earliest possible date.
 *
 * If any of intervals is empty then we consider it as scheduling conflict, and [[EngineReplica.reject|reject]] the transaction.
 *
 */
export class ConstrainedEarlyEventMixin extends Mixin(
    [ HasSubEventsMixin, HasPercentDoneMixin ],
    (base : AnyConstructor<HasSubEventsMixin & HasPercentDoneMixin, typeof HasSubEventsMixin & typeof HasPercentDoneMixin>) => {

    const superProto : InstanceType<typeof base> = base.prototype


    class ConstrainedEarlyEventMixin extends base {
        static scheduleMixinClass   : typeof ConstrainedScheduleMixin           = ConstrainedScheduleMixin

        _earlySchedule           : ConstrainedScheduleMixin

        /**
         * A [[ConstrainedScheduleMixin]] for this event, which is used for scheduling by constraints and dependencies.
         */
        get earlyPreSchedule () : ConstrainedScheduleMixin {
            return this.earlySchedule
        }

        /**
         * A [[ConstrainedScheduleMixin]], which in the absence of late scheduling is just an alias for [[earlyPreSchedule]]
         */
        get earlySchedule () : ConstrainedScheduleMixin {
            if (this._earlySchedule !== undefined) return this._earlySchedule

            const schedule      = new (this.constructor as typeof ConstrainedEarlyEventMixin).scheduleMixinClass({
                // Assign id to avoid expensive id generation
                id : 'earlySchedule' // no-sanity
            }, null, null, false, true) // Skip cloning
            schedule.event      = this

            return this._earlySchedule = schedule
        }

        project     : SchedulerProProjectMixin

        /**
         * The earliest possible date the event can start.
         * This value is calculated based on the event restrictions.
         */
        @model_field(
            { type : 'date', persist : false, calculated : true },
            { lazy : true, converter : dateConverter, persistent : false }
        )
        earlyStartDate : Date


        /**
         * The earliest possible date the event can finish.
         * This value is calculated based on the event restrictions.
         */
        @model_field(
            { type : 'date', persist : false, calculated : true  },
            { lazy : true, converter : dateConverter, persistent : false }
        )
        earlyEndDate : Date

        //--------------------------
        /**
         * Field to accumulate the "generic" constraints for start date (which are not related to ASAP scheduling).
         * It is calculated with [[calculateStartDateConstraintIntervals]].
         */
        @field()
        startDateConstraintIntervals    : DateInterval[]

        /**
         * Field to accumulate the "generic" constraints for end date (which are not related to ASAP scheduling).
         * It is calculated with [[calculateEndDateConstraintIntervals]].
         */
        @field()
        endDateConstraintIntervals      : DateInterval[]


        enterGraph (replica : EngineReplica) {
            super.enterGraph(replica)

            this.earlySchedule.enterGraph(replica)
        }

        leaveGraph (replica : EngineReplica) {
            this.earlySchedule.leaveGraph(replica)

            super.leaveGraph(replica)
        }

        unlink () {
            this.earlySchedule.unlink()

            super.unlink()
        }


        @calculate('earlyStartDate')
        * calculateEarlyStartDate () : CalculationIterator<Date> {
            return yield this.earlySchedule.$.startDate
        }


        @calculate('earlyEndDate')
        * calculateEarlyEndDate () : CalculationIterator<Date | boolean> {
            return yield this.earlySchedule.$.endDate
        }


        @calculate('startDateConstraintIntervals')
        * calculateStartDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            return []
        }

        @calculate('endDateConstraintIntervals')
        * calculateEndDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            return []
        }


        * calculateEarlyStartDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            return []
        }

        * calculateEarlyEndDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            return []
        }

        * calculateLateStartDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            return []
        }

        * calculateLateEndDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            return []
        }

        /**
         * The method defines whether the provided child event should be
         * taken into account when calculating this summary event [[earlyStartDate]].
         * Child events roll up their [[earlyStartDate]] values to their summary tasks.
         * So a summary task [[earlyStartDate]] date gets equal to its minimal child [[earlyStartDate]].
         *
         * If the method returns `true` the child event is taken into account
         * and if the method returns `false` it's not.
         * By default, the method returns `true` to include all child events data.
         * @param child Child event to consider.
         * @returns `true` if the provided event should be taken into account, `false` if not.
         */
        * shouldRollupChildEarlyStartDate (child : ConstrainedEarlyEventMixin) : CalculationIterator<boolean> {
            return true
        }

        /**
         * The method defines whether the provided child event should be
         * taken into account when calculating this summary event [[earlyEndDate]].
         * Child events roll up their [[earlyEndDate]] values to their summary tasks.
         * So a summary task [[earlyEndDate]] gets equal to its maximal child [[earlyEndDate]].
         *
         * If the method returns `true` the child event is taken into account
         * and if the method returns `false` it's not.
         * By default, the method returns `true` to include all child events data.
         * @param child Child event to consider.
         * @returns `true` if the provided event should be taken into account, `false` if not.
         */
        * shouldRollupChildEarlyEndDate (child : ConstrainedEarlyEventMixin) : CalculationIterator<boolean> {
            return true
        }

        /**
         * The method defines wether the provided child event should be
         * taken into account when calculating this summary event [[lateStartDate]].
         * Child events roll up their [[lateStartDate]] values to their summary tasks.
         * So a summary task [[lateStartDate]] date gets equal to its minimal child [[lateStartDate]].
         *
         * If the method returns `true` the child event is taken into account
         * and if the method returns `false` it's not.
         * By default the method returns `true` to include all child events data.
         * @param childEvent Child event to consider.
         * @returns `true` if the provided event should be taken into account, `false` if not.
         */
        * shouldRollupChildLateStartDate (childEvent : ConstrainedEarlyEventMixin) : CalculationIterator<boolean> {
            return true
        }

        /**
         * The method defines wether the provided child event should be
         * taken into account when calculating this summary event [[lateEndDate]].
         * Child events roll up their [[lateEndDate]] values to their summary tasks.
         * So a summary task [[lateEndDate]] gets equal to its maximal child [[lateEndDate]].
         *
         * If the method returns `true` the child event is taken into account
         * and if the method returns `false` it's not.
         * By default the method returns `true` to include all child events data.
         * @param childEvent Child event to consider.
         * @returns `true` if the provided event should be taken into account, `false` if not.
         */
        * shouldRollupChildLateEndDate (childEvent : ConstrainedEarlyEventMixin) : CalculationIterator<boolean> {
            return true
        }


        * calculateStartDatePure () : CalculationIterator<Date> {
            const direction : EffectiveDirection    = yield this.$.effectiveDirection

            let result : Date

            const manuallyScheduled : boolean                        = yield* this.isManuallyScheduled()

            // early exit if this mixin is not applicable, but only after(!) the direction check
            // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,
            // depending on the direction
            // Note, that "simple" checks for `manuallyScheduled` and `unscheduled` goes prior the `isConstrainedEarly`
            // this is because `isConstrainedEarly` checks the start/end intervals, which may trigger a cycle in some
            // edge cases (see #7605), however, just being `manuallyScheduled` is enough for a task to skip those
            if (!manuallyScheduled && !(yield this.$.unscheduled) && (yield* this.isConstrainedAlongDirection(direction.direction))) {

                if (yield* this.hasSubEvents()) {
                    return yield* this.calculateMinChildrenStartDate()
                }

                result = yield this.pickDirectionSchedule(direction.direction).$.startDate
            }

            return result || (yield* superProto.calculateStartDatePure.call(this))
        }


        * calculateStartDateProposed () : CalculationIterator<Date> {
            const direction : EffectiveDirection    = yield this.$.effectiveDirection

            let result : Date

            const manuallyScheduled : boolean                        = yield* this.isManuallyScheduled()

            // early exit if this mixin is not applicable, but only after(!) the direction check
            // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,
            // depending on the direction
            if (!manuallyScheduled && !(yield this.$.unscheduled) && (yield* this.isConstrainedAlongDirection(direction.direction))) {

                if (yield* this.hasSubEvents()) {
                    return yield* this.calculateMinChildrenStartDate()
                }

                result = yield this.pickDirectionSchedule(direction.direction).$.startDate

                // is this code still needed?
                if (result && !isDateFinite(result)) {
                    throw new Error("Fix me")

                    // const baseSchedulingStartDate : Date                    = yield* superProto.calculateStartDateProposed.call(this)
                    // const earlyEffectiveStartDateInterval : DateInterval    = yield this.$.earlyEffectiveStartDateInterval
                    //
                    // if (earlyEffectiveStartDateInterval.containsDate(baseSchedulingStartDate)) return baseSchedulingStartDate
                    //
                    // return isDateFinite(earlyEffectiveStartDateInterval.endDate) ? earlyEffectiveStartDateInterval.endDate : baseSchedulingStartDate
                }
            }

            return result || (yield* superProto.calculateStartDateProposed.call(this))
        }


        * calculateEndDatePure () : CalculationIterator<Date> {
            const direction : EffectiveDirection    = yield this.$.effectiveDirection

            let result : Date

            const manuallyScheduled : boolean       = yield* this.isManuallyScheduled()

            // early exit if this mixin is not applicable, but only after(!) the direction check
            // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,
            // depending on the direction
            if (!manuallyScheduled && !(yield this.$.unscheduled) && (yield* this.isConstrainedAlongDirection(direction.direction))) {

                if (yield* this.hasSubEvents()) {
                    return yield* this.calculateMaxChildrenEndDate()
                }

                result = yield this.pickDirectionSchedule(direction.direction).$.endDate
            }

            return result || (yield* superProto.calculateEndDatePure.call(this))
        }


        * calculateEndDateProposed () : CalculationIterator<Date> {
            const direction : EffectiveDirection     = yield this.$.effectiveDirection

            let result : Date

            const manuallyScheduled : boolean                        = yield* this.isManuallyScheduled()

            // early exit if this mixin is not applicable, but only after(!) the direction check
            // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,
            // depending on the direction
            if (!manuallyScheduled && !(yield this.$.unscheduled) && (yield* this.isConstrainedAlongDirection(direction.direction))) {

                if (yield* this.hasSubEvents()) {
                    return yield* this.calculateMaxChildrenEndDate()
                }

                result = yield this.pickDirectionSchedule(direction.direction).$.endDate

                // is this code still needed?
                if (result && !isDateFinite(result)) {
                    throw new Error("Fix me")

                    // const baseSchedulingEndDate : Date                  = yield* superProto.calculateEndDateProposed.call(this)
                    // const earlyEffectiveEndDateInterval : DateInterval  = yield this.$.effectiveEndDateInterval
                    //
                    // if (earlyEffectiveEndDateInterval.containsDate(baseSchedulingEndDate)) return baseSchedulingEndDate
                    //
                    // return isDateFinite(earlyEffectiveEndDateInterval.endDate) ? earlyEffectiveEndDateInterval.endDate : baseSchedulingEndDate
                }
            }

            return result || (yield* superProto.calculateEndDateProposed.call(this))
        }


        * isConstrainedAlongDirection (direction : Direction) : CalculationIterator<boolean> {
            return yield* this.earlySchedule.isConstrained()
        }


        pickDirectionSchedule (ownDirection : Direction) : ConstrainedScheduleMixin {
            return this.earlySchedule
        }


        * createConflictEffect (type : 'start' | 'end', sourceSchedule : ConstrainedScheduleMixin) : CalculationIterator<ConflictEffect> {
            // re-calculate effective resulting interval gathering intersection history
            const effectiveInterval = type === 'start'
                ? yield* sourceSchedule.doCalculateEffectiveStartDateInterval(true)
                : yield* sourceSchedule.doCalculateEffectiveEndDateInterval(true)

            return ConflictEffect.new({
                intervals       : [...effectiveInterval.intersectionOf] as ConstraintInterval[],
                sourceSchedule
            })
        }


        * onEmptyEffectiveInterval (type : 'start' | 'end', sourceSchedule : ConstrainedScheduleMixin)
            :
                CalculationIterator<
                    { kind : 'resume' }
                    | { kind : 'return', value : Date }
                    | { kind : 'resolved', value : DateInterval }
                >
        {
            const conflict : ConflictEffect = yield* this.createConflictEffect(type, sourceSchedule)

            if ((yield conflict) === EffectResolutionResult.Cancel) {
                yield Reject(conflict)
                return { kind : 'resume' as 'resume' }
            } else {
                return { kind : 'return' as 'return', value : null }
            }
        }


        * onNonEmptyEffectiveInterval (type : 'start' | 'end', sourceSchedule : ConstrainedScheduleMixin)
            :
                CalculationIterator<void>
        {
        }
    }

    return ConstrainedEarlyEventMixin
}){}
