import Toolbar from './Toolbar.js';
import ArrayHelper from '../helper/ArrayHelper.js';

import './Tab.js';

/**
 * @module Core/widget/TabBar
 */

const isTab = t => t.isTab;

/**
 * A special toolbar used by {@link Core.widget.TabPanel} to present {@link Core.widget.Tab tabs} for the container's
 * items.
 *
 * The {@link Core.widget.Container#config-items} of a tab bar are typically managed by the tab panel, however,
 * items can be added that do not correspond to items in the tab panel. The {@link Core.widget.Widget#config-weight}
 * config of each tab defaults to 0 or the weight of its corresponding item.
 *
 * {@inlineexample Core/widget/TabBar.js}
 *
 * @extends Core/widget/Toolbar
 * @classtype tabbar
 * @internalwidget
 */
export default class TabBar extends Toolbar {

    static $name = 'TabBar';

    static type = 'tabbar';

    static configurable = {
        defaultType : 'tab',

        overflow : 'scroll',

        role : 'tablist',

        ignoreParentReadOnly : true
    };

    get firstTab() {
        return this.tabAt(0);
    }

    get lastTab() {
        return this.tabAt(-1);
    }

    get tabCount() {
        return this._items.countOf(isTab);
    }

    get tabs() {
        return ArrayHelper.from(this._items, isTab);
    }

    compose() {
        return {
            children : {
                toolbarContent : {
                    class : {
                        'b-tabpanel-tabs' : 1
                    }
                }
            }
        };
    }

    indexOfTab(tab) {
        return this._items.indexOf(tab, isTab);
    }

    onChildAdd(child) {
        super.onChildAdd(child);

        if (child.index == null) {
            this.syncTabs();
        }
    }

    onChildRemove(child) {
        super.onChildRemove(child);

        this.syncTabs();
    }

    onFocusIn({ _target }) {
        const { activeIndex } = this.owner;

        // If user is tabbing in (as opposed to clicking a tab), focus the active tab
        if (_target?.matches('.b-tab:focus-visible') && !isNaN(activeIndex)) {
            this.tabs[activeIndex].focus();
        }
    }

    syncTabs() {
        const { tabs } = this;

        for (let i = 0, n = tabs.length; i < n; ++i) {
            tabs[i].index = i;
            tabs[i].isFirst = !i;
            tabs[i].isLast = i === n - 1;
        }
    }

    tabAt(index) {
        return this._items.find(isTab, index) || null;
    }

    //endregion

    // region drag-drop
    onChildMove() {
        // Ensure all tabs have the correct first/last CSS classes in sync
        this.syncTabs();
    }

    /**
     * Handle drop
     * @private
     */
    onDrop({ context }) {
        const
            { item, valid, oldIndex } = context,
            { owner } = this;

        super.onDrop(...arguments);

        if (valid && owner) {
            const
                { owner } = this,
                wasActive = item.active,
                index     = Array.from(item.element.parentElement.children).indexOf(item.element);

            // Sync the item order of the owning TabPanel
            owner.insert(owner.items[oldIndex], index);

            if (wasActive) {
                owner.layout.setActiveItem(index, oldIndex, { animation : false, silent : true });
                owner.activeTab = item.item;
            }
        }
    }
    //endregion
}

// Register this widget type with its Factory
TabBar.initClass();
