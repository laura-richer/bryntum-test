import GridFeatureManager from '../GridFeatureManager.js';
import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';
import TableExporter from '../../util/TableExporter.js';
import DateHelper from '../../../Core/helper/DateHelper.js';
import ObjectHelper from '../../../Core/helper/ObjectHelper.js';
import BrowserHelper from '../../../Core/helper/BrowserHelper.js';
import TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';
import VersionHelper from '../../../Core/helper/VersionHelper.js';
import WriteExcelFileProvider from './xlsproviders/WriteExcelFileProvider.js';

/**
 * @module Grid/feature/experimental/ExcelExporter
 */

/**
 * Object describing config param for `beforeExcelExport` and `beforeCSVExport` event.
 * @typedef {Object} ExportConfig
 * @property {Boolean} convertEmptyValueToEmptyString If this is true, exporter will convert all empty values to `''`
 * @property {String} dateFormat Defines how dates in a cell will be formatted
 * @property {Object} exporterConfig Configuration object for {@link #config-exporterClass exporter class}
 * @property {Grid.util.TableExporter} exporterClass Exporter class to use as a data provider.
 * @property {String} filename Name of the exported file
 * @property {Boolean|Object} [csv] Set to true to output as a CSV file, or as an object where you can specify delimiters.
 */

/**
 * A feature that allows exporting Grid data to Excel or CSV without involving the server. It uses
 * {@link Grid.util.TableExporter} class as data provider, 3rd party provider to generate XLS files, and
 * [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).
 *
 * ```
 * import WriteExcelFileProvider from '../../lib/Grid/feature/experimental/xlsproviders/WriteExcelFileProvider.js';
 *
 * new Grid({
 *     features : {
 *         excelExporter : {
 *             xlsProvider : WriteExcelFileProvider
 *         }
 *     }
 * });
 *
 * ### Implementing custom provider
 *
 * ```html
 * // Global scope
 * <script src="https://cdn.jsdelivr.net/npm/write-excel-file/bundle/write-excel-file.min.js"></script>
 * ```
 *
 * ```javascript
 * // importing from package
 * import writeXlsxFile from 'write-excel-file';
 *
 * const typeMap = { string : String, number : Number, date : Date };
 *
 * class MyXlsProvider {
 *     static write({ filename, columns, rows }) {
 *         columns.forEach(col => delete col.type);
 *         rows.forEach(row => row.forEach(cell => cell.type = typeMap[cell.type] || String));
 *
 *         globalThis.writeXlsxFile([columns, ...rows], {
 *             // write-excel-file uses amount of symbols as width, so we need to convert pixels to symbols
 *             columns    : columns.map(col => ({ ...col, width : Math.round(col.width / 10) })),
 *             fileName   : filename,
 *             dateFormat : 'yyyy-mm-dd'
 *         });
 *     }
 * }
 *
 * const grid = new Grid({
 *     features : {
 *         excelExporter : {
 *             xlsProvider : MyXlsProvider
 *         }
 *     }
 * })
 * ```
 *
 * Here is an example of how to add the feature:
 *
 * ```javascript
 * const grid = new Grid({
 *     features : {
 *         excelExporter : {
 *             // Choose the date format for date fields
 *             dateFormat : 'YYYY-MM-DD HH:mm',
 *
 *             exporterConfig : {
 *                 // Choose the columns to include in the exported file
 *                 columns : ['name', 'role'],
 *                 // Optional, export only selected rows
 *                 rows    : grid.selectedRecords
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * And how to call it:
 *
 * ```javascript
 * grid.features.excelExporter.export({
 *     filename       : 'Export',
 *     exporterConfig : {
 *         columns : [
 *             { text : 'First Name', field : 'firstName', width : 90 },
 *             { text : 'Age', field : 'age', width : 40 },
 *             { text : 'Starts', field : 'start', width : 140 },
 *             { text : 'Ends', field : 'finish', width : 140 }
 *         ]
 *     }
 * })
 * ```
 *
 * Exporting to CSV is done with the `csv` config:
 *
 * ```javascript
 * grid.features.excelExporter.export({
 *     filename : 'myfile',
 *     csv      : true
 * })
 * ```
 *
 * This feature is **disabled** by default.
 * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.
 *
 * {@note}This feature will not work properly when Store uses {@link Core.data.Store#config-lazyLoad}{/@note}
 * {@note}This class requires a 3rd party library to export to XLSX{/@note}
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Grid/exporttoexcel
 * @classtype excelExporter
 * @feature
 */
export default class ExcelExporter extends InstancePlugin {
    static $name = 'ExcelExporter';

    static configurable = {
        /**
         * Name of the exported file
         * @config {String} filename
         * @default
         */
        filename : null,

        /**
         * Defines how dates in a cell will be formatted
         * @config {String} dateFormat
         * @default
         */
        dateFormat : VersionHelper.checkVersion('core', '7.0', '>=') ? null : 'YYYY-MM-DD',

        /**
         * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.
         * @config {Grid.util.TableExporter}
         * @typings {typeof TableExporter}
         * @default
         */
        exporterClass : TableExporter,

        /**
         * Configuration object for {@link #config-exporterClass exporter class}.
         * @config {Object}
         */
        exporterConfig : null,

        /**
         * This hook allows to use 3rd party libraries to generate XLSX files. Until version 7.0 zipcelx library is
         * used. From version 7.0, the default will be {@link Grid/feature/experimental/xlsproviders/WriteExcelFileProvider}.
         * Provider must extend {@link Grid/feature/experimental/xlsproviders/XlsProviderBase} and implement static
         * {@link Grid/feature/experimental/xlsproviders/XlsProviderBase#function-write-static write} method.
         *
         * @config {Class}
         * @typings {typeof XlsProviderBase}
         */
        xlsProvider : VersionHelper.checkVersion('core', '7.0', '>=') ? WriteExcelFileProvider : null,

        /**
         * Allows configuring MIME type of the exported CSV file
         * @config {String}
         * @default
         * @internal
         */
        csvMimeType : 'text/csv',

        /**
         * Legacy way to generate XLS files was using [zipcelx library](https://www.npmjs.com/package/zipcelx)
         * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)
         *
         * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.
         * Reference to zipcelx library. If not provided, exporter will look in the global scope.
         * @config {Object}
         * @deprecated 6.1.0 Use {@link #config-xlsProvider} instead
         */
        zipcelx : null,

        /**
         * If this config is true, exporter will convert all empty values to ''. Empty values are:
         * * undefined, null, NaN
         * * Objects/class instances that do not have toString method defined and are stringified to [object Object]
         * * functions
         * @config {Boolean}
         */
        convertEmptyValueToEmptyString : true,

        /**
         * Set this config to `true` to export all {@link Grid.column.Column#config-exportable} columns including
         * {@link Grid.column.Column#config-hidden} columns as well.
         * @config {Boolean}
         * @default
         */
        exportAllColumns : false
    };

    processValue(value) {
        if (
            value === undefined ||
            value === null ||
            Number.isNaN(value) ||
            typeof value === 'function' ||
            (typeof value === 'object' && String(value) === '[object Object]')
        ) {
            return '';
        }
        return value;
    }

    generateExportData(config) {
        const
            me                = this,
            { rows, columns } = me.exporter.export(config.exporterConfig);

        return {
            rows : rows.map(row => {
                return row.map((value, index) => {
                    let type = columns[index]?.type || 'string';

                    if (type === 'object' || type === 'auto') {
                        type = 'string';
                    }

                    if (value instanceof Date) {
                        if (config.dateFormat) {
                            value = DateHelper.format(value, config.dateFormat);
                            type = 'string';
                        }
                        else {
                            // excel does not support timezones, to get same date we need to use create date in UTC
                            // https://gitlab.com/catamphetamine/write-excel-file/-/issues/79#note_1808783126
                            value = TimeZoneHelper.fromTimeZone(value, 0);
                            type = 'date';
                        }
                    }
                    else if (type === 'number' && typeof value === 'string') {
                        // replace leading non-digit symbols and parse the value to be a number
                        value = parseFloat(value.replace(/^\D*/, ''));
                    }

                    if (me.convertEmptyValueToEmptyString) {
                        value = me.processValue(value);
                    }
                    else if (type === 'string' && typeof value !== 'string') {
                        value = `${value}`;
                    }

                    return { value, type };
                });
            }),
            columns
        };
    }

    /**
     * Generate and download an Excel (.xlsx), or CSV file (.csv).
     * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.
     * @param {String} [config.filename] Name of the exported file
     * @param {String} [config.dateFormat] Defines how dates in a cell will be formatted
     * @param {Boolean|Object} [config.csv] Set to `true` to output as a CSV file, or as an object where you can specify
     * delimiters.
     * @param {String} [config.csv.columnDelimiter] The CSV delimiter to separate values on one line, defaults to `,`.
     * @param {String} [config.csv.lineDelimiter] The CSV delimiter to separate lines, defaults to `\n`.
     * @param {String[]|Object[]} [config.columns] An array of column configuration objects
     * @param {Core.data.Model[]} [config.rows] An array of records to export
     * @returns {Promise} Promise that resolves when the export is completed
     */
    async export(config = {}) {
        const
            me         = this,
            { client } = me,
            exporter   = me.xlsProvider?.write || me.zipcelx || globalThis.zipcelx;

        if (!exporter) {
            throw new Error('ExcelExporter: "xlsProvider" or "zipcelx" library is required');
        }

        if (me.disabled) {
            return;
        }

        config = ObjectHelper.assign({}, me.config, config);

        if (!config.filename) {
            config.filename = client.$$name;
        }

        const
            { filename }      = config,
            { rows, columns } = me.generateExportData(config);

        if (config.csv) {
            const
                columnDelimiter = config.csv.columnDelimiter || ',',
                lineDelimiter   = config.csv.lineDelimiter || '\n';

            /**
             * Fires on the owning Grid before CSV export starts. Return `false` to cancel the export.
             * @event beforeCSVExport
             * @preventable
             * @on-owner
             * @param {ExportConfig} config Export config
             * @param {Grid.column.Column[]} columns An array of columns to export
             * @param {Core.data.Model[]} rows An array of records to export
             * @param {String} lineDelimiter The CSV delimiter to separate lines
             * @param {String} columnDelimiter The CSV delimiter to separate values on one line
             */
            if (client.trigger('beforeCSVExport', { config, rows, columns, lineDelimiter, columnDelimiter }) !== false) {
                const
                    headers         = columns.map(col => this.processCsvValue(col.value)).join(columnDelimiter) + lineDelimiter,
                    text            = rows.map(rowValues => rowValues.map(obj => this.processCsvValue(obj.value)).join(`${columnDelimiter}`)).join(lineDelimiter),
                    // Adding BOM to let the reader (Excel) know this is a UTF-8 file
                    bom             = new Uint8Array([0xEF, 0xBB, 0xBF]),
                    blob            = new Blob([bom, headers + text], { type : me.csvMimeType });

                BrowserHelper.downloadBlob(blob, filename);
            }

            return Promise.resolve();
        }

        /**
         * Fires on the owning Grid before Excel export starts. Return `false` to cancel the export.
         * @event beforeExcelExport
         * @preventable
         * @on-owner
         * @param {ExportConfig} config Export config
         * @param {XLSColumn[]} columns An array of columns to export
         * @param {XLSCell[][]} rows An array of records to export
         */
        if (client.trigger('beforeExcelExport', { config, rows, columns }) !== false) {
            const params = {
                filename,
                columns,
                rows
            };

            // This is required to keep backward compatibility with zipcelx
            if (VersionHelper.checkVersion('core', '7.0', '<')) {
                // zipcelx uses only string columns
                params.sheet = {};

                params.sheet.data = [...rows.map(row => row.map((cell, index) => ({
                    ...cell,
                    type : columns[index]?.type === 'number' && typeof value !== 'string' ? 'number' : 'string'
                })))];
                params.sheet.cols = columns.map(col => ({
                    ...col,
                    type : 'string'
                }));
                params.sheet.data.unshift(params.sheet.cols);
            }

            return exporter(params);
        }

        return Promise.resolve();
    }

    processCsvValue(text = '') {
        return `"${String(text).replace(/"/g, '""')}"`;
    }

    construct(grid, config) {
        super.construct(grid, config);

        if (!this.zipcelx) {
            if (typeof zipcelx !== 'undefined') {
                this.zipcelx = globalThis.zipcelx;
            }
        }
    }

    get exporter() {
        const me = this;

        return me._exporter || (me._exporter = me.exporterClass.new({ target : me.client }, me.exporterConfig));
    }
}

GridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');
