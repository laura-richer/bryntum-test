import ResourceTimeRangesBase from '../../Scheduler/feature/base/ResourceTimeRangesBase.js';
import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';
import ArrayHelper from '../../Core/helper/ArrayHelper.js';
import DateHelper from '../../Core/helper/DateHelper.js';
import Store from '../../Core/data/Store.js';
import ResourceTickStore from '../../Scheduler/data/ResourceTickStore.js';
import TickEditor from '../widget/TickEditor.js';

/**
 * @module Scheduler/feature/TickCells
 */

/**
 * A feature allowing you to display values in the time axis cell for each row in a scheduler.
 *
 * This feature is **disabled** by default.
 *
 * {@inlineexample Scheduler/feature/TickCells.js}
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *      features : {
 *          tickCells : {
 *              resourceTicksData : [
 *                  {
 *                      id           : 1,
 *                      startDate    : '2024-06-03',
 *                      value        : 20,
 *                      resourceId   : 1,
 *                      durationUnit : 'day',
 *                      duration     : 1
 *                  }
 *              ],
 *              tickRenderer({ value = 0 }) {
 *                  const
 *                      hours = Math.floor(value),
 *                      hourFraction =  60 * (value - hours);
 *                  return value ? `${hours}:${String(hourFraction).padStart(2, '0')}` : '';
 *              }
 *          }
 *      }
 * });
 * ```
 *
 * @classtype tickCells
 * @extends Scheduler/feature/base/ResourceTimeRangesBase
 * @internal
 */
export default class TickCells extends ResourceTimeRangesBase {
    static $name = 'TickCells';

    static configurable = {
        /**
         * Store that holds resource ticks - instances of {@link Scheduler.model.ResourceTickModel}.
         * A store will be automatically created if none is specified.
         * @config {ResourceTickStoreConfig|Scheduler.data.ResourceTickStore}
         * @category Models & Stores
         */
        resourceTickStore : {},

        /**
         * Used to configure tick entity name
         *
         * @config {String}
         * @default
         */
        entityName : 'tickCell',

        /**
         * Used to configure tick cell wrapper class
         *
         * @config {String}
         * @default
         */
        rangeCls : 'b-sch-tick-cell',

        /**
         * Used to configure tick cell class
         *
         * @config {String}
         * @default
         */
        cls : '',

        /**
         * The initial data, to fill the {@link #config-resourceTickStore} with.
         * Should be an array of {@link Scheduler.model.ResourceTickModel} or configuration objects.
         *
         * @config {ResourceTickModelConfig[]|Scheduler.model.ResourceTickModel[]}
         * @category Legacy inline data
         */
        resourceTicksData : null,

        /**
         * Renderer function. Should return textual content or a {@link Core.helper.DomHelper#typedef-DomConfig} object.
         *
         * ```javascript
         * new Scheduler({
         *     features : {
         *         tickCells : {
         *             tickRenderer : resourceTick => {
         *                  const
         *                      hours = Math.floor(resourceTick.value),
         *                      hourFraction = 60 * (value - hours);
         *                  return value ? `${hours}:${String(hourFraction).padStart(2, '0')}` : '';
         *             }
         *         }
         *     }
         * });
         * ```
         *
         * @config {Function} tickRenderer
         * @param {Scheduler.model.ResourceTickModel} resourceTick Tick value to render
         * @returns {String|DomConfig} Either textual content or a DomConfig object
         */

        /**
         * Config used to show or not the tick editor on cell double click.
         *
         * @config {Boolean}
         * @default true
         */
        showEditor : true
    };

    changeResourceTickStore(store) {
        return Store.getStore(store, ResourceTickStore);
    }

    updateResourceTickStore(store, oldStore) {
        this.detachStore(oldStore);

        store = Store.getStore(store, ResourceTickStore);

        if (!store.id) {
            store.id = 'resourceTicks';
        }

        // For faster lookup during rendering
        store.storage.addIndex({
            property : 'indexKey'
        });

        this.attachStore(store);
    }

    // Detach a store, stop relaying its change events
    detachStore(store) {
        store && this.detachListeners(store.$$name);
    }

    // Attach to a store, relaying its change events
    attachStore(store) {
        if (this.syncDataOnLoad) {
            store.syncDataOnLoad = this.syncDataOnLoad;
        }

        store.ion({
            name    : store.$$name,
            change  : 'internalOnStoreChange',
            thisObj : this
        });
    }

    updateResourceTicksData(ticks) {
        this.resourceTickStore.data = ticks;
    }

    updateClient(client) {
        client.ion({
            scheduleDblClick : 'onTimeAxisCellDblClick',
            thisObj          : this
        });
    }

    //region Rendering

    getEventsToRender(resource, events) {
        const
            { client }   = this,
            { timeAxis } = client;

        if (!this.disabled) {
            const
                firstTick = Math.floor(timeAxis.getTickFromDate(timeAxis.startDate)),
                lastTick  = Math.ceil(timeAxis.getTickFromDate(timeAxis.endDate));

            for (let tick = firstTick; tick <= lastTick; tick++) {
                const
                    startDate  = timeAxis.getDateFromTick(tick),
                    tickRecord = this.getResourceTickRecord(resource, startDate);

                tickRecord && events.push(tickRecord);
            }
        }

        return events;
    }

    shouldInclude({ isTickCell }) {
        return isTickCell;
    }

    generateElementId(record) {
        return `tick-cell-${record.id}`;
    }

    getElementFromResourceTimeRangeRecord(record) {
        return this.canvas.syncIdMap[`tick-cell-${record.domId}`];
    }

    //endregion

    //region Data

    tickRenderer(resourceTick) {
        return resourceTick.value;
    }

    onEventDataGenerated(renderData) {
        const
            me                             = this,
            { client }                     = me,
            { eventRecord : resourceTick } = renderData;

        if (me.shouldInclude(resourceTick)) {
            if (client.isVertical) {
                renderData.width = client.getResourceWidth(renderData.resourceRecord);
            }
            else {
                renderData.top = 0;
            }

            // Flag that we should fill entire row/col
            renderData.fillSize = true;

            renderData.wrapperCls[me.rangeCls] = 1;
            renderData.wrapperCls['b-sch-style-none'] = 0;
            renderData.wrapperCls['b-sch-color-none'] = 0;
            renderData.cls[me.cls] = 1;

            // Used to render to the correct canvas
            renderData.entityName = me.entityName;

            // Event data for DOMSync comparison
            renderData.eventId = me.generateElementId(resourceTick);

            const rendererResult = me.tickRenderer(resourceTick);

            if (client.isVertical && typeof rendererResult !== 'object') {
                renderData.eventContent = {
                    text : rendererResult
                };
            }

            renderData.children = ArrayHelper.asArray(rendererResult);
        }
    }

    internalOnStoreChange(event) {
        this.client.refresh();

        /**
         * Fired when data store changes.
         *
         * @event change
         * @param {Scheduler.feature.TickCells} source This project
         * @param {Core.data.Store} store Affected store
         * @param {'remove'|'removeAll'|'add'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
         * Name of action which triggered the change. May be one of the options listed above.
         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
         */
        return this.trigger('change', { store : event.source, ...event, source : this });
    }

    getResourceTickRecord(resource, startDate) {
        return this.resourceTickStore.storage.getBy('indexKey', `${startDate.getTime()}-${resource.id}`);
    }

    //endregion

    //region Editing

    editTickCell(resourceRecord, tickStartDate) {
        const
            me         = this,
            { client } = me;

        let tickRecord = me.getResourceTickRecord(resourceRecord, tickStartDate);

        // No data for the tick, create it
        if (!tickRecord) {
            [tickRecord] = me.resourceTickStore.add({
                resourceId   : resourceRecord.id,
                startDate    : tickStartDate,
                duration     : client.timeAxis.increment,
                durationUnit : client.timeAxis.unit
            });

            // Since rendering is sync, the element for this record will be available below
        }

        const target = me.getElementFromResourceTimeRangeRecord(tickRecord);

        me.editor = new TickEditor({
            appendTo : me.canvas,
            owner    : me
        });

        me.editor.startEdit({
            target,
            record : tickRecord,
            field  : 'value'
        });
    }

    getNextDate(date) {
        return this.getAdjacentDate(date);
    }

    getPrevDate(date) {
        return this.getAdjacentDate(date, false);
    }

    getAdjacentDate(date, next = true) {
        const
            { timeAxis } = this.client,
            adjacentDate = DateHelper.add(date, timeAxis.increment * (next ? 1 : -1), timeAxis.unit);

        if (adjacentDate >= timeAxis.startDate && adjacentDate < timeAxis.endDate) {
            return adjacentDate;
        }

        return null;
    }

    getNextResource(resource) {
        return this.getAdjacentResource(resource);
    }

    getPrevResource(resource) {
        return this.getAdjacentResource(resource, false);
    }

    getAdjacentResource(resource, next = true) {
        resource = this.client.store.getById(resource);

        return this.client.store[next ? 'getNext' : 'getPrev'](resource);
    }

    onTimeAxisCellDblClick({ resourceRecord, tickStartDate }) {
        if (this.showEditor) {
            this.editTickCell(resourceRecord, tickStartDate);
        }
    }

    //endregion
}

GridFeatureManager.registerFeature(TickCells, false, ['Scheduler', 'SchedulerPro', 'Gantt']);
