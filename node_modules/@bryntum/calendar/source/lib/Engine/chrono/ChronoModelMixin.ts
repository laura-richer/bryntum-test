import { AnyConstructor, Mixin } from "../../ChronoGraph/class/BetterMixin.js"
import { Entity } from "../../ChronoGraph/replica/Entity.js"
import { ModelId } from "../quark/Types.js"
import Model from "../../Core/data/Model.js"
import ObjectHelper from "../../Core/helper/ObjectHelper.js"
import { CalculationIterator } from "../../ChronoGraph/primitives/Calculation.js"
import { ProposedOrPrevious } from "../../ChronoGraph/chrono/Effect.js"
import {
    ChronoModelReferenceBucketFieldIdentifier,
    ChronoModelReferenceFieldIdentifier,
    ModelReferenceField
} from "./ModelFieldAtom.js"
import { CalculatedValueGen, Identifier } from "../../ChronoGraph/chrono/Identifier.js"
import { Replica } from "../../ChronoGraph/replica/Replica.js"

/**
 * This is a base mixin, which mixes together the ChronoGraph's [Entity](https://bryntum.com/products/gantt/docs/engine/modules/_lib_chronograph_replica_entity_.html)
 * and the Bryntum Core [Model](https://bryntum.com/products/grid/docs/api/Core/data/Model)
 *
 * It is used as a very base mixin for all other entities in the project.
 */
export class ChronoModelMixin extends Mixin(
    [ Entity, Model ],
    (base : AnyConstructor<Model & Entity, typeof Model & typeof Entity>) => {

    const superProto : InstanceType<typeof base> = base.prototype


    class ChronoModelMixin extends base {
        // This is a marker for Models which have the Engine API available.
        get isEntity () : boolean {
            return true
        }


        /**
         * Calculation function that simply returns current ([[ProposedOrPrevious|proposed or previous]]) value of
         * an identifier.
         */
        * userProvidedValue () : CalculationIterator<any> {
            return yield ProposedOrPrevious
        }


        copy (newId : ModelId = null, deep = null) : this {
            const copy = superProto.copy.call(this, newId, deep)
            const { creatingOccurrence } = deep ?? {}

            // If deep is everything but object - use default behavior, which is to invoke accessors
            // If deep is an object, check if it has certain field disabled
            if ((ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers) || !ObjectHelper.isObject(deep)) {
                this.forEachFieldIdentifier((identifier, fieldName, field) => {
                    if (
                        !field.lazy &&
                        // @ts-ignore
                        this.getFieldDefinition(fieldName)?.type !== 'store' && (
                            // Do not copy buckets for non-occurrences (for example task.incomingDeps, since it contains
                            // records related to the original, not the copy)
                            (!creatingOccurrence && !(identifier instanceof ChronoModelReferenceBucketFieldIdentifier))
                            // Only include buckets and references for occurrences, they will not be part of graph and
                            // will handle their own dates etc
                            || (creatingOccurrence && (identifier instanceof ChronoModelReferenceBucketFieldIdentifier
                                || identifier instanceof ChronoModelReferenceFieldIdentifier))
                        )
                    ) {
                        copy[fieldName] = this[fieldName]
                    }
                })
            }

            return copy
        }


        _data           : object


        applyValue (useProp : boolean, key : string, value : any, skipAccessors : boolean, field : any) {
            // key is the dataSource, we need to check for the field name instead
            const chronoField   = this.$entity.getField(field?.name || key)

            if (chronoField) useProp = true
            if (skipAccessors) useProp = false

            superProto.applyValue.call(this, useProp, useProp ? field?.name ?? key : key, value, skipAccessors, field)
        }


        get isInActiveTransaction () : boolean {
            // Might not have joined graph when using delayed calculation
            const activeTransaction     = this.graph?.activeTransaction

            return Boolean(activeTransaction?.getLatestEntryFor(this.$$))
        }


        get $entityName () : string {
            const className     = this.constructor.name || this.$entity.name

            const id            = this.internalId

            return `${className}${ id != null ? '-' + String(id) : '' }`
        }

        // Field updates of which are tracked and relayed to special identifiers on the graph
        fieldChangeTrackers : Map<String, Identifier>

        trackFieldChanges (fieldName : string) : Identifier {
            if (!this.fieldChangeTrackers) {
                this.fieldChangeTrackers = new Map()
            }

            const trackers = this.fieldChangeTrackers

            let identifier = trackers.get(fieldName)

            if (!identifier) {
                // make a special identifier for tracking
                identifier = this.graph.addIdentifier(CalculatedValueGen.new({
                    context : this,
                    * calculation() {
                        // return the field value
                        return this[fieldName]
                    },
                }))

                trackers.set(fieldName, identifier)
            }

            return identifier
        }

        untrackFieldChanges (fieldName : string) {
            const graph = this.graph

            const trackers = this.fieldChangeTrackers

            if (trackers) {
                if (fieldName) {
                    const identifier = trackers.get(fieldName)

                    if (identifier && graph) {
                        graph.removeIdentifier(identifier)
                    }

                    trackers.delete(fieldName)
                }
                else {
                    if (graph) {
                        for (const [, identifier] of trackers) {
                            graph.removeIdentifier(identifier)
                        }
                    }

                    trackers.clear()
                }

                if (!trackers.size) {
                    this.fieldChangeTrackers = undefined
                }
            }
        }

        enterGraph (replica : Replica) {
            super.enterGraph(replica)

            if (this.fieldChangeTrackers) {
                for (const identifier of this.fieldChangeTrackers.values()) {
                    replica.addIdentifier(identifier)
                }
            }
        }

        leaveGraph (replica : Replica) {
            super.leaveGraph(replica)

            if (this.fieldChangeTrackers) {
                for (const identifier of this.fieldChangeTrackers.values()) {
                    replica.removeIdentifier(identifier)
                }
            }
        }

        unlink () {
            // Might not have entered replica yet when using delayed calculation
            if (this.graph) {
                const { activeTransaction } = this.graph
                const { $ }                 = this
                const keys                  = Object.keys($)

                // Write current values to identifier.DATA, to have correct value entering new replica later
                for (let i = 0; i < keys.length; i++) {
                    const key           = keys[ i ]
                    const identifier    = $[ key ]

                    const entry         = activeTransaction.getLatestStableOrProposedEntryFor(identifier)

                    if (entry) {
                        let value       = entry.getValue()

                        if (value === undefined) value = entry.proposedValue

                        if (value !== undefined) {
                            identifier.DATA = identifier.field instanceof ModelReferenceField
                                ? value?.id ?? value
                                : value
                        }
                    }
                }

                // Cut the link, to enable joining another replica
                this.graph = null
            }
        }
    }

    return ChronoModelMixin
}){}
