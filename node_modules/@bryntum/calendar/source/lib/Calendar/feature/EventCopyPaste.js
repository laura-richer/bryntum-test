import DateHelper from '../../Core/helper/DateHelper.js';
import EventHelper from '../../Core/helper/EventHelper.js';
import SchedulerEventCopyPaste from '../../Scheduler/feature/EventCopyPaste.js';
import CalendarFeature from '../feature/CalendarFeature.js';

/**
 * @module Calendar/feature/EventCopyPaste
 */

/**
 * Allow using [Ctrl/CMD + C/X/V] to copy/cut-and-paste events.
 *
 * This feature also adds entries to the {@link Calendar/feature/EventMenu} for copying & cutting (see example below
 * for how to configure) and to the {@link Calendar/feature/ScheduleMenu} for pasting.
 *
 * You can configure how a newly pasted record is named using {@link #config-generateNewName}.
 *
 * {@inlineexample Calendar/feature/EventCopyPaste.js}
 *
 * This feature is **enabled** by default.
 *
 * ## Customize menu items
 *
 * See {@link Calendar/feature/EventMenu} and {@link Calendar/feature/ScheduleMenu} for more info on customizing the
 * menu items supplied by the feature. This snippet illustrates the concept:
 *
 * ```javascript
 * // Custom copy text + remove cut option from event menu:
 * const calendar = new Calendar({
 *     features : {
 *         eventMenu : {
 *             items : {
 *                 copyEvent : {
 *                     text : 'Copy booking'
 *                 },
 *                 cutEvent  : false
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * ## Keyboard shortcuts
 *
 * The feature has the following default keyboard shortcuts:
 *
 * | Keys       | Action   | Action description                             |
 * |------------|----------|------------------------------------------------|
 * | `Ctrl`+`C` | *copy*   | Copies selected event into the clipboard.      |
 * | `Ctrl`+`X` | *cut*    | Cuts out selected event into the clipboard.    |
 * | `Ctrl`+`V` | *paste*  | Insert copied or cut event from the clipboard. |
 *
 * <div class="note">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>
 * is the equivalent to <code>Option</code> for Mac users</div>
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [our guide](#Scheduler/guides/customization/keymap.md).
 *
 * ## Native/shared clipboard
 *
 * If you have multiple Calendars (or other Bryntum products) on the same page, they will share clipboard. This makes
 * it possible to copy and paste between different Calendar instances. It is also possible to use the native Clipboard
 * API if it is available and if you set {@link #config-useNativeClipboard} to `true`.
 *
 * Regardless of native clipboard availability, copy-pasting "outside" of the current Calendar instance will convert
 * the copied events to a string. When pasting, the string will then be parsed back into events. In case of usage of the
 * native Clipboard API, this means it is possible to copy and paste events between completely different applications.
 *
 * To configure the fields that is converted and parsed from the copied string value, please see the
 * {@link #config-eventToStringFields} config.
 *
 * @extends Scheduler/feature/EventCopyPaste
 * @classtype eventCopyPaste
 * @feature
 *
 * @typings Scheduler.feature.EventCopyPaste -> Scheduler.feature.SchedulerEventCopyPaste
 */

export default class EventCopyPaste extends SchedulerEventCopyPaste {
    static $name = 'EventCopyPaste';
    static type = 'eventCopyPaste';

    // There's no merging of pluginConfigs
    static get pluginConfig() {
        const config = {};

        for (const prop in super.pluginConfig) {
            config[prop] = [...super.pluginConfig[prop]];
        }

        config.assign.push('beforeListRenderRow');
        return config;
    };

    /**
     * @hideconfigs copyPasteAction
     */

    static configurable = {
        allowNoAssignments : true
    };

    constructor(config) {
        super(config.client, config);

        // For year-view interaction
        this.client.ion({
            cellOverFlowClick : 'onScheduleClick',
            thisObj           : this
        });

        // We update the cellClickedContext on focus move because day cells are navigable.
        EventHelper.on({
            element   : this.client.element,
            focusmove : 'onFocusMove',
            thisObj   : this
        });
    }

    // When we navigate to a new cell, we need to update the cellClickedContext
    onFocusMove(e) {
        const
            me          = this,
            { client }  = me,
            { _target } = e,
            date        = client.getDateFromDomEvent(_target);

        if (date) {
            const eventRecord = client.getEventRecord(_target.closest('[class*=-event-wrap]'));

            // If focus was moved to an event, cache its start time so that pasting
            // Using keyboard paste will paste at the same time.
            if (eventRecord) {
                me.targetTime = eventRecord.startDate;
            }
            // If focus moved to a cell, use the last event's start time
            else if (me.targetTime) {
                DateHelper.copyTimeValues(date, me.targetTime);
            }

            me._cellClickedContext = {
                date,
                domEvent       : e,
                source         : client.activeView,
                view           : client.activeView,
                resourceRecord : me.client.resolveResourceRecord(_target)
            };
        }
        else {
            me._cellClickedContext - null;
        }
    }

    populateEventMenu(event) {
        const { client } = this;

        this.fixEventData(event);
        super.populateEventMenu(event);

        // In List and Agenda this adds a paste option on the event context menu
        if (client.activeView.isEventList && !client.readOnly && this.hasClipboardData() !== false) {
            event.items.pasteEvent = {
                text        : 'L{pasteEvent}',
                localeClass : this,
                icon        : 'b-icon b-icon-paste',
                disabled    : client.resourceStore.count === 0 || event.resourceRecord.readOnly,
                weight      : 110,
                onItem      : ({ eventRecord }) => {
                    this.pasteEvents(eventRecord.startDate);
                }
            };
        }
    }

    onScheduleMenuPasteClick({ date, resourceRecord, domEvent, feature }) {
        const
            { activeView, constructor } = this.client,
            contextView = constructor.fromElement(feature.menuContext.targetElement, w => w.isCalendarMixin);

        // Make sure the resource is only available when pasting via ScheduleMenu from certain views
        // In other views We want pasteEvents to decide what resource(s) should be assigned to the pasted events
        if (!activeView.isResourceView && !activeView.isDayResourceView) {
            resourceRecord = null;
        }

        // Pasting into the allDay bar, should set the allDay flag
        if (contextView?.parent && contextView.parent.allDayEvents === contextView) {
            this._isPastingIntoAllDay = true;
        }

        this.pasteEvents(date, resourceRecord);
    }

    onEventDataGenerated(renderData) {
        this.fixEventData(renderData);
        super.onEventDataGenerated(renderData);
    }

    fixEventData(renderData) {
        if (!renderData.assignmentRecord) {
            const { eventRecord, resourceRecord } = renderData;
            // Adds missing assignmentRecord value to a few event data objects
            renderData.assignmentRecord = (resourceRecord && eventRecord.assignments.find(a => a.eventId === eventRecord.id && a.resourceId === resourceRecord.id)) ?? eventRecord;
        }
    }

    // Overridden to always provide events so to be able to copy all the event assignments
    copyEvents(records, isCut) {
        if (records?.[0].isAssignmentModel) {
            records = records.map(r => r.event);
        }
        return super.copyEvents(records, isCut);
    }

    pasteEvents(date, resourceRecord) {
        const
            { _cellClickedContext }               = this,
            { isResourceView, isDayResourceView } = this.client.activeView;

        if (date) {
            this.targetTime = date;
        }

        // If keyboard paste on a resource (only possible in the ResourceView's) provide resource to the
        // original pasteEvents to tell it to ignore the copied event's assignments
        if (!date && !resourceRecord && _cellClickedContext && (isResourceView || isDayResourceView)) {
            return super.pasteEvents(_cellClickedContext.date, _cellClickedContext.resourceRecord);
        }

        // Must pass the arguments as the initial call
        return super.pasteEvents(...arguments);
    }

    cloneData({ data, isPaste }) {
        const cloned = super.cloneData({ data, isPaste });

        // Re-target all assignment copies to the event copies
        cloned.assignmentRecords = data.assignmentRecords.map(a => {
            const
                copy          = a.copy(),
                originalEvent = data.eventRecords.find(r => r.id === copy.eventId);

            copy.event = cloned.eventRecords.find(r => r.originalInternalId === originalEvent.internalId);

            return copy;
        });

        cloned.eventRecords?.forEach(e => delete e.meta.originalResourceId);

        if (isPaste && this._isPastingIntoAllDay) {
            cloned.eventRecords?.forEach(e => e.allDay = true);
            this._isPastingIntoAllDay = false;
        }

        return cloned;
    }

    refreshClient() {
        const { activeView } = this.client;

        this.client.refresh();

        if (activeView._overflowPopup?.isVisible) {
            activeView._overflowPopup.refresh();
        }

        // Shouldn't be needed (considering we call refresh on the Calendar above) but it is
        if (activeView.isResourceView) {
            activeView.eachView(view => view.refresh());
        }
    }

    beforeListRenderRow({ row, record }) {
        row.cls['b-cut-item'] = record.assignments.some(assignment => assignment.meta.isCut);
    }
}

// Register this feature type with its Factory
CalendarFeature.register(EventCopyPaste.type, EventCopyPaste);
