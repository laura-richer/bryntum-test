import { Identifier } from '../../../../ChronoGraph/chrono/Identifier.js'
import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/BetterMixin.js'
import { CalculationIterator } from "../../../../ChronoGraph/primitives/Calculation.js"
import { calculate } from '../../../../ChronoGraph/replica/Entity.js'
import { isAtomicValue } from '../../../../ChronoGraph/util/Helpers.js'
import { DateInterval } from '../../../scheduling/DateInterval.js'
import { DependencyType, Direction, Duration, TimeUnit } from '../../../scheduling/Types.js'
import { BaseCalendarMixin } from '../scheduler_basic/BaseCalendarMixin.js'
import { ConstrainedScheduleMixin } from "./ConstrainedScheduleMixin.js"
import { ConstrainedByDependenciesEventMixin } from "./ConstrainedByDependenciesEventMixin.js"
import { SchedulerProProjectMixin } from "./SchedulerProProjectMixin.js"


//---------------------------------------------------------------------------------------------------------------------
export class ConstrainedByDependenciesEventScheduleMixin extends Mixin(
    [ ConstrainedScheduleMixin ],
    (base : AnyConstructor<ConstrainedScheduleMixin, typeof ConstrainedScheduleMixin>) => {

    const superProto : InstanceType<typeof base> = base.prototype


    class ConstrainedByDependenciesEventScheduleMixin extends base {
        event : ConstrainedByDependenciesEventMixin

        /**
         * The method defines whether the provided dependency (called pushing dependency)
         * should constrain the successor/predecessor (in forward/backward direction) or not.
         * If the method returns `true` the dependency constrains the event being pushed and does not do that when `false` returned.
         * By default the method returns `true` if the dependency is [[SchedulerProDependencyMixin.active|active]]
         * and if this event is [[inactive|active]] (or both the pushing event and the event being pushed are [[inactive]]).
         *
         * This is used when calculating [[startDateConstraintIntervals]].
         * @param dependency Dependency to consider.
         * @returns `true` if the dependency should push, `false` if not.
         */
        * shouldPushingDepAffectScheduling (dependency : InstanceType<this[ 'project' ][ 'dependencyModelClass' ]>) : CalculationIterator<boolean> {
            if (
                this.direction === Direction.Forward
                && !(yield* this.event.shouldPredecessorAffectScheduling(dependency))
                ||
                this.direction === Direction.Backward
                && !(yield* this.event.shouldSuccessorAffectScheduling(dependency))
            ) {
                // early exit if the hooks on event said the pushing dependency should be ignored
                return false
            }

            const pushingEvent : ConstrainedByDependenciesEventMixin = yield this.pickPushingEventIdentifier(dependency)

            // ignore missing from events and inactive dependencies
            return pushingEvent && !isAtomicValue(pushingEvent) && (yield dependency.$.active)
                // ignore inactive predecessor (unless we both are inactive)
                && (!(yield pushingEvent.$.inactive) || (yield this.event.$.inactive))
        }


        pickPushingDepsIdentifier (event : this[ 'event' ]) : Identifier {
            if (this.direction === Direction.Forward) {
                return event.$.incomingDeps
            }
            else if (this.direction === Direction.Backward) {
                return event.$.outgoingDeps
            }
            else {
                throw new Error("Should not be here")
            }
        }


        pickPushingEventIdentifier (dependency : InstanceType<this[ 'project' ][ 'dependencyModelClass' ]>) : Identifier {
            if (this.direction === Direction.Forward) {
                return dependency.$.fromEvent
            }
            else if (this.direction === Direction.Backward) {
                return dependency.$.toEvent
            }
            else {
                throw new Error("Should not be here")
            }
        }


        * pickPushingStartDateIdentifier (pushingEvent : ConstrainedByDependenciesEventMixin) : CalculationIterator<Identifier> {
            return this.pick(pushingEvent).$.startDate
        }


        * pickPushingEndDateIdentifier (pushingEvent : ConstrainedByDependenciesEventMixin) : CalculationIterator<Identifier> {
            return this.pick(pushingEvent).$.endDate
        }


        // need to have at least one "entity" decorator in the class, otherwise the entity infrastructure won't be setup
        @calculate('startDateConstraintIntervals')
        * calculateStartDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            const intervals : DateInterval[]            = yield* superProto.calculateStartDateConstraintIntervals.call(this)

            const project : SchedulerProProjectMixin    = this.getProject()
            const dependencyConstraintIntervalClass     = project.dependencyConstraintIntervalClass

            const pushingDeps : Set<InstanceType<this[ 'project' ][ 'dependencyModelClass' ]>> = yield this.pickPushingDepsIdentifier(this.event)

            for (const pushingDep of pushingDeps) {
                // ignore missing from events and inactive predecessors/dependencies
                if (!(yield* this.shouldPushingDepAffectScheduling(pushingDep))) continue

                const pushingEvent : ConstrainedByDependenciesEventMixin = yield this.pickPushingEventIdentifier(pushingDep)
                // treat the event as manually scheduled if the field is true or the event is started
                // and we should schedule started events as manually scheduled
                const manuallyScheduled : boolean       = yield* pushingEvent.isManuallyScheduled()
                const pushingEventDirection : Direction = (yield this.event.$.effectiveDirection).direction

                let pushingDate : Date

                switch (yield pushingDep.$.type) {
                    case DependencyType.StartToEnd:
                        if (this.direction === Direction.Backward) {
                            pushingDate     = manuallyScheduled && pushingEventDirection === this.direction
                                ? yield pushingEvent.$.endDate
                                : yield (yield* this.pickPushingEndDateIdentifier(pushingEvent))
                        }
                        break

                    case DependencyType.EndToStart:
                        if (this.direction === Direction.Forward) {
                            pushingDate     = manuallyScheduled && pushingEventDirection === this.direction
                                ? yield pushingEvent.$.endDate
                                : yield (yield* this.pickPushingEndDateIdentifier(pushingEvent))
                        }
                        break

                    case DependencyType.StartToStart:
                        pushingDate     = manuallyScheduled && pushingEventDirection === this.direction
                            ? yield pushingEvent.$.startDate
                            : yield (yield* this.pickPushingStartDateIdentifier(pushingEvent))
                        break
                }

                if (pushingDate) {
                    const lag : Duration                = yield pushingDep.$.lag
                    const lagUnit : TimeUnit            = yield pushingDep.$.lagUnit
                    const calendar : BaseCalendarMixin  = project.isElapsedDurationUnit(lagUnit) ? project.defaultCalendar : (yield pushingDep.$.calendar)

                    // this "subscribes" on the calendar's `version` field (which is incremented
                    // every time when the intervals of the calendar changes)
                    yield calendar.$.version

                    const interval : DateInterval       = this.direction === Direction.Forward
                        ?
                            dependencyConstraintIntervalClass.new({
                                owner       : pushingDep,
                                startDate   : lag !== 0
                                    ?
                                        calendar.calculateEndDate(
                                            pushingDate,
                                            yield* pushingDep.convertLagGen(lag, lagUnit, TimeUnit.Millisecond)
                                        )
                                    :
                                        pushingDate,
                                endDate     : null
                            })
                        :
                            dependencyConstraintIntervalClass.new({
                                owner       : pushingDep,
                                startDate   : null,
                                endDate     : lag !== 0
                                    ?
                                        // Skip non-working time forward to constrain the event as late as possible
                                        // (could affect if the event and successor use different calendars)
                                        calendar.skipNonWorkingTime(calendar.calculateStartDate(
                                            pushingDate,
                                            yield* pushingDep.convertLagGen(lag, lagUnit, TimeUnit.Millisecond)
                                        )) as Date
                                    :
                                        pushingDate
                            })

                    intervals.unshift(interval)
                }
            }

            return intervals
        }


        * calculateEndDateConstraintIntervals () : CalculationIterator<DateInterval[]> {
            const intervals : DateInterval[]            = yield* superProto.calculateEndDateConstraintIntervals.call(this)

            const project : SchedulerProProjectMixin    = this.getProject()
            const dependencyConstraintIntervalClass     = project.dependencyConstraintIntervalClass

            const pushingDeps : Set<InstanceType<this[ 'project' ][ 'dependencyModelClass' ]>> = yield this.pickPushingDepsIdentifier(this.event)

            for (const pushingDep of pushingDeps) {
                // ignore missing from events and inactive dependencies
                if (!(yield* this.shouldPushingDepAffectScheduling(pushingDep))) continue

                const pushingEvent : ConstrainedByDependenciesEventMixin = yield this.pickPushingEventIdentifier(pushingDep)
                const manuallyScheduled : boolean       = yield* pushingEvent.isManuallyScheduled()
                const pushingEventDirection : Direction = (yield this.event.$.effectiveDirection).direction

                let pushingDate : Date

                switch (yield pushingDep.$.type) {
                    case DependencyType.EndToEnd:
                        pushingDate                 = manuallyScheduled && pushingEventDirection === this.direction
                            ? yield pushingEvent.$.endDate
                            : yield (yield* this.pickPushingEndDateIdentifier(pushingEvent))
                        break

                    case DependencyType.StartToEnd:
                        if (this.direction === Direction.Forward) {
                            pushingDate                 = manuallyScheduled && pushingEventDirection === this.direction
                                ? yield pushingEvent.$.startDate
                                : yield (yield* this.pickPushingStartDateIdentifier(pushingEvent))
                        }
                        break

                    case DependencyType.EndToStart:
                        if (this.direction === Direction.Backward) {
                            pushingDate                 = manuallyScheduled && pushingEventDirection === this.direction
                                ? yield pushingEvent.$.startDate
                                : yield (yield* this.pickPushingStartDateIdentifier(pushingEvent))
                        }
                        break
                }

                if (pushingDate) {
                    const lag : Duration                = yield pushingDep.$.lag
                    const lagUnit : TimeUnit            = yield pushingDep.$.lagUnit
                    const calendar : BaseCalendarMixin  = project.isElapsedDurationUnit(lagUnit) ? project.defaultCalendar : (yield pushingDep.$.calendar)

                    // this "subscribes" on the calendar's `version` field (which is incremented
                    // every time when the intervals of the calendar changes)
                    yield calendar.$.version

                    const interval : DateInterval       = this.direction === Direction.Forward
                        ?
                            dependencyConstraintIntervalClass.new({
                                owner       : pushingDep,
                                startDate   : lag !== 0
                                    ?
                                        calendar.calculateEndDate(
                                            pushingDate,
                                            yield* pushingDep.convertLagGen(lag, lagUnit, TimeUnit.Millisecond)
                                        )
                                    :
                                        pushingDate,
                                endDate     : null
                            })
                        :
                            dependencyConstraintIntervalClass.new({
                                owner       : pushingDep,
                                startDate   : null,
                                endDate     : lag !== 0
                                    ?
                                        // Skip non-working time forward to constrain the event as late as possible
                                        // (could affect if the event and successor use different calendars)
                                        calendar.skipNonWorkingTime(calendar.calculateStartDate(
                                            pushingDate,
                                            yield* pushingDep.convertLagGen(lag, lagUnit, TimeUnit.Millisecond)
                                        )) as Date
                                    :
                                        pushingDate
                            })

                    intervals.unshift(interval)
                }
            }

            return intervals
        }
    }

    return ConstrainedByDependenciesEventScheduleMixin
}){}