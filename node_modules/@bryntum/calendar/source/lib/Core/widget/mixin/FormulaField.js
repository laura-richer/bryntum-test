import CollectionFilter from '../../util/CollectionFilter.js';
import Panel from '../Panel.js';
import '../layout/Fit.js';
import '../List.js';

/**
 * @module Core/widget/mixin/FormulaField
 */

const
    returnTrue  = () => true,
    fieldSorter = (a, b) => a.text.localeCompare(b.text);

/**
 * A mixin to add the {@link #config-dataField} config to {@link Core.widget.TextField}.
 * @mixin
 */
export default Target => class FormulaField extends Target {
    static $name = 'FormulaField';

    static configurable = {
        /**
         * A {@link Core.data.field.DataField} which describes a field of a {@link Core.data.Model}
         * that we are editing.
         *
         * This is used to find {@link Core.data.field.DataField#config-formulaProviders}
         * which the field may support.
         *
         * ```javascript
         * items : [{
         *     type      : 'textfield',
         *     dataField : myStore.modelClass.getFieldDefinition('name')
         * }]
         * ```
         * @config {Core.data.field.DataField}
         */
        dataField : null,

        /**
         * The Formula provider prefix currently being used
         * @property {String}
         * @private
         */
        formulaPrefix : null
    };

    onFocusIn() {
        super.onFocusIn(...arguments);

        if (this.formulaProvider) {
            this.fieldsList?.show();
        }
    }

    onFocusOut() {
        this.fieldsList?.hide();
        super.onFocusOut(...arguments);
    }

    internalOnKeyEvent(event) {
        const
            me = this,
            { key }        = event,
            { fieldsList } = me;

        if (event.type === 'keydown') {
            if (event.key !== 'Enter') {
                me.lastKey = event.key;
            }

            if (key === 'Escape' && fieldsList?.isVisible) {
                event.stopImmediatePropagation();
                fieldsList.hide();
                return;
            }
            else if (me.formulaPrefix && key === 'ArrowDown') {
                // Prevent cursor jumping to the end of the input field
                event.preventDefault();
                if (!fieldsList?.isVisible) {
                    me.showFieldsList();
                }
            }
        }
        super.internalOnKeyEvent(...arguments);
    }

    internalOnInput() {
        super.internalOnInput(...arguments);
        this.checkForFormula();
    }

    updateValue() {
        super.updateValue(...arguments);
        this.checkForFormula();
    }

    checkForFormula() {
        // Create/change/remove the current active formula provider
        this.formulaPrefix = this.dataField?.inputPrefixRE ? this.value.match(this.dataField.inputPrefixRE)?.[1] : null;
    }

    updateFormulaPrefix(prefix, was) {
        const me = this;

        // Destroy previous formula provider if it exists.
        me.formulaProvider = prefix && me.dataField?.getFormulaProvider?.(prefix);
        was && me.input.classList.toggle(`b-${was.toLowerCase()}-input`, false);

        if (me.formulaProvider) {
            me.input.classList.toggle(`b-${prefix.toLowerCase()}-input`, true);
            me.formulaProvider.setConfig({
                inputField : me,
                store      : me.formulaStore
            });
            me.whenVisible('showFieldsList');

        }
        else {
            me.fieldsList?.hide();
        }
    }

    /**
     * The formula typed between the parentheses in a `=XXX(...)` expression in the field's value if the `XXX`
     * matches an available {@link Core.util.FormulaProvider}.
     * @property {String}
     */
    get formula() {
        const { formulaProvider, value } = this;

        if (formulaProvider) {
            const { formulaRE } = formulaProvider;
            return formulaRE ? value.match(formulaRE) : value;
        }
        return '';
    }

    showFieldsList() {
        const
            me        = this,
            { input } = me,
            name      = me.name?.replace(/^#/, ''),
            grid      = me.up('gridbase', true);

        let picker = me.fieldsList;

        if (picker) {
            picker.owner = me;
            picker.widgetMap.fields.navigator.keyEventTarget = input;
        }
        else {
            // Field names must not contain the field we are editing.
            me.fieldFilter = name && new CollectionFilter(({ id }) => id !== name);

            const { fieldNames } = me;

            picker = me.fieldsList = new Panel({
                title        : 'Fields',
                cls          : 'b-formula-fieldlist',
                floating     : true,
                forElement   : me.inputWrap,
                scrollAction : 'realign',
                owner        : me,
                autoShow     : false,
                align        : {
                    matchSize : 'min',
                    align     : 't0-b0',
                    axisLock  : true,
                    minHeight : Math.min(3, fieldNames.length) * 40
                },
                layoutStyle : {
                    padding : 0
                },
                layout : 'fit',
                items  : {
                    fields : {
                        type           : 'list',
                        items          : fieldNames,
                        itemsFocusable : false,
                        scrollable     : {
                            overflowY : true
                        },
                        navigator : {
                            keyEventTarget      : input,
                            activateOnMouseover : true
                        },
                        getItemCls(record) {
                            if (record.id === 'this' || record.id === 'data') {
                                return 'b-special-field';
                            }
                        },
                        onItem({ event, record }) {
                            if (event.type === 'click') {
                                me.lastKey = null;
                            }

                            if (!event.key || (event.key === 'Enter' && (me.lastKey === 'ArrowDown' || me.lastKey === 'ArrowUp'))) {
                                // Add the field name into the formula at the current cursor position.
                                me.selectField(record.id);
                            }
                            else {
                                // Finalize editing
                                // Unless a list item is focused, don't allow the Enter KeyEvent to be stopped.
                                // So that it can bubble to for example CellEdit handling.
                                event.stopImmediatePropagation = () => delete event.stopImmediatePropagation;
                            }
                        }
                    }
                }
            });

            // If we are a cell editor...
            if (me.owner?.cellEditorContext) {
                grid.ion({
                    cellMousedown : 'onCellMousedown',
                    cellClick     : 'onCellClick',
                    thisObj       : me,
                    prio          : 99999
                });
                me.record = me.owner.cellEditorContext.record;
            }
            else if (!me.record) {
                me.record = me.formulaProvider.record;
            }
        }

        picker.show();
        // Prevent first item being selected, we wait for the user to use UP/DOWN or mouse to show what he/she wants
        // to insert
        picker.activeItem = null;
    }

    onCellMousedown({ event }) {
        if (this.fieldsList.isVisible) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }

    // Users can also inject a field variable by clicking a cell in that column, just like Excel
    onCellClick({ event, column : { field } }) {
        if (this.fieldsList.isVisible) {
            event.stopImmediatePropagation();
            this.selectField(field);

            // Stop the CellEdit's click handling from starting an edit on the clicked cell.
            return false;
        }
    }

    // This inserts the selected field at the current caret position in the input
    selectField(fieldName) {
        const
            me                 = this,
            { input }          = me,
            value              = input.value.trim(),
            { selectionStart } = input,
            atEnd              = selectionStart >= value.length,
            end                = value.endsWith(')') ? value.length : value.length + 2,
            length             = me.formulaProvider.prefix?.length || 0;

        // Only add the field token in if we are inside the formula parentheses.
        if (selectionStart > length + 1 && selectionStart < end) {
            // Ensure there is a space before and after the field token.
            const param = `${atEnd || value[selectionStart - 1]?.match(/\s|\(/) ? '' : ' '}$${fieldName}${atEnd || value[selectionStart]?.match(/\s|\)$/) ? '' : ' '}`;

            input.setRangeText(param, selectionStart, selectionStart);
            input.selectionStart = selectionStart + param.length;

            // Keep the value synced with the inputValue at all times.
            me.inputting = true;
            me.fetchInputValue();
            me.inputting = false;
        }
    }

    get fieldNames() {
        const me = this;

        if (!me._fields) {
            const
                modelClass      = me.formulaStore?.modelClass || me.record.constructor,
                { fieldMap }    = modelClass,
                { fieldFilter } = me,
                fields          = me._fields = modelClass.fields.map(field => {
                    const fieldName = typeof field === 'string' ? field : field.name;

                    return {
                        id   : fieldName,
                        text : fieldMap[fieldName].label
                    };
                })
                    .filter(fieldFilter ? CollectionFilter.generateFiltersFunction([fieldFilter]) : returnTrue)
                    .sort(fieldSorter);

            fields.push({
                text : 'Record',
                id   : 'this'   
            }, {
                text : 'Store',
                id   : 'data'   
            });
        }
        return me._fields;
    }
};
