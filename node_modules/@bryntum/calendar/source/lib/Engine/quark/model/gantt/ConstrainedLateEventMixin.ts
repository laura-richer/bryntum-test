import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/BetterMixin.js'
import { CalculationIterator } from '../../../../ChronoGraph/primitives/Calculation.js'
import { calculate } from '../../../../ChronoGraph/replica/Entity.js'
import DateHelper from '../../../../Core/helper/DateHelper.js'
import { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js'
import { EngineReplica } from "../../../chrono/Replica.js"
import { DateInterval } from "../../../scheduling/DateInterval.js"
import { Direction, Duration, TimeUnit } from '../../../scheduling/Types.js'
import { HasChildrenMixin } from '../scheduler_basic/HasChildrenMixin.js'
import { ConstrainedByDependenciesEventMixin } from "../scheduler_pro/ConstrainedByDependenciesEventMixin.js"
import { ConstrainedScheduleMixin } from "../scheduler_pro/ConstrainedScheduleMixin.js"
import { DateConstraintInterval } from "../scheduler_pro/HasDateConstraintMixin.js"
import { SchedulerProProjectMixin } from "../scheduler_pro/SchedulerProProjectMixin.js"
import { ConstrainedLateScheduleMixin } from "./ConstrainedLateScheduleMixin.js"
import { GanttProjectMixin } from "./GanttProjectMixin.js"


//---------------------------------------------------------------------------------------------------------------------
/**
 * This mixin provides the constraint-based as-late-as-possible scheduling. See the [[ConstrainedEarlyEventMixin]]
 * for the description of the ASAP constraints-based scheduling. See [[GanttProjectMixin]] for more details about
 * forward/backward, ASAP/ALAP scheduling.
 *
 * It also provides the facilities for calculating the event's [[totalSlack]] and the [[critical]] flag.
 *
 * The ALAP-specific constraints are accumulated in [[lateSchedule]], [[latePreSchedule]] fields.
 */
export class ConstrainedLateEventMixin extends Mixin(
    [ ConstrainedByDependenciesEventMixin, HasChildrenMixin ],
    (base : AnyConstructor<
        ConstrainedByDependenciesEventMixin & HasChildrenMixin,
        typeof ConstrainedByDependenciesEventMixin & typeof HasChildrenMixin
    >) => {

    const superProto : InstanceType<typeof base> = base.prototype


    class ConstrainedLateEventMixin extends base {
        // @ts-ignore
        static scheduleMixinClass  : typeof ConstrainedLateScheduleMixin   =
            Mixin(
                [ base.scheduleMixinClass, ConstrainedLateScheduleMixin ],
                base => base
            )

        // here it should be GanttProjectMixin of course, but this breaks the typing badly
        project                     : SchedulerProProjectMixin

        _earlyPreSchedule           : ConstrainedLateScheduleMixin
        _earlySchedule              : ConstrainedLateScheduleMixin
        _latePreSchedule            : ConstrainedLateScheduleMixin
        _lateSchedule               : ConstrainedLateScheduleMixin


        get earlyPreSchedule () : ConstrainedLateScheduleMixin {
            if (this._earlyPreSchedule !== undefined) return this._earlyPreSchedule

            const scheduleMixinClass = (this.constructor as typeof ConstrainedLateEventMixin).scheduleMixinClass

            const schedule      = new scheduleMixinClass({
                // Assign id to avoid expensive id generation
                id : 'earlyPreSchedule' // no-sanity
            }, null, null, false, true) // Skip cloning
            schedule.event      = this
            schedule.phase      = 'phase1'

            return this._earlyPreSchedule = schedule
        }

        // is instantiated upon entering the graph only
        get earlySchedule () : ConstrainedLateScheduleMixin {
            if (this._earlySchedule !== undefined) return this._earlySchedule

            const schedule      = super.earlySchedule as ConstrainedLateScheduleMixin
            schedule.phase      = 'phase2'

            return this._earlySchedule = schedule
        }

        /**
         * The [[ConstrainedLateScheduleMixin]] containing the 1st phase ALAP schedule
         */
        get latePreSchedule () : ConstrainedLateScheduleMixin {
            if (this._latePreSchedule !== undefined) return this._latePreSchedule

            const scheduleMixinClass = (this.constructor as typeof ConstrainedLateEventMixin).scheduleMixinClass

            const schedule      = new scheduleMixinClass({
                // Assign id to avoid expensive id generation
                id : 'latePreSchedule' // no-sanity
            }, null, null, false, true) // Skip cloning
            schedule.event      = this
            schedule.direction  = Direction.Backward
            schedule.phase      = 'phase1'

            return this._latePreSchedule = schedule
        }

        /**
         * The [[ConstrainedLateScheduleMixin]] containing the 2nd phase ALAP schedule
         */
        get lateSchedule () : ConstrainedLateScheduleMixin {
            if (this._lateSchedule !== undefined) return this._lateSchedule

            const scheduleMixinClass = (this.constructor as typeof ConstrainedLateEventMixin).scheduleMixinClass

            const schedule      = new scheduleMixinClass({
                // Assign id to avoid expensive id generation
                id : 'lateSchedule' // no-sanity
            }, null, null, false, true) // Skip cloning
            schedule.event      = this
            schedule.direction  = Direction.Backward
            schedule.phase      = 'phase2'

            return this._lateSchedule = schedule
        }

        /**
         * The latest possible date the event can start.
         * This value is calculated based on the event restrictions.
         */
        @model_field(
            { type : 'date', persist : false, calculated : true },
            { lazy : true, converter : dateConverter, persistent : false }
        )
        lateStartDate : Date

        /**
         * The latest possible date the event can finish.
         * This value is calculated based on the event restrictions.
         */
        @model_field(
            { type : 'date', persist : false, calculated : true },
            { lazy : true, converter : dateConverter, persistent : false }
        )
        lateEndDate : Date


        /**
         * A field storing the _total slack_ (or _total float_) of the event.
         * The _total slack_ is the amount of time that this event can be delayed without causing a delay
         * to the project end.
         * The value is calculated in [[slackUnit]] units.
         */
        @model_field(
            { type : 'number', persist : false, calculated : true },
            { lazy : true, persistent : false }
        )
        totalSlack : Duration

        /**
         * A field storing unit for the [[totalSlack]] value.
         */
        @model_field(
            { type : 'string', defaultValue : TimeUnit.Day, persist : false },
            { lazy : true, converter : DateHelper.normalizeUnit, persistent : false }
        )
        slackUnit : TimeUnit

        /**
         * A boolean field, indicating whether the event is critical or not.
         * The event is __critical__ if its [[totalSlack|total slack]] is zero (or less than zero).
         * This means that if the event is delayed, its successor tasks and the project finish date are delayed as well.
         */
        @model_field(
            { type : 'boolean', defaultValue : false, persist : false, calculated : true },
            { persistent : false, lazy : true }
        )
        critical                        : boolean


        enterGraph (replica : EngineReplica) {
            super.enterGraph(replica)

            this.earlyPreSchedule.enterGraph(replica)
            this.latePreSchedule.enterGraph(replica)
            this.lateSchedule.enterGraph(replica)
        }

        leaveGraph (replica : EngineReplica) {
            this.lateSchedule.leaveGraph(replica)
            this.latePreSchedule.leaveGraph(replica)
            this.earlyPreSchedule.leaveGraph(replica)

            super.leaveGraph(replica)
        }

        unlink () {
            this.lateSchedule.unlink()
            this.latePreSchedule.unlink()
            this.earlyPreSchedule.unlink()

            super.unlink()
        }


        @calculate('lateStartDate')
        * calculateLateStartDate () : CalculationIterator<Date | boolean> {
            return yield this.lateSchedule.$.startDate
        }


        @calculate('lateEndDate')
        * calculateLateEndDate () : CalculationIterator<Date | boolean> {
            return yield this.lateSchedule.$.endDate
        }


        @calculate('totalSlack')
        * calculateTotalSlack () : CalculationIterator<Duration> {
            const earlyStartDate : Date     = yield this.earlySchedule.$.startDate
            const lateStartDate : Date      = yield this.lateSchedule.$.startDate
            const earlyEndDate : Date       = yield this.earlySchedule.$.endDate
            const lateEndDate : Date        = yield this.lateSchedule.$.endDate
            const slackUnit : TimeUnit      = yield this.$.slackUnit

            let result : Duration

            if (earlyStartDate && lateStartDate) {
                result = yield* this.calculateProjectedDuration(earlyStartDate, lateStartDate, slackUnit, undefined, true)
            }

            if (earlyEndDate && lateEndDate) {
                const endSlack = yield* this.calculateProjectedDuration(earlyEndDate, lateEndDate, slackUnit, undefined, true)
                if (endSlack < result) result = endSlack
            }

            return result
        }


        @calculate('critical')
        * calculateCritical () : CalculationIterator<boolean> {
            const totalSlack : Duration = yield this.$.totalSlack

            return typeof totalSlack === 'number' && totalSlack <= 0
        }


        * isConstrainedAlongDirection (direction : Direction) : CalculationIterator<boolean> {
            return yield* this.pickDirectionSchedule(direction).isConstrained()
        }


        pickDirectionSchedule (ownDirection : Direction) : ConstrainedScheduleMixin {
            return ownDirection === Direction.Forward ? this.earlySchedule : this.lateSchedule
        }


        * onEmptyEffectiveInterval (type : 'start' | 'end', sourceSchedule : ConstrainedLateScheduleMixin)
            :
                CalculationIterator<
                    { kind : 'resume' }
                    | { kind : 'return', value : Date }
                    | { kind : 'resolved', value : DateInterval }
                >
        {
            // this condition indicates 2nd pass in the calculation ("late" for forward project, "early" for backward)
            // what happens here is the following - we assume, that if calculations have reached the 2nd pass
            // the conflicts on 1st pass have been resolved somehow
            // so when we have a conflict on the 2nd pass, we just take the value from the 1st pass
            // in other words, if we were able to position the event on 1st pass somehow, we should always be able
            // to position it on the 2nd pass as well (using data from the 1st pass)
            // this will make task critical (early date = late date) with slack 0, however in MSP,
            // slack is negative (if that make sense)
            // probably, also need to set some marker on the task, to indicate that there's a "hidden" conflict
            if (!(yield* sourceSchedule.isFirstPass())) {
                const project = this.getProject() as GanttProjectMixin

                if (yield project.$.ignoreConstraintsOnConflictDuringSecondPass) {
                    const effectiveInterval = type === 'start'
                        ? yield* sourceSchedule.doCalculateEffectiveStartDateInterval(true)
                        : yield* sourceSchedule.doCalculateEffectiveEndDateInterval(true)

                    let intervals : DateInterval[] = Array.from(effectiveInterval.intersectionOf)

                    const info  = this.getOwnConstraintConflictInfo(intervals)

                    if (info.kind === 'dependency_with_own_constraint') {
                        const startDateConstraintIntervals : DateInterval[] =
                            (yield sourceSchedule.$.startDateConstraintIntervals)
                            .concat(yield this.$.startDateConstraintIntervals)
                            .filter(interval => !(interval instanceof DateConstraintInterval))

                        const endDateConstraintIntervals : DateInterval[]   =
                            (yield sourceSchedule.$.endDateConstraintIntervals)
                            .concat(yield this.$.endDateConstraintIntervals)
                            .filter(interval => !(interval instanceof DateConstraintInterval))

                        const newEffectiveConstraintInterval : DateInterval = yield* sourceSchedule.calculateEffectiveConstraintInterval(
                            type === 'start',
                            startDateConstraintIntervals,
                            endDateConstraintIntervals,
                            false
                        )

                        if (!newEffectiveConstraintInterval.isIntervalEmpty()) {
                            return { kind : 'resolved' as 'resolved', value : newEffectiveConstraintInterval }
                        }
                    }
                }

                return {
                    kind : 'return' as 'return',
                    value : yield sourceSchedule.pickOpposite(this).$[ type === 'start' ? 'startDate' : 'endDate' ]
                }
            }
            else {
                return yield* super.onEmptyEffectiveInterval(type, sourceSchedule)
            }
        }
    }

    return ConstrainedLateEventMixin
}){}
