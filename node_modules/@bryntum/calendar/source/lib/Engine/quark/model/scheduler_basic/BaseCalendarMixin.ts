import { AnyConstructor, Mixin } from "../../../../ChronoGraph/class/BetterMixin.js"
import { field } from "../../../../ChronoGraph/replica/Entity.js"
import { CalendarIntervalMixin } from "../../../calendar/CalendarIntervalMixin.js"
import { model_field } from "../../../chrono/ModelFieldAtom.js"
import { ChronoPartOfProjectModelMixin } from "../mixin/ChronoPartOfProjectModelMixin.js"
import { SchedulerBasicProjectMixin } from "./SchedulerBasicProjectMixin.js"
import { AbstractCalendarMixin } from "../AbstractCalendarMixin.js"
import { SchedulingIssueEffect, SchedulingIssueEffectResolution } from "../../../chrono/SchedulingIssueEffect.js"
import Localizable from "../../../../Core/localization/Localizable.js"
import Base from "../../../../Core/Base.js"
import { prototypeValue } from "../../../../ChronoGraph/util/Helpers.js"
import { format } from "../../../util/Functions.js"
import { HasCalendarMixin } from "./HasCalendarMixin.js"
import DateHelper from "../../../../Core/helper/DateHelper.js"

export const EmptyCalendarSymbol    = Symbol('EmptyCalendarSymbol')

export enum CalendarAvailabilityIssue {
    Empty      = 'Empty',
    NoForward  = 'NoForward',
    NoBackward = 'NoBackward'
}

/**
 * The calendar for project scheduling, it is used to mark certain time intervals as "non-working" and ignore them during scheduling.
 *
 * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.
 */
export class BaseCalendarMixin extends Mixin(
    [
        AbstractCalendarMixin,
        ChronoPartOfProjectModelMixin
    ],
    (base : AnyConstructor<
        AbstractCalendarMixin &
        ChronoPartOfProjectModelMixin
        ,
        typeof AbstractCalendarMixin &
        typeof ChronoPartOfProjectModelMixin
>) => {

    class BaseCalendarMixin extends base {
        project                 : SchedulerBasicProjectMixin

        // this field intentionally made "model field", so that its updates are going through
        // all the Core's fields processing (and fires the appropriate events on the store)
        @model_field({}, { persistent : false })
        version                 : number    = 1

        /**
         * The flag, indicating, whether the "unspecified" time (time that does not belong to any [[CalendarIntervalMixin|interval]])
         * is working (`true`) or not (`false`). Default value is `true`
         */
        @model_field({ type : 'boolean', defaultValue : true })
        unspecifiedTimeIsWorking : boolean

        @model_field()
        intervals                : Partial<CalendarIntervalMixin>[]


        leaveProject () {
            this.project?.clearCombinationsWith(this)

            super.leaveProject()
        }
    }

    return BaseCalendarMixin
}){}

/**
 * Class providing a human readable localized description of an [[EmptyCalendarEffect]] instance.
 */
export class EmptyCalendarEffectDescription extends Localizable(Base) {

    static $name = 'EmptyCalendarEffectDescription'

    static get dateFormat() {
        return 'LLL'
    }

    static getDescription (effect : EmptyCalendarEffect) : string {
        let text : string = 'L{descriptionTpl}'
        let calendar : BaseCalendarMixin

        const invalidCalendarData = effect.getInvalidCalendar()

        if (invalidCalendarData) {
            calendar = invalidCalendarData[0]

            if (invalidCalendarData[1] !== CalendarAvailabilityIssue.Empty) {
                text = effect.isForward ? 'L{forwardDescriptionTpl}' : 'L{backwardDescriptionTpl}'
            }
        }
        else {
            text     = 'L{noIntersectionDescriptionTpl}'
            calendar = effect.calendars[0]
        }

        return format(this.L(text), calendar.name || calendar.id,
            DateHelper.format(effect.date, this.dateFormat),
            // @ts-ignore
            effect.event.name)
    }

}

/**
 * Special effect indicating that some calendar or calendars group is misconfigured
 * and do not provide any working period of time which makes its usage
 * impossible.
 */
export class EmptyCalendarEffect extends SchedulingIssueEffect<BaseEmptyCalendarEffectResolution|SchedulingIssueEffectResolution> {

    @prototypeValue('emptyCalendar')
    type                        : string

    handler                     : symbol    = EmptyCalendarSymbol

    @prototypeValue(EmptyCalendarEffectDescription)
    _descriptionBuilderClass

    calendars                   : Array<BaseCalendarMixin>

    event                       : HasCalendarMixin

    date                        : Date

    isForward                   : boolean

    getResolutions () : (BaseEmptyCalendarEffectResolution|SchedulingIssueEffectResolution)[] {
        const calendar      = this.getCalendar()

        return this._resolutions || (this._resolutions = [
            Use24hrsEmptyCalendarEffectResolution.new({ calendar }),
            Use8hrsEmptyCalendarEffectResolution.new({ calendar })
        ])
    }


    /**
     * Returns the calendar that does not have any working periods specified.
     */
    getCalendar () : BaseCalendarMixin {
        const invalidCalendarData = this.getInvalidCalendar()

        return invalidCalendarData ? invalidCalendarData[0] : this.calendars[0]
    }

    getInvalidCalendar () : [BaseCalendarMixin, CalendarAvailabilityIssue] {
        const { calendars, date, isForward } = this

        for (const calendar of calendars) {
            const skippingBackwardResult = calendar.skipNonWorkingTime(date, false)
            const skippingForwardResult = calendar.skipNonWorkingTime(date, true)

            if (isForward) {
                if (!(skippingForwardResult instanceof Date)) {
                    return [
                        calendar,
                        skippingBackwardResult instanceof Date ? CalendarAvailabilityIssue.NoForward : CalendarAvailabilityIssue.Empty
                    ]
                }
            }
            else {
                if (!(skippingBackwardResult instanceof Date)) {
                    return [
                        calendar,
                        skippingForwardResult instanceof Date ? CalendarAvailabilityIssue.NoBackward : CalendarAvailabilityIssue.Empty
                    ]
                }
            }
        }
    }

}

/**
 * Base class for [[EmptyCalendarEffect]] resolutions.
 * The class has [[fixCalendarData]] method that pushes preconfigured `calendarData`
 * to the given [[calendar]]. The method is called in [[resolve]] method so for a subclass
 * it's enough just providing [[fixCalendarData|proper data]].
 */
export class BaseEmptyCalendarEffectResolution extends Localizable(SchedulingIssueEffectResolution) {

    static $name = 'BaseEmptyCalendarEffectResolution'

    /**
     * Calendar to fix.
     */
    calendar        : BaseCalendarMixin

    static get configurable () {
        return {
            /**
             * Correct calendar data.
             * @property calendarData
             */
            calendarData : {
                intervals : [
                    { isWorking : true }
                ]
            }
        }
    }

    getDescription () : string {
        const { calendar } = this

        return format(this.L('L{descriptionTpl}'), calendar.name || calendar.id)
    }

    /**
     * Fixes the provided calendar data by clearing its intervals
     * and then applying data specified in `calendarData` config.
     * @param calendar
     */
    fixCalendarData (calendar : BaseCalendarMixin) {
        calendar.clearIntervals(true)

        // @ts-ignore
        Object.assign(calendar, this.calendarData)

        if (calendar.intervals?.length) {
            calendar.addIntervals(calendar.intervals)
        }
    }

    /**
     * Resolves the [[calendar]] by removing all its intervals and adding new `calendarData`.
     */
    resolve () {
        const { calendar } = this

        this.fixCalendarData(calendar)
    }
}

/**
 * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by
 * replacing its data with standard __24 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.
 */
export class Use24hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {

    static $name = 'Use24hrsEmptyCalendarEffectResolution'

    static get configurable () {
        return {
            calendarData : {
                unspecifiedTimeIsWorking : false,
                intervals                : [
                    {
                        recurrentStartDate : 'on Mon',
                        recurrentEndDate   : 'on Sat',
                        isWorking          : true
                    }
                ]
            }
        }
    }

}

/**
 * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by
 * replacing its data with standard __8 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.
 */
 export class Use8hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {

    static $name = 'Use8hrsEmptyCalendarEffectResolution'

    static get configurable () {
        return {
            calendarData : {
                unspecifiedTimeIsWorking : false,
                intervals                : [
                    {
                        recurrentStartDate : 'every weekday at 08:00',
                        recurrentEndDate   : 'every weekday at 12:00',
                        isWorking          : true
                    },
                    {
                        recurrentStartDate : 'every weekday at 13:00',
                        recurrentEndDate   : 'every weekday at 17:00',
                        isWorking          : true
                    }
                ]
            }
        }
    }

}
