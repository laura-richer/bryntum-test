import CalendarFeature from './CalendarFeature.js';
import Tooltip from '../../Core/widget/Tooltip.js';
import ObjectHelper from '../../Core/helper/ObjectHelper.js';
import DateHelper from '../../Core/helper/DateHelper.js';
import Widget from '../../Core/widget/Widget.js';
import GlobalEvents from '../../Core/GlobalEvents.js';
import ClockTemplate from '../../Scheduler/tooltip/ClockTemplate.js';
import EventHelper from '../../Core/helper/EventHelper.js';
import BrowserHelper from '../../Core/helper/BrowserHelper.js';
import DomHelper from '../../Core/helper/DomHelper.js';

/**
 * @module Calendar/feature/ScheduleTooltip
 */

const isCalendarMixin = w => w.isCalendarMixin;

/**
 * A feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule:
 *
 * {@inlineexample Calendar/feature/ScheduleTooltip.js}
 *
 * ```javascript
 * const calendar = new Calendar({
 *     features : {
 *         scheduleTooltip : true
 *     }
 * });
 * ```
 *
 * This feature is **disabled** by default.
 *
 * @demo Calendar/tooltips
 *
 * @extends Calendar/feature/CalendarFeature
 * @classtype scheduleTooltip
 * @feature
 *
 * @typings Scheduler.feature.ScheduleTooltip -> Scheduler.feature.SchedulerScheduleTooltip
 */
export default class ScheduleTooltip extends CalendarFeature {
    static $name = 'ScheduleTooltip';

    static type = 'ScheduleTooltip';

    static configurable = {
        /**
         * A function (or name of a function in the ownership hierarchy) which decides whether to show the ScheduleTooltip
         * depending on the active view. The active view is passed, and if a truthy value is returned, the tip is shown,
         * otherwise it is hidden.
         *
         * *This defaults to only showing for {@link Calendar.widget.DayView}s*
         * @prp {Function} showScheduleTip
         * @param {Calendar.widget.mixin.CalendarMixin} view The Calendar view that the pointer is over. Return `true` to
         * show the ScheduleTooltip for the passed view.
         * @returns {Boolean} `true` to show the Schedule tooltip for the passed view.
         * @accepts {Function|String}
         */
        showScheduleTip : v => v?.isDayView || v?.viewType?.isDayView,

        /**
         * Gets the Tooltip instance that this feature is using.
         * @member {Core.widget.Tooltip} tooltip
         * @readonly
         */
        /**
         * This config is used to directly configure the associated {@link Core.widget.Tooltip}.
         * @config {TooltipConfig}
         */
        tooltip : {
            $config : ['lazy', 'nullify'],

            value : {
                type                     : 'tooltip',
                allowOver                : true,
                hoverDelay               : 0,
                hideDelay                : 100,
                forSelector              : '*',
                showOnHover              : true,
                anchorToTarget           : false,
                trackMouse               : true,
                updateContentOnMouseMove : true,
                // disable text content and monitor resize for tooltip, otherwise it doesn't
                // get sized properly on first appearance
                monitorResize            : false,
                textContent              : false,
                layoutStyle              : 'white-space:nowrap'
            }
        }
    };

    static get pluginConfig() {
        return {
            chain : ['render']
        };
    }

    changeTooltip(config, existingInstance) {
        if (config) {
            const
                me         = this,
                { client } = me,
                tip        = Tooltip.reconfigure(existingInstance, ObjectHelper.assign({}, config, {
                    id                : `${client.id}-schedule-tip`,
                    owner             : client,
                    forElement        : client.viewContainer.element,
                    getHtml           : me.getHtml.bind(me),
                    filterTarget      : me.filterTarget.bind(me),
                    internalListeners : {
                        innerHtmlUpdate({ source }) {
                            me.clockTemplate.updateDateIndicator(source.element, me.lastTime);
                        }
                    }
                }));

            me.clockTemplate = new ClockTemplate({
                scheduler : client,
                mode      : 'hour'
            });

            return tip;
        }
    }

    filterTarget({ target }) {
        if (!GlobalEvents.isMouseDown() && this.callback(this.showScheduleTip, this, [Widget.fromElement(target)?.closest(isCalendarMixin)])) {
            return target.closest('.b-cal-event-wrap') ? null : target;
        }
    }

    getHtml({ tip, event, activeTarget }) {
        const
            me         = this,
            activeView = Widget.fromElement(activeTarget)?.closest(isCalendarMixin),
            date       = me.callback(me.showScheduleTip, me, [activeView]) && activeView.getDateFromDomEvent(event);

        // We cannot track the tooltip if we are also dragging
        if (date && !(event.type === 'pointermove' && event.pointerType === 'touch' && Object.values(me.client.features.drag?.zones || {}).some(z => z.dragging))) {
            const
                { isDayView } = activeView,
                text          = DateHelper.format(date, `${activeView.dateFormat}${isDayView ? ' ' + (activeView.timeFormat || 'LST') : ''}`);

            me.lastTime = date;
            return isDayView ? me.clockTemplate.generateContent({ date, text }) : text;
        }
        tip.hide();
    }

    onCalendarScroll() {
        const { tooltip } = this;

        // Update tooltip with new over time on scroll
        if (tooltip.isVisible) {
            const
                { triggeredByEvent } = tooltip,
                targetElement        = DomHelper.elementFromPoint(triggeredByEvent.clientX, triggeredByEvent.clientY);

            targetElement.dispatchEvent(new BrowserHelper.PointerEventConstructor('pointermove', triggeredByEvent));
        }
    }

    render() {
        this.getConfig('tooltip');
        EventHelper.on({
            element : this.client.element,
            scroll  : 'onCalendarScroll',
            thisObj : this,
            capture : true
        });
    }

    //region Internal

    updateDisabled(disabled, was) {
        super.updateDisabled(disabled, was);

        if (this._tooltip) {
            this._tooltip.disabled = disabled;
        }
    }
    //endregion
}

// Register this feature type with its Factory
CalendarFeature.register(ScheduleTooltip.type, ScheduleTooltip, true);
