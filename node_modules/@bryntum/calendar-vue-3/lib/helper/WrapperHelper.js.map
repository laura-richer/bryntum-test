{"version":3,"file":"WrapperHelper.js","sources":["../../src/helper/WrapperHelper.ts"],"sourcesContent":["/**\n * Vue 3 widget helper\n */\n\nimport { type ComponentInternalInstance, nextTick } from 'vue';\nimport { type VueConfig, Widget } from '@bryntum/calendar';\n\ndeclare global {\n    // eslint-disable-next-line no-unused-vars\n    interface Window {\n        bryntum: {\n            isTestEnv?: boolean;\n            vue?: {\n                isVueConfig?: (config: any) => boolean;\n                handleVueContent?: (widget: Widget, html: VueConfig) => void;\n            };\n        };\n    }\n}\n\ninterface RenderElement extends HTMLElement {\n    vueKey: string;\n}\n\nexport type Data = Record<string, unknown>;\n\ntype SuppressNew<T> = { [K in keyof T]: T[ K ] }\n\ntype AnyConstructor<\n    Instance extends object = object,\n    Static extends object = object\n> = (new (...input: any[]) => Instance) & SuppressNew<Static>\n\ntype AnyWidget = AnyConstructor<any, any>;\n\ntype RenderData = {\n    record: any,\n    row: any,\n    column: any,\n    cellElement: RenderElement\n}\n\ntype VueTeleportConfig = {\n    vue: boolean,\n    is: string,\n    bind?: object\n    on?: object\n}\n\nexport type WidgetData<T extends AnyWidget> = {\n    instanceClass: T,\n    instanceName: string\n    isView?: boolean,\n    dataStores?: object,\n    projectStores?: boolean,\n    configNames: string[]\n    propertyConfigNames: string[]\n    propertyNames: string[]\n    eventNames: string[]\n    featureNames?: string[]\n}\n\nexport type WidgetConfig<T extends AnyWidget> = {\n    me?: ComponentInternalInstance;\n    widgetData: WidgetData<T>,\n    emit: (...args: any[]) => any\n    element: HTMLDivElement;\n    processCellContent?: Function;\n    processEventContent?: Function;\n    processWidgetContent?: Function;\n    hasFrameworkRenderer?: Function;\n    toRaw?: Function\n}\n\nexport type BryntumConfig = Record<string, any> & {\n    vueComponent?: Object,\n    listeners: Record<string, Function>,\n    features: {},\n    processCellContent: Function,\n    processEventContent: Function,\n    processWidgetContent: Function;\n    hasFrameworkRenderer: Function\n};\n\nexport class WrapperHelper {\n\n    /**\n     * Development warning. Showed when environment is set to 'development'\n     * @param {String} clsName vue component instance\n     * @param {String} msg console message\n     */\n    static devWarning(clsName: string, msg: string) {\n        // @ts-ignore\n        if (window.bryntum?.isTestEnv || process.env.NODE_ENV === 'development') {\n            console.warn(`Bryntum${clsName}Component development warning!\\n${msg}\\n` +\n                'Please check Vue integration guide: https://bryntum.com/products/grid/docs/guide/Grid/integration/vue/guide'\n            );\n        }\n    }\n\n    static devWarningContainer(clsName: string, containerParam: string) {\n        WrapperHelper.devWarning(clsName,\n            `Using \"${containerParam}\" parameter for configuration is not recommended.\\n` +\n            'Widget is placed automatically inside it\\'s container element.\\n' +\n            `Solution: remove \"${containerParam}\" parameter from configuration.`\n        );\n    }\n\n    static devWarningConfigProp(clsName: string, prop: string) {\n        WrapperHelper.devWarning(clsName,\n            `Using \"${prop}\" parameter for configuration is not recommended.\\n` +\n            `Solution: Use separate parameter for each \"${prop}\" value to enable reactive updates of the API instance`\n        );\n    }\n\n    static devWarningUpdateProp(clsName: string, prop: string) {\n        WrapperHelper.devWarning(clsName,\n            `\"${prop}\" is a static config option for component constructor only. No runtime changes are supported!`\n        );\n    }\n\n    static camelize(str: string) {\n        return str.replace(/-./g, s => s[1].toUpperCase());\n    }\n\n    static capitalize(str: string) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n    /**\n     * Returns `true` if the provided configuration object is valid for Vue processing.\n     * @param {*} config\n     * @returns {Boolean}\n     */\n    static isVueConfig(config: any): boolean {\n        return Boolean(config?.vue);\n    }\n\n    /**\n     * Creates bryntum component config from vue component\n     * @param {Object} context\n     * @param {Object} context.me vue component instance\n     * @param {Object} context.widgetData reference to data\n     * @param {Function} context.emit reference to emit\n     * @param {Object} context.element HTML element\n     * @param {Function} context.processCellContent cell renderer method\n     * @param {Function} context.processEventContent event renderer method\n     * @param {Function} context.processWidgetContent widget renderer method\n     * @param {Function} context.hasFrameworkRenderer checks presence of vue renderer\n     * @param {Function} context.toRaw Vue fn to unwrap reactive object\n     * @returns {Object} config object\n     */\n    static createConfig<T extends AnyWidget>({\n        me,\n        widgetData,\n        emit,\n        element,\n        processCellContent,\n        processEventContent,\n        processWidgetContent,\n        hasFrameworkRenderer,\n        toRaw\n    }: WidgetConfig<T>) {\n\n        const\n            props: Record<string, any> = {},\n            vProps                     = me!.vnode!.props! || {};\n\n        for (const key of Object.keys(vProps)) {\n            // Convert possible kebab keys to camelCase\n            props[this.camelize(key)] = vProps[key];\n        }\n\n        const\n            {\n                instanceClass,\n                instanceName\n            }                   = widgetData,\n            isValidProp         = (propName: string) => props[propName] !== undefined,\n            configNames         = (widgetData.configNames || []).filter(isValidProp),\n            propertyConfigNames = (widgetData.propertyConfigNames || []).filter(isValidProp),\n            propertyNames       = (widgetData.propertyNames || []).filter(isValidProp),\n            featureNames        = (widgetData.featureNames || []).filter(isValidProp),\n            // Disable event listeners for onProps, which are duplicating functions with preventable result support\n            eventNames          = widgetData.eventNames.filter(eventName => !isValidProp(eventName) && !props[`on${this.capitalize(eventName)}`]),\n            bryntumConfig       = {\n                vueComponent : me,\n                listeners    : {},\n                features     : {},\n                processCellContent,\n                processEventContent,\n                processWidgetContent,\n                hasFrameworkRenderer\n            } as BryntumConfig;\n\n        // Setup events listeners\n        eventNames.forEach(eventName => bryntumConfig.listeners[eventName] = (params: any) => emit(eventName, params));\n\n        // Setup configs\n        [\n            ...configNames,\n            ...propertyConfigNames,\n            ...featureNames\n        ].forEach(propName => {\n            WrapperHelper.applyPropValue(bryntumConfig, propName, props[propName], true, toRaw);\n            if (['features', 'config'].includes(propName)) {\n                WrapperHelper.devWarningConfigProp(instanceClass.$name, propName);\n            }\n        });\n\n        // Add vue wrapper class name\n        bryntumConfig.cls = (bryntumConfig.cls || '') + ` b-vue-${instanceClass.$name.toLowerCase()}-container`;\n\n        // Prepare watch arrays\n        widgetData.configNames   = configNames;\n        widgetData.propertyNames = [\n            ...configNames,\n            ...propertyNames,\n            ...propertyConfigNames,\n            ...featureNames\n        ];\n\n        // Cleanup unused instance arrays\n        widgetData.eventNames          = [];\n        widgetData.propertyConfigNames = [];\n        widgetData.featureNames        = [];\n\n        // If component has no container specified in config then use adopt to Wrapper's element\n        const\n            containerParam = [\n                'adopt',\n                'appendTo',\n                'insertAfter',\n                'insertBefore'\n            ].find((prop: string) => bryntumConfig[prop]);\n\n        if (!containerParam) {\n            if (instanceName === 'Button') {\n                // Button should always be <a> or <button> inside owner element\n                bryntumConfig.appendTo = element;\n            }\n            else {\n                bryntumConfig.adopt = element;\n            }\n        }\n        else {\n            WrapperHelper.devWarningContainer(instanceClass.$name, containerParam);\n        }\n        return bryntumConfig;\n    }\n\n    /**\n     * Setup store events relay\n     * @param {Object} data reference to data\n     * @param {Object} instance bryntum widget instance\n     */\n    static relayStores(data: any, instance: any) {\n        const { dataStores, projectStores } = data;\n\n        if (dataStores) {\n            Object.keys(dataStores).forEach(storeName => {\n                const store = projectStores ? instance.project[storeName] : instance[storeName];\n                if (store) {\n\n\n                    store.syncDataOnLoad = store.syncDataOnLoad == null ? true : store.syncDataOnLoad;\n\n\n\n                    // Makes relaying store events configurable but off by default\n                    if (instance && instance.relayStoreEvents) {\n                        store.relayAll(instance, dataStores[storeName]);\n                    }\n                }\n            });\n            delete data.dataStores;\n        }\n    }\n\n    /**\n     * Creates bryntum Widget from vue component\n     * @param {Object} config\n     * @param {Object} config.me vue component instance\n     * @param {Object} config.widgetData reference to data\n     * @param {Function} config.emit reference to emit\n     * @param {Object} config.element HTML element\n     * @param {Function} config.processCellContent cell renderer method\n     * @param {Function} config.hasFrameworkRenderer check the presence of vue renderer\n     * @param {Function} config.toRaw Vue fn to unwrap reactive object\n     * @returns {Object} widget object\n     */\n    static createWidget<T extends AnyWidget>(config: WidgetConfig<T>): InstanceType<T> {\n        const\n            { instanceClass } = config.widgetData,\n            cfg               = WrapperHelper.createConfig(config);\n        return (instanceClass.$name === 'Widget' ? Widget.create(cfg) : new instanceClass(cfg)) as InstanceType<T>;\n    }\n\n    /**\n     * Applies property value to Bryntum config or instance.\n     * @param {Object} configOrInstance target object\n     * @param {String} prop property name\n     * @param {Object} value value\n     * @param {Boolean} [isConfig] config setting mode\n     * @param {Function} [toRaw] Vue fn to unwrap reactive object\n     */\n    static applyPropValue(configOrInstance: any, prop: string, value: any, isConfig = true, toRaw?: Function) {\n\n        if (prop === 'project') {\n            // Allow use ProjectModel component as project\n            if (value && typeof value === 'object') {\n                configOrInstance[prop] = value.instance ? value.instance.value || value.instance : value;\n            }\n        }\n        else if (prop === 'features' && typeof value === 'object') {\n            Object.keys(value).forEach(key => WrapperHelper.applyPropValue(configOrInstance, `${key}Feature`, value[key], isConfig, toRaw));\n        }\n        else if (prop === 'config' && typeof value === 'object') {\n            Object.keys(value).forEach(key => WrapperHelper.applyPropValue(configOrInstance, key, value[key], isConfig, toRaw));\n        }\n        else if (prop === 'columns' && !isConfig) {\n            configOrInstance['columns'].data = value;\n        }\n        else if (prop.endsWith('Feature')) {\n            const\n                features    = configOrInstance['features'],\n                featureName = prop.replace('Feature', '');\n            if (isConfig) {\n                features[featureName] = value;\n            }\n            else {\n                const feature = features[featureName];\n                if (feature) {\n                    feature.setConfig(value);\n                }\n            }\n        }\n        else {\n            configOrInstance[prop] = toRaw ? toRaw(value) : value;\n        }\n    }\n\n    /**\n     * Creates watches for vue component properties\n     * @param {Object} me vue component instance\n     * @param {Object} instance bryntum widget instance\n     * @param {Object} props reference to props\n     * @param {Object} data reference to data\n     * @param {Function} watcher watch method reference (Accepts: prop and newValue)\n     */\n    static watchProps<T extends AnyWidget>(\n        instance: InstanceType<T>,\n        data: WidgetData<T>,\n        watcher: (prop: string, callback: (value: any) => void) => void) {\n        const\n            {\n                configNames,\n                propertyNames,\n                instanceClass\n            } = data;\n\n        propertyNames.forEach(prop => watcher(prop, newValue => {\n            const value = Array.isArray(newValue) ? newValue.slice() : newValue;\n            WrapperHelper.applyPropValue(instance, prop, value, false);\n\n            // Check if property is a config and notify\n            if (configNames.includes(prop)) {\n                WrapperHelper.devWarningUpdateProp(instanceClass.$name, prop);\n            }\n        }));\n\n        // Cleanup unused instance arrays\n        data.configNames   = [];\n        data.propertyNames = [];\n    }\n\n    /**\n     * Called from Widget.js to add the Vue component to teleports\n     * @param {Object} context\n     * @param {Widget} context.widget Widget which content is rendered by the Vue component\n     * @param {Object} context.html Object containing the Vue component properties and event listeners\n     */\n    static processWidgetContent({ widget, html }: { widget: Widget; html: VueTeleportConfig }) {\n        const\n            { is, bind = {}, vue, on = {} }       = html,\n            // @ts-ignore\n            { vueComponent }                      = this,\n            { teleports : { value : teleports } } = vueComponent.provides,\n            { contentElement : to, id }           = widget;\n\n        if (vue) {\n            const key = `key-${id}`;\n\n            // delete the teleport with the same key if any\n            if (teleports.has(key)) {\n                teleports.delete(key);\n            }\n\n            nextTick(() => {\n                teleports.set(key, { bind, on, key, is, to });\n            });\n        }\n    }\n\n    /**\n     * Handles the content provided by a Vue component for the widget.\n     * @param {Widget} widget Owner widget\n     * @param {String} html The HTML content to be processed\n     */\n    static handleVueContent(widget: Widget, html: VueConfig): void {\n        // Called when a Vue component is to provide the widget content\n        const\n            hasTeleports = (element: any) => Boolean(element.vueComponent?.provides?.teleports),\n            parentView   = widget.closest(hasTeleports) as any,\n            // Find a view (grid, scheduler, etc.) which has `teleports` defined. It also has `processWidgetContent`\n            view         = parentView?.vueComponent ? parentView : Widget.query(hasTeleports);\n\n        view?.processWidgetContent?.({ widget, html });\n    }\n\n    /**\n     * Event renderer method\n     * @param {Object} context\n     * @param {*} context.jsx\n     * @param {DomConfig} context.domConfig\n     * @param {HTMLElement} context.targetElement\n     * @param {Boolean} context.isRelease\n     * @returns {Boolean}\n     */\n    static processEventContent({\n        // Core passes it as jsx for React wrappers.\n        // Let's rename it to a more appropriate name.\n        jsx : rendererConfig,\n        domConfig,\n        targetElement,\n        isRelease\n    }: {\n        jsx: { [key: string]: any },\n        domConfig: any;\n        isRelease: boolean;\n        targetElement: HTMLElement & { vueKey: string }\n        scrolling: boolean\n    }) {\n\n        let wrap: any   = targetElement,\n            returnValue = false;\n\n        // @ts-ignore\n        const domConfigData = this.isVertical ? domConfig?.elementData?.renderData : domConfig?.elementData;\n\n        if (WrapperHelper.isVueConfig(rendererConfig) && rendererConfig?.is) {\n            if (domConfig?.dataset?.isMilestone) {\n                wrap = targetElement.parentElement!.parentElement!.parentElement!;\n            }\n            else {\n                wrap = targetElement.parentElement!.parentElement!;\n            }\n            const\n                // Vertical nests renderData, while horizontal does not\n                // @ts-ignore\n                wrapData                              = this.isVertical ? wrap.elementData.renderData : wrap.elementData,\n                { assignmentRecord }                  = isRelease ? domConfigData : wrapData,\n                { eventRecord }                       = wrapData,\n                { vueComponent }                      = this as any,\n                { teleports : { value : teleports } } = vueComponent.provides,\n\n                // Recurring events are handled a bit differently so get the flag\n                isRecurring = eventRecord.isRecurring || eventRecord.isOccurrence,\n                key         = `assignment-${assignmentRecord?.id}${isRecurring ? '-' + eventRecord.id : ''}`;\n\n            if (wrap.vueKey) {\n                teleports.delete(wrap.vueKey);\n            }\n            const\n                bind            = { ...rendererConfig },\n                { is, on = {} } = bind;\n\n            delete bind.is;\n            delete bind.on;\n\n            nextTick(() => {\n                teleports.set(key, {\n                    bind,\n                    key,\n                    is,\n                    on,\n                    to         : targetElement,\n                    generation : assignmentRecord.generation\n                });\n\n            });\n\n            wrap.vueKey = key;\n            returnValue = true;\n        }\n\n        return returnValue;\n    }\n\n    /**\n     * Cell renderer method\n     * @param {Object} context\n     * @param {RenderData} context.rendererData\n     * @param {*} context.rendererHtml\n     * @returns {Boolean}\n     */\n    static processCellContent({ rendererData, rendererHtml }: { rendererData: RenderData, rendererHtml: any }) {\n        const { record, column, cellElement, row } = rendererData;\n\n        // Only run for cells with vue renderers\n        if (WrapperHelper.isVueConfig(column.data) && column.data?.renderer) {\n            const\n                // `this` is a caller component\n                { vueComponent }                      = this as any,\n                // `teleports` is javascript Map object\n                { teleports : { value : teleports } } = vueComponent.provides,\n                key                                   = `${column.id}-${record.id}`,\n                renderElement                         = column.tree\n                    ? cellElement.querySelector('.b-tree-cell-value')\n                    : cellElement;\n\n            // If the cell already has a teleport, release it\n            if (cellElement.vueKey) {\n                teleports.delete(cellElement.vueKey);\n            }\n\n            const\n                bind            = { ...rendererHtml },\n                { is, on = {} } = bind;\n\n            delete bind.is;\n            delete bind.on;\n\n            // Create new teleport\n            nextTick(() => {\n                // Only teleport if the row is still used for the same record. Since this happens async, we might have\n                // scrolled over the entire block of rows since the render\n                if (row.id === record.id) {\n                    teleports.set(key, {\n                        bind,\n                        key,\n                        is,\n                        on,\n                        to         : renderElement,\n                        generation : record.generation\n                    });\n                }\n            });\n\n            // Link cell to the teleport, to be able to release it above\n            cellElement.vueKey = key;\n        }\n    }\n\n    /**\n     *\n     * @param {Object} context\n     * @param {*} context.cellContent Content to be rendered in cell (set by renderer)\n     * @param {*} context.column Column being rendered\n     * @returns {Boolean} `true` if there is a Vue Renderer in this cell, `false` otherwise\n     */\n    static hasFrameworkRenderer({ cellContent, column }: { cellContent: any, column: any }) {\n        return cellContent && typeof cellContent === 'object' && WrapperHelper.isVueConfig(column?.data);\n    }\n}\n\n// Expose wrapper methods on window.bryntum\nwindow.bryntum     = window.bryntum || {};\nwindow.bryntum.vue = {\n    isVueConfig      : WrapperHelper.isVueConfig,\n    handleVueContent : WrapperHelper.handleVueContent\n};\n"],"names":["WrapperHelper","clsName","msg","_a","containerParam","prop","str","s","config","me","widgetData","emit","element","processCellContent","processEventContent","processWidgetContent","hasFrameworkRenderer","toRaw","props","vProps","key","instanceClass","instanceName","isValidProp","propName","configNames","propertyConfigNames","propertyNames","featureNames","eventNames","eventName","bryntumConfig","params","data","instance","dataStores","projectStores","storeName","store","cfg","Widget","configOrInstance","value","isConfig","features","featureName","feature","watcher","newValue","widget","html","is","bind","vue","on","vueComponent","teleports","to","id","nextTick","hasTeleports","_b","parentView","view","rendererConfig","domConfig","targetElement","isRelease","wrap","returnValue","domConfigData","wrapData","assignmentRecord","eventRecord","isRecurring","rendererData","rendererHtml","record","column","cellElement","row","renderElement","cellContent"],"mappings":"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"}