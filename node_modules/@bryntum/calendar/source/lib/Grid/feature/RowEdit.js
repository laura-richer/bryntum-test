import ObjectHelper from '../../Core/helper/ObjectHelper.js';
import StringHelper from '../../Core/helper/StringHelper.js';
import GridEditBase from './base/GridEditBase.js';
import GridFeatureManager from './GridFeatureManager.js';
import Panel from '../../Core/widget/Panel.js';
import DomHelper from '../../Core/helper/DomHelper.js';
import GridLocation from '../util/GridLocation.js';

/**
 * @module Grid/feature/RowEdit
 */

/**
 *
 * This feature allows editing of entire rows in a grid in a docked panel which by default slides out from the right.
 *
 * By default, the editor is docked to the browser viewport, but it can be configured to be {@link #config-local} to the
 * grid.
 *
 * The input fields are generated from the columns in the grid in the same way as the {@link Grid.feature.CellEdit}, and
 * the editor is a {@link Core.widget.Panel}.
 *
 * {@inlineexample Grid/feature/RowEdit.js}
 *
 * By default, the editor works in batch mode. Fields are changed, and when the "Save" button is clicked (or the
 * <kbd>Enter</kbd> key pressed), the record is updated with all the changes.
 *
 * The editor can be configured to update the record as soon as a field is changed by setting the
 * {@link #config-instantUpdate} config to `true`.
 *
 * Note that the {@link Grid.column.Column#config-revertOnEscape} property of columns is respected, so pressing
 * <kbd>Escape</kbd> will revert the field to the value of the field *on focus*.
 *
 * Pressing <kbd>Escape</kbd> on a field which has *not* been changed will cancel the edit and close the editor.
 *
 * To start editing a row, double-click a cell in the row, or press <kbd>Enter</kbd> or <kbd>F2</kbd> when a cell is
 * focused.
 *
 * The start gesture can be configured by setting the {@link #config-triggerEvent} config to `'cellClick'` or
 * `'cellDblClick'`.
 *
 * Editing can be prevented by setting the {@link #config-ignoreCSSSelector} config to a CSS selector which matches
 * elements that should not trigger editing.
 *
 * Pressing <kbd>Enter</kbd> or clicking the "Save" button will save the changes and close the editor.
 * Pressing <kbd>Escape</kbd> or clicking the "Cancel" button will close the editor without saving changes.
 *
 * If {@link #config-instantUpdate} is `true`, the record will be updated as soon as a field is changed (on blur or when
 * changed by trigger action such as spin up or down in a number or date or time field), so <kbd>Escape</kbd> and the
 * "Cancel" button revert the changes before closing the editor.
 *
 * Clicking outside the editor will normally cancel the ongoing edit and start a new one on the clicked cell. This can
 * be prevented by setting the {@link #config-continueEditingOnCellClick} config to `false`.
 *
 * This feature is **disabled** by default
 * @demo Grid/rowedit
 * @extends Grid/feature/base/GridEditBase
 * @classtype rowEdit
 * @feature
 */
export default class RowEdit extends GridEditBase {
    static $name = 'RowEdit';

    static configurable = {
        /**
         * The {@link Core.widget.Panel} instance used as the editor.
         * @prp {Core.widget.Panel} editor The editor panel used to edit rows.
         * @accepts {PanelConfig}
         */
        editor : {
            $config : 'lazy',
            value   : {
                type : 'panel',
                cls  : {
                    'b-row-editor' : 1
                },
                drawer : {
                    type      : 'overlay',
                    autoClose : false,
                    tool      : null
                },
                keyMap : {
                    Escape : 'up.cancelEditing',
                    Enter(e) {
                        if (e.target.matches('button')) {
                            return false;
                        }
                        else {
                            this.callback('up.finishEditing');
                        }
                    }
                },
                bbar : {
                    items : {
                        save : {
                            text    : 'L{save}',
                            cls     : { 'b-raised' : 1 },
                            color   : 'b-blue',
                            onClick : 'up.finishEditing'
                        },
                        cancel : {
                            text    : 'L{cancel}',
                            onClick : 'up.cancelEditing'
                        }
                    }
                },
                focus() {
                    const target = this.isValid ? this.focusableElement : this.items.find(f => !f.isValid).focusableElement;

                    target.focus({ preventScroll : true });
                }
            }
        },

        /**
         * By default, the editor field corresponding to the cell clicked will be focused when starting editing.
         *
         * Set to `false` to prevent this. Focus will then go to the first field in the editor.
         *
         * if {@link #config-autoEdit} is `true`, starting editing by typing will always focus the contextual field in
         * the editor.
         * @config {Boolean}
         * @default
         */
        focusContextualField : true,

        /**
         * Set to `true` to update the record as soon as a field is changed.
         * @config {Boolean} [instantUpdate=false]
         */
        instantUpdate : null,

        /**
         * The width of the editor. (Or height if {@link #config-side} is `'top'` or `'bottom'`).
         *
         * May be specified as a number of pixels or a CSS length string.
         * @config {Number|String}
         * @default '30em'
         */
        editorSize : null,

        /**
         * The width of field labels in the editor.
         *
         * May be specified as a number of pixels or a CSS length string.
         * @config {Number|String}
         * @default '10em'
         */
        labelWidth : null,

        /**
         * Configure this as `true` to dock the editor to the grid's element instead of the browser viewport.
         * @config {Boolean} local
         * @default false
         */
        local : null,

        /**
         * Configure this as `true` to show a "Revert" button in the editor which reverts any unsynced changes to the record.
         *
         * This reverts all changes made since the data was loaded or synchronized with the server. This is different to just
         * canceling an ongoing edit. This reverts the record to its loaded state.
         *
         * The button is only shown when starting an edit on a record which has unsynced changes.
         * @config {Boolean}
         * @default false
         */
        revertButton : null,

        /**
         * The side of the grid where the editor will be shown.
         *
         * `'start'` means the `inline-start` side.
         * `'end'` means the `inline-end` side.
         * @config {'start'|'left'|'end'|'right'|'top'|'bottom'}
         * @default 'end'
         */
        side : {
            $config : 'lazy',
            value   : 'end'
        },

        keyMap : {
            Enter : 'startEditing',
            F2    : 'startEditing'
        },

        /**
         * The name of the field from the record to use when generating the title for the editor.
         *
         * The default implementation returns "Editing " plus the value of the named field from the editing record.
         * @config {String} [titleField='name']
         */
        titleField : 'name',

        /**
         * A function (or the name of a function) which will be called passing the editing record to generate the title
         * for the editor.
         *
         * <div class="note">
         * You should never modify any records inside this method.
         * </div>
         *
         * The default implementation returns "Editing " (localized according to the current locale) plus the value of
         * the field specified in {@link #config-titleField}.
         *
         * This may be configured if a more sophisticated title is required.
         * @config {Function} [titleRenderer]
         * @param {Core.data.Model} record The record being edited
         * @returns {String} The title for the editor
         */
        titleRenderer : null
    };

    bindStore(store) {
        this.detachListeners('store');

        store.ion({
            name    : 'store',
            update  : 'onStoreUpdate',
            remove  : 'onStoreRemove',
            thisObj : this
        });
    }

    changeTitleField(titleField) {
        if (typeof titleField === 'string') {
            this.titleRenderer = record => this.L('L{Object.editing}', StringHelper.encodeHtml(record[titleField]));
        }
    }

    getEditingContext(cellSelector) {
        cellSelector = cellSelector.target ? new GridLocation(cellSelector.target) : this.grid.normalizeCellContext(cellSelector);

        if (!cellSelector.record.isSpecialRow) {
            return cellSelector;
        }
    }

    /**
     * Start editing specified row. If no cellContext is given it edits the first visible row.
     * This function is exposed on Grid and can thus be called as `grid.startEditing(...)`.
     *
     * @param {GridLocationConfig} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See
     *   {@link Grid.view.Grid#function-getCell} for details.
     * @param {Boolean} [isAutoEdit] Pass `true` to indicate that the edit is due to a `keydown` event with {@link #config-autoEdit} set to
     *   `true`. In this case the editor field corresponding to the cell context will be cleared for the `keypress` to take effect upon focus.
     * @fires beforeStartRowEdit
     * @fires startRowEdit
     * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an {@link Core.widget.Editor#event-beforeStart} listener
     *   has vetoed the edit.
     * @category Editing
     * @on-owner
     */
    async startEditing(editorContext = { id : this.grid.firstVisibleRow.id }, isAutoEdit) {
        if (this.isEditing) {
            if (this.cancelEditing(true) === false) {
                return false;
            }
            this.editorContext?.row?.removeCls('b-editing');
        }
        editorContext = this.editorContext = this.getEditingContext(editorContext);

        if (editorContext) {
            const
                me         = this,
                { grid }   = me,
                editor     = me.editor || ((me.editor = me._editorConfig) && me.editor),
                { cancel } = editor.bbar.widgetMap;

            editorContext.editor = editor;
            editor.title = me.callback(me.titleRenderer, me, [editorContext.record]);
            editor.record = editorContext.record;
            editor.rowEditorContext = editorContext;
            editor.readOnly = grid.readOnly || editor.record.readOnly;
            cancel && (cancel.text = me.L(editor.readOnly ? 'L{close}' : 'L{cancel}'));

            /**
             * Fires on the owning Grid before editing starts, return `false` to prevent editing
             * @event beforeStartRowEdit
             * @on-owner
             * @preventable
             * @param {Grid.view.Grid} source Owner grid
             * @param {Grid.util.GridLocation} editorContext Editing context
             * @param {Grid.column.Column} editorContext.column Target column
             * @param {Core.data.Model} editorContext.record Target record
             * @param {HTMLElement} editorContext.cell Target cell
             * @param {Core.widget.Field} editorContext.editor The {@link Core.widget.Panel} instance which contains the editor fields.
             */
            if (grid.trigger('beforeStartRowEdit', { grid, editorContext }) === false) {
                return false;
            }

            // Show or hide revert button depending upon record's modified state
            if (me.revertButton) {
                editor.bbar.widgetMap.revert.hidden = !me.editorContext.record.isModified;
            }

            await editor.collapsible.toggleReveal(true);

            const
                field   = editor.widgetMap[editorContext.column?.field],
                toFocus = field && (isAutoEdit || me.focusContextualField) ? field : editor;

            if (isAutoEdit && !editor.readOnly) {
                field?.clear();
            }
            toFocus.focus();
            editorContext.row.addCls('b-editing');

            /**
             * Fires on the owning Grid when editing starts
             * @event startRowEdit
             * @on-owner
             * @param {Grid.view.Grid} source Owner grid
             * @param {Grid.util.GridLocation} editorContext Editing context
             * @param {Core.widget.Panel} editorContext.editor The Panel being used.
             * Will contain an `inputField` property which is the field being used to perform the editing.
             * @param {Grid.column.Column} editorContext.column Target column
             * @param {Core.data.Model} editorContext.record Target record
             * @param {HTMLElement} editorContext.cell Target cell
             */
            grid.trigger('startRowEdit', { grid, editorContext });

        }
    }

    onEditorStart() {
        // Should move editing to new cell on click, unless click is configured to start editing - in which case it
        // will move anyway
        if (this.triggerEvent !== 'cellclick') {
            this.detachListeners('cellClickWhileEditing');
            this.grid.ion({
                name      : 'cellClickWhileEditing',
                cellclick : 'onCellClickWhileEditing',
                thisObj   : this
            });
        }
    }

    syncEditingReadOnly({ readOnly }) {
        if (this.isEditing) {
            const
                { editor } = this,
                { record } = this.editorContext,
                { cancel } = editor.bbar.widgetMap;

            editor.readOnly = readOnly || record.readOnly;
            cancel && (cancel.text = this.L(editor.readOnly ? 'L{close}' : 'L{cancel}'));
        }
    }

    onEditorHide() {
        // Clean up and restore cell to full visibility
        // before we hide and attempt to revert focus to the cell.
        this.editorContext?.row?.removeCls('b-editing');
        this.detachListeners('cellClickWhileEditing');
        this.editorContext = this.editor.record = null;
    }

    /**
     * Finish editing, update the underlying record and hide the editor.
     * This function is exposed on Grid and can thus be called as `grid.finishEditing(...)`
     * @fires beforeFinishRowEdit
     * @fires finishRowEdit
     * @returns {Promise} Resolved promise returns `false` if the edit could not be finished due to an input field being invalid
     * or the {@link #event-beforeFinishRowEdit} event was prevented.
     * @on-owner
     */
    async finishEditing() {
        const
            me = this,
            {
                grid,
                editor,
                editorContext
            }  = this;

        if (editor.isValid) {
            /**
             * Fires on the owning Grid before the row editing is finished, return false to signal that the value is invalid and editing should not be finalized.
             *
             * Note that if {@link #config-instantUpdate} is `true`, the record will be updated as soon as a field is changed, so this event
             * would not prevent the record from being updated, only the editor being hidden.
             * @on-owner
             * @event beforeFinishRowEdit
             * @preventable
             * @async
             * @param {Grid.view.Grid} grid Target grid
             * @param {Core.widget.Panel} editorContext.editor The Panel being used.
             * Will contain an `inputField` property which is the field being used to perform the editing.
             * @param {Core.data.Model} record The record being edited
             */
            let result = grid.trigger('beforeFinishRowEdit', editorContext);

            // If the event handler returns a promise, wait for it to resolve
            // During this time, the finishEditingPromise property will be set to the promise as a flag
            // to indicate that we should not try to start a new edit until the promise has resolved.
            if (ObjectHelper.isPromise(result)) {
                me.finishEditingPromise = result;
                result = await result;
                me.finishEditingPromise = null;
            }
            if (result === false) {
                editor.focus();
                return false;
            }

            editor.collapsible.toggleReveal(false);
            me.updateRecordFromFields();

            /**
             * Fires on the owning Grid before the row editing is finished, return false to signal that the value is invalid and editing should not be finalized.
             *
             * Note that if {@link #config-instantUpdate} is `true`, the record will be updated as soon as a field is changed, so this event
             * would not prevent the record from being updated, only the editor being hidden.
             * @on-owner
             * @event finishRowEdit
             * @preventable
             * @async
             * @param {Grid.view.Grid} grid Target grid
             * @param {Core.widget.Panel} editorContext.editor The Panel being used.
             * Will contain an `inputField` property which is the field being used to perform the editing.
             * @param {Core.data.Model} record The record that has been edited
             */
            grid.trigger('finishRowEdit', editorContext);

            return true;
        }
        else {
            editor.items.find(f => !f.isValid)?.focus();
            return false;
        }
    }

    /**
     * Cancel editing, hides the editor.
     * This function is exposed on Grid and can thus be called as `grid.cancelEditing(...)`
     * @param {Boolean} isStarting Pass `true` to indicate that the cancel is due to a new edit starting
     * @fires beforeCancelRowEdit
     * @returns {Boolean} `false` if the edit could not be canceled due to the {@link #event-beforeCancelRowEdit} event being prevented.
     * @category Editing
     * @on-owner
     */
    cancelEditing(isStarting = false) {
        const
            me         = this,
            { editor } = me;

        /**
         * Fires on the owning Grid before the row editing is canceled, return false to signal that the value is invalid and editing should not be finalized.
         *
         * Note that if {@link #config-instantUpdate} is `true`, the record *will* be reset to initial values on cancel of editing.
         * @on-owner
         * @event beforeCancelRowEdit
         * @preventable
         * @async
         * @param {Grid.view.Grid} grid Target grid
         * @param {Core.widget.Panel} editorContext.editor The Panel being used.
         * Will contain an `inputField` property which is the field being used to perform the editing.
         * @param {Core.data.Model} recordThe record being edited
         */
        if (me.grid.trigger('beforeCancelRowEdit', me.editorContext) === false) {
            editor.focus();
            return false;
        }

        // If it's a cancel due to a new edit starting, don't revert the record and don't hide the editor
        if (isStarting !== true) {
            if (me.instantUpdate) {
                me.isCanceling = true;
                editor.setValues(editor.initialValues);
                me.updateRecordFromFields();
                me.isCanceling = false;
            }
            editor.collapsible.toggleReveal(false);
        }
    }

    /**
     * Finish editing if clicking below rows (only applies when grid is higher than rows).
     * Also finish if event target is the subgrid which can happen if the pointer is moved during mouse down.
     * @private
     * @category Internal event handling
     */
    async onElementClick(event) {
        if (event.target.matches('.b-grid-body-container, .b-grid-subgrid') && this.editorContext) {
            await this.finishEditing(event);
        }
    }

    // Handles autoedit
    async onElementKeyDown(event) {
        const
            me              = this,
            { grid }        = me,
            { focusedCell } = grid;

        // flagging event with handled = true used to signal that other features should probably not care about it
        if (event.handled || !me.autoEdit || me.isEditing || !focusedCell || (focusedCell.isActionable && DomHelper.isEditable(event.target)) || event.ctrlKey) {
            return;
        }

        // Any character or space starts editing while autoedit is true
        if (event.key.length <= 1) {
            me.startEditing(focusedCell, true);
        }
    }

    updateSide() {
        // Once an editor has been created docked, changing sides necessitates a new one
        this.editor = null;
    }

    changeEditor(editor, was) {
        if (editor) {
            const
                me  = this,
                {
                    grid,
                    labelWidth
                } = me,
                config   = Panel.mergeConfigs({
                    owner : grid,
                    cls   : {
                        'b-editor-instant-update' : me.instantUpdate
                    },
                    drawer : {
                        side : me.side,
                        size : me.editorSize
                    },
                    autoUpdateRecord : me.instantUpdate,
                    items            : me.collectEditorFields(),
                    style            : {
                        [labelWidth ? '--b-label-width' : ''] : DomHelper.setLength(labelWidth)
                    },
                    refreshEdit : me.refreshEdit.bind(me)
                }, editor);

            if (!me._editorConfig) {
                me._editorConfig = editor;
            }
            // If app wants it local to the grid, append it to the grid's element
            if (me.local) {
                config.appendTo = grid.element;
            }
            if (me.revertButton) {
                config.bbar.items.revert = {
                    text    : 'L{revert}',
                    onClick : me.revertChanges.bind(me)
                };
            }
            editor = Panel.reconfigure(was, editor ? config : null, me);

            editor?.ion({
                thisObj : me,
                show    : 'onEditorStart',
                hide    : 'onEditorHide'
            });
        }
        else {
            was?.removeAll();
            was?.destroy();
        }
        return editor;
    }

    revertChanges() {
        const
            me                 = this,
            { editor, record } = me.editorContext;

        me.isCanceling = true;
        record.revertChanges();
        editor.title = me.callback(me.titleRenderer, me, [record]);
        editor.setValues(record, {
            onlyName  : editor.strictRecordMapping,
            highlight : Boolean(editor.$highlight)
        });
        me.isCanceling;
    }

    refreshEdit() {
        const { editor } = this;

        // On change while editing, update the field values unless we are in the process of canceling
        // or we are doing immediate record updates which will always go back through here
        if (editor.isVisible) {
            this.syncEditingReadOnly({ readOnly : this.grid.readOnly });
            if (!this.instantUpdate && !this.isCanceling) {
                editor.setValues(this.editorContext.record, {
                    onlyName  : editor.strictRecordMapping,
                    highlight : Boolean(editor.$highlight)
                });
            }
        }
    }

    updateRecordFromFields() {
        const
            { editor } = this,
            { record } = editor;

        editor.items.forEach(field => {
            const key = field.getValueName({
                onlyName : editor.strictRecordMapping
            });

            if (key && (key in record)) {
                record.setValue(key, field.value);
            }
        }, true);
    }

    updateInstantUpdate(instantUpdate) {
        const { _editor } = this;

        if (_editor) {
            _editor.autoUpdateRecord = instantUpdate;
            _editor.element.classList.toggle('b-editor-instant-update', Boolean(instantUpdate));
        }
    }

    collectEditorFields() {
        let weight = 0;

        return this.grid.columns.reduce((items, column) => {
            const
                { editor }     = column,
                { modelClass } = this.grid.store;

            if (editor?.isField) {
                editor.readOnly = column.readOnly;
                weight = editor.weight || (editor.weight = weight + 100);
                if (!editor.label) {
                    editor.label = column.text || modelClass.getFieldDefinition(column.field).label;
                }
                // First ESC press reverts
                editor.revertOnEscape = column.revertOnEscape;
                items[column.field] = editor;
            }
            return items;
        }, {});
    }
}

GridFeatureManager.registerFeature(RowEdit);
