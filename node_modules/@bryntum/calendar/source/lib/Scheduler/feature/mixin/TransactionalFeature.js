import Base from '../../../Core/Base.js';
import AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';
import IdHelper from '../../../Core/helper/IdHelper.js';

/**
 * @module Scheduler/feature/mixin/TransactionalFeature
 */

/**
 * Feature defining methods to lock the view for a time of a user action
 * @internal
 * @mixin
 */
export default Target => class TransactionalFeature extends (Target || Base).mixin(AttachToProjectMixin) {
    static $name = 'TransactionalFeature';

    //#region AttachToProjectMixin implementation

    detachFromProject(project) {
        this.rejectFeatureTransaction();
        super.detachFromProject(project);
    }

    //#endregion

    //#region TaskEditSTM Mixin overrides

    getStmCapture() {
        const result = super.getStmCapture?.() ?? {};
        result._editorPromiseResolve = this._editorPromiseResolve;
        return result;
    }

    applyStmCapture(stmCapture) {
        super.applyStmCapture?.(stmCapture);

        this._editorPromiseResolve = stmCapture._editorPromiseResolve;
    }

    //#endregion

    //#region API related to passing transaction between features

    /**
     * Capturing transaction is a process of passing control over current revision boundaries from one feature
     * to another. At the moment it is only used by the CellEdit feature which keeps revision open while new
     * records are being created.
     * We take the promise which unblocks the queue, store transaction id and raise a flag which tells this
     * mixin to not actually start new or finish existing transaction. Rejection, however, cleans up the flag
     * and unblocks the queue like it should.
     * Workflow is like this:
     * ```
     * const capture = feature1.captureFeatureTransaction
     * feature2.applyCapturedFeatureTransaction(capture);
     * ```
     * @returns {Object}
     * @private
     */
    captureFeatureTransaction() {
        if (this.client.transactionalFeaturesEnabled) {
            this._hasFeatureTransactionCapture = true;

            return {
                source  : this,
                resolve : this._editorPromiseResolve
            };
        }
    }

    /**
     * Applies captured feature transaction to pass control to the current feature
     * @param {Object} capture
     * @private
     */
    applyCapturedFeatureTransaction(capture = {}) {
        if (this.client.transactionalFeaturesEnabled) {
            const { source, resolve } = capture;

            if (source !== this) {
                source._hasFeatureTransactionCapture = false;
                source.cleanupTransactionMetadata();

                this._hasFeatureTransactionCapture = true;
                this._editorPromiseResolve = resolve;
            }
        }
    }

    releaseFeatureTransaction() {
        if (this.client.transactionalFeaturesEnabled) {
            this._hasFeatureTransactionCapture = false;
        }
    }

    //#endregion

    get canStartFeatureTransaction() {
        return !this.client.transactionalFeaturesEnabled ||
            (!this._hasFeatureTransactionCapture &&
                !this.client.project.stm.isNavigatingRevisions);
    }

    async startFeatureTransaction() {
        // If transaction is captured, we don't need to do anything else
        if (!this.client.transactionalFeaturesEnabled || this._hasFeatureTransactionCapture) {
            return;
        }

        const
            me          = this,
            { project } = me.client,
            { stm }     = project,
            // This id is used to help debugging concurrent promises
            id          = IdHelper.generateId('featureTransaction');

        me.client.trigger('beforeFeatureTransactionStart', { id });

        // Await previous promise chain to resolve
        let chainResolved;

        if (me.hasStmCapture) {
            stm.startTransaction();
        }
        else {
            chainResolved = project.queue(async() => {
                // commitAsync call will lead to `refresh` event on the project
                // and consequent view refresh, which we do not need
                if (!project.isEngineReady()) {
                    await project.commitAsync();
                }
            });
        }

        project.queue(() => {
            if (!me.hasStmCapture) {
                me._stmInitiallyDisabled = stm.disabled;
                me._stmInitiallyAutoRecord = stm.autoRecord;

                if (stm.isRecording) {
                    stm.stopTransaction();
                }
                else if (me._stmInitiallyDisabled) {
                    stm.enable();
                }

                // Disable autoRecord to avoid finishing transaction after a timeout
                stm.autoRecord = false;
            }

            if (!stm.isRecording) {
                // We need to wrap cell editing into own transaction to be able to apply user changes last
                stm.startTransaction();
            }

            me.client.trigger('featureTransactionStart', { id });

            // Put an empty promise to the queue to pause it
            return new Promise(resolve => me._editorPromiseResolve = resolve);
        });

        await chainResolved;
    }

    rejectFeatureTransaction() {
        const
            me      = this,
            { stm } = me.client.project,
            id      = me.client.featureTransactionId;

        if (!id || me.finishingFeatureTransaction) {
            return;
        }

        me._editorPromiseResolve?.();

        if (me._hasFeatureTransactionCapture) {
            me.releaseFeatureTransaction();
        }

        me.cleanupTransactionMetadata();

        stm.isRecording && stm.rejectTransaction();

        if (!me.hasStmCapture && me._stmInitiallyDisabled != null) {
            stm.disabled = me._stmInitiallyDisabled;
            stm.autoRecord = me._stmInitiallyAutoRecord;
        }

        me.client.trigger('featureTransactionReject', { id });
        me.client.trigger('featureTransactionComplete', { id });
    }

    cleanupTransactionMetadata() {
        this._editorPromiseResolve = null;
    }

    async finishFeatureTransaction() {
        const
            me      = this,
            {
                client,
                _stmInitiallyDisabled,
                _stmInitiallyAutoRecord
            }       = me,
            {
                project,
                featureTransactionId : id
            }       = client,
            { stm } = project;

        // If transaction is captured we don't need to finish current transaction
        if (!id || me._hasFeatureTransactionCapture) {
            return;
        }

        client.trigger('featureTransactionFinalizeStart', { id });
        me.finishingFeatureTransaction = true;

        // In case there is a commit pending, we need to wait to not suspend more events than we should
        await project.commitAsync();

        if (stm.isRecording) {
            stm.stopTransaction();
        }

        me._editorPromiseResolve?.();
        me._editorPromiseResolve = null;

        if (!me.hasStmCapture && stm && !stm.isDestroying && _stmInitiallyDisabled != null) {
            stm.disabled = _stmInitiallyDisabled;
            stm.autoRecord = _stmInitiallyAutoRecord;
        }

        if (!me.isDestroying) {
            me.finishingFeatureTransaction = false;

            client.trigger('featureTransactionFinalized', { id });
            client.trigger('featureTransactionComplete', { id });
        }
    }
};
