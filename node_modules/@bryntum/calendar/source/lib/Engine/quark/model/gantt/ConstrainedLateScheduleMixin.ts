import { Identifier } from '../../../../ChronoGraph/chrono/Identifier.js'
import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/BetterMixin.js'
import { CalculationIterator } from "../../../../ChronoGraph/primitives/Calculation.js"
import { Direction, EffectiveDirection } from "../../../scheduling/Types.js"
import { ConstrainedByDependenciesEventScheduleMixin } from "../scheduler_pro/ConstrainedByDependenciesEventScheduleMixin.js"
import { ConstrainedLateEventMixin } from "./ConstrainedLateEventMixin.js"


/**
 * The "late" schedule of the event, which is used when scheduling "backward" (as late as possible).
 */
export class ConstrainedLateScheduleMixin extends Mixin(
    [ ConstrainedByDependenciesEventScheduleMixin ],
    (base : AnyConstructor<
        ConstrainedByDependenciesEventScheduleMixin
        ,
        typeof ConstrainedByDependenciesEventScheduleMixin
    >) => {

    class ConstrainedLateScheduleMixin extends base {
        event       : ConstrainedLateEventMixin


        pick (event : this[ 'event' ]) : this {
            if (this.phase === 'phase1') {
                return (this.direction === Direction.Forward ? event.earlyPreSchedule : event.latePreSchedule) as this
            }
            else {
                return (this.direction === Direction.Forward ? event.earlySchedule : event.lateSchedule) as this
            }
        }


        pickOpposite (event : this[ 'event' ]) : this {
            if (this.phase === 'phase1') {
                return (this.direction === Direction.Forward ? event.latePreSchedule : event.earlyPreSchedule) as this
            }
            else {
                return (this.direction === Direction.Forward ? event.lateSchedule : event.earlySchedule) as this
            }
        }


        * pickPushingSchedule (pushingEvent : ConstrainedLateEventMixin, pushingDirection : EffectiveDirection) : CalculationIterator<ConstrainedLateScheduleMixin> {
            if (this.phase === 'phase1') {
                return this.pick(pushingEvent)
            }
            else {
                // possibly should be checking the parent event direction here, instead of the project's?
                // anyway, the idea is, that we should pick the "phase1" schedule only on one side
                // of the dependency with contradicting directions, for that, we compare the direction
                // with the direction of some "outer" context
                const projectDirection : EffectiveDirection     = yield this.getProject().$.effectiveDirection

                if (this.direction === Direction.Forward) {
                    if (pushingDirection.direction === Direction.Backward && projectDirection.direction === Direction.Forward) {
                        return pushingEvent.latePreSchedule
                    }
                    else {
                        return pushingEvent.earlySchedule
                    }
                }
                else {
                    if (pushingDirection.direction === Direction.Forward && projectDirection.direction === Direction.Backward) {
                        return pushingEvent.earlyPreSchedule
                    }
                    else {
                        return pushingEvent.lateSchedule
                    }
                }
            }
        }


        * pickPushingStartDateIdentifier (pushingEvent : ConstrainedLateEventMixin) : CalculationIterator<Identifier> {
            return (yield* this.pickPushingSchedule(pushingEvent, yield pushingEvent.$.startDateDirection)).$.startDate
        }


        * pickPushingEndDateIdentifier (pushingEvent : ConstrainedLateEventMixin) : CalculationIterator<Identifier> {
            return (yield* this.pickPushingSchedule(pushingEvent, yield pushingEvent.$.endDateDirection)).$.endDate
        }
    }

    return ConstrainedLateScheduleMixin
}){}
