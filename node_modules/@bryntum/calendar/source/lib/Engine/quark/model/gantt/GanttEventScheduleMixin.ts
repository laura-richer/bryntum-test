import { AnyConstructor, MixinAny } from "../../../../ChronoGraph/class/BetterMixin.js"
import { calculate, field } from "../../../../ChronoGraph/replica/Entity.js"
import { CalculationIterator } from "../../../../ChronoGraph/primitives/Calculation.js"
import { Direction, EffectiveDirection, ProjectConstraintResolution } from "../../../scheduling/Types.js"
import { ConstrainedByParentScheduleMixin } from "./ConstrainedByParentScheduleMixin.js"
import { ConstrainedLateScheduleMixin } from "./ConstrainedLateScheduleMixin.js"
import { GanttEvent } from "./GanttEvent.js"
import { ProjectConstraintInterval } from "./GanttProjectMixin.js"
import { InactiveEventScheduleMixin } from "./InactiveEventScheduleMixin.js"

/**
 * This is a gantt-specific event schedule mixin.
 */
export class GanttEventScheduleMixin extends MixinAny(
    [
        ConstrainedByParentScheduleMixin,
        ConstrainedLateScheduleMixin,
        InactiveEventScheduleMixin
    ],
    (base : AnyConstructor<
        ConstrainedByParentScheduleMixin
            & ConstrainedLateScheduleMixin
            & InactiveEventScheduleMixin,
        typeof ConstrainedByParentScheduleMixin
            & typeof ConstrainedLateScheduleMixin
            & typeof InactiveEventScheduleMixin
    >) => {

    class GanttEventScheduleMixin extends base {
        event : GanttEvent

        // need to have at least one "entity" decorator in the class, otherwise the entity infrastructure won't be setup
        @calculate('startDateConstraintIntervals')
        * calculateStartDateConstraintIntervals () : CalculationIterator<this[ 'startDateConstraintIntervals' ]> {
            const result : this[ 'startDateConstraintIntervals' ]           = yield* super.calculateStartDateConstraintIntervals()

            if (this.direction === Direction.Forward) {
                const projectConstraintResolution : this[ 'event' ]['projectConstraintResolution']  = yield this.event.$.projectConstraintResolution
                const direction : EffectiveDirection                                                = yield this.event.$.effectiveDirection

                // If the event is configured to ignore the project border constraint
                if (direction.direction === Direction.Forward && projectConstraintResolution === ProjectConstraintResolution.Ignore) {
                    // skip the project constraint for it so we could calculate the event start/end dates w/o that constraint effect
                    return result.filter(interval => !(interval as ProjectConstraintInterval).isProjectConstraintInterval)
                }
            }

            return result
        }

        * calculateEndDateConstraintIntervals () : CalculationIterator<this[ 'endDateConstraintIntervals' ]> {
            const result : this[ 'endDateConstraintIntervals' ]             = yield* super.calculateEndDateConstraintIntervals()

            if (this.direction === Direction.Backward) {
                const projectConstraintResolution : this[ 'event' ]['projectConstraintResolution']  = yield this.event.$.projectConstraintResolution
                const direction : EffectiveDirection                                                = yield this.event.$.effectiveDirection

                // If the event is configured to ignore the project border constraint
                if (direction.direction === Direction.Backward && projectConstraintResolution === ProjectConstraintResolution.Ignore) {
                    // skip the project constraint for it so we could calculate the event start/end dates w/o that constraint effect
                    return result.filter(interval => !(interval as ProjectConstraintInterval).isProjectConstraintInterval)
                }
            }

            return result
        }

    }

    return GanttEventScheduleMixin
}){}