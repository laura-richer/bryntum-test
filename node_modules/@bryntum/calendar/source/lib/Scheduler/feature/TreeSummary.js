import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';
import TickCells from '../../Scheduler/feature/TickCells.js';

/**
 * @module Scheduler/feature/TreeSummary
 */

/**
 * A feature allowing you to roll up and display values in the time axis cell for each parent row in a tree scheduler.
 *
 * This feature is **disabled** by default.
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *      appendTo : 'container',
 *      features : {
 *          treeSummary : {
 *              renderer({ startDate, endDate, resourceRecord, timeline }) {
 *                  let totalDemandedCapacity = 0;
 *
 *                  resourceRecord.traverse(child => {
 *                      child.events.forEach(task => {
 *                          if (DateHelper.intersectSpans(task.startDate, task.endDate, startDate, endDate)) {
 *                              totalDemandedCapacity += task.demandedCapacity || 0;
 *                          }
 *                      });
 *                  }, true);
 *
 *                  if (timeline.project.effectiveCalendar.isWorkingTime(startDate, endDate)) {
 *                      return 1 - totalDemandedCapacity;
 *                  }
 *
 *                  return 0;
 *              }
 *          }
 *      }
 * });
 * ```
 *
 * @demo Scheduler/tree-summary
 * @classtype treeSummary
 * @feature
 * @extends Core/mixin/InstancePlugin
 */
export default class TreeSummary extends TickCells {
    static $name = 'TreeSummary';

    //region Init

    static configurable = {
        // region Hidden configs
        /**
         * @hideconfigs resourceTickStore, resourceTicksData, tickRenderer, showEditor
         */
        // endRegion

        rangeCls : 'b-sch-tick-summary-cell',

        cls : 'b-tree-summary-cell',

        showEditor : false,

        /**
         * Required, renderer function for parent resource summary cells. Used to both calculate and format the summary.
         * Should return textual content or a {@link Core.helper.DomHelper#typedef-DomConfig} object.
         *
         * ```javascript
         * new Scheduler({
         *     features : {
         *         treeSummary : {
         *             renderer({ startDate, endDate, resourceRecord, timeline }) {
         *                  let totalDemandedCapacity = 0;
         *
         *                  resourceRecord.traverse(node => {
         *                     node.events.forEach(task => {
         *                          if (DateHelper.intersectSpans(task.startDate, task.endDate, startDate, endDate)) {
         *                              totalDemandedCapacity += task.demandedCapacity || 0;
         *                          }
         *                      });
         *                  }, true);
         *
         *                  if (timeline.project.effectiveCalendar.isWorkingTime(startDate, endDate)) {
         *                      return 1 - totalDemandedCapacity;
         *                  }
         *
         *                  return 0;
         *             }
         *         }
         *     }
         * });
         * ```
         *
         * @config {Function}
         * @param {Object} context Summary context object
         * @param {Date} context.startDate Tick start date
         * @param {Date} context.endDate Tick end date
         * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record representing the current row
         * @param {Scheduler.data.EventStore} context.eventStore Event store
         * @param {Scheduler.data.ResourceStore} context.resourceStore Resource store
         * @param {Scheduler.view.TimelineBase} context.timeline The timeline/scheduler instance
         * @returns {String|DomConfig} Either textual content or a DomConfig object
         */
        renderer : false,

        /**
         * Set to `false` to disallow mouse interactions with the rendered range elements. By default, the range elements
         * are reachable with the mouse.
         * @prp {Boolean}
         * @default true
         */
        enableMouseEvents : true
    };

    // Plugin configuration.
    static get pluginConfig() {
        return {
            before   : ['onInternalPaint', 'internalOnVisibleDateRangeChange'],
            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],
            override : ['matchScheduleCell', 'resolveResourceRecord']
        };
    }

    changeRenderer(renderer) {
        if (!renderer) {
            throw new Error('The TreeSummary feature requires defining a `renderer` function');
        }

        return renderer;
    }

    onInternalPaint({ firstPaint }) {
        super.onInternalPaint(...arguments);
        if (firstPaint) {
            this.client.ion({
                treeGroupChange : () => this.updateResourceTickCell()
            });
        }
    }

    attachToEventStore(store) {
        store.ion({
            name    : 'eventStore',
            change  : 'onEventStoreChange',
            buffer  : 1,
            thisObj : this
        });
    }

    attachToResourceStore(store) {
        store.ion({
            name    : 'resourceStore',
            change  : 'onResourceStoreChange',
            buffer  : 1,
            thisObj : this
        });
    }

    doDisable(disable) {
        super.doDisable(disable);

        if (!this.isConfiguring) {
            this.client.renderRows();
        }
    }

    //endregion

    //region Events

    /**
     * Triggered for mouse down on a tick cell. Only triggered if the TreeSummary feature is configured
     * with `{@link #config-enableMouseEvents}: true`.
     * @event tickCellMouseDown
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.feature.TreeSummary} feature The TreeSummary feature
     * @param {Date} startDate Tick start date
     * @param {Date} endDate Tick end date
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} domEvent Browser event
     * @on-owner
     */

    /**
     * Triggered for mouse up on a tick cell. Only triggered if the TreeSummary feature is configured
     * with `{@link #config-enableMouseEvents}: true`.
     * @event tickCellMouseUp
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.feature.TreeSummary} feature The TreeSummary feature
     * @param {Date} startDate Tick start date
     * @param {Date} endDate Tick end date
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} domEvent Browser event
     * @on-owner
     */

    /**
     * Triggered for click on a tick cell. Only triggered if the TreeSummary feature is configured with
     * `{@link #config-enableMouseEvents}: true`.
     * @event tickCellClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.feature.TreeSummary} feature The TreeSummary feature
     * @param {Date} startDate Tick start date
     * @param {Date} endDate Tick end date
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} domEvent Browser event
     * @on-owner
     */

    /**
     * Triggered for double-click on a tick cell. Only triggered if the TreeSummary feature is configured
     * with `{@link #config-enableMouseEvents}: true`.
     * @event tickCellDblClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.feature.TreeSummary} feature The TreeSummary feature
     * @param {Date} startDate Tick start date
     * @param {Date} endDate Tick end date
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} domEvent Browser event
     * @on-owner
     */

    /**
     * Triggered for right-click on a tick cell. Only triggered if the TreeSummary feature is configured
     * with `{@link #config-enableMouseEvents}: true`.
     * @event tickCellContextMenu
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.feature.TreeSummary} feature The TreeSummary feature
     * @param {Date} startDate Tick start date
     * @param {Date} endDate Tick end date
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} domEvent Browser event
     * @on-owner
     */

    internalOnVisibleDateRangeChange() {
        if (!this.disabled) {
            this.updateResourceTickCell();
        }
    }

    async onEventStoreChange() {
        await this.client.project.commitAsync();
        if (!this.disabled) {
            this.updateResourceTickCell();
        }
    }

    async onResourceStoreChange({ action, records }) {
        await this.client.project.commitAsync();
        if (!this.disabled) {
            if (action === 'remove' || action === undefined) {
                this.updateResourceTickCell();
            }
            else {
                // Iterate all resources and refresh parent cells
                const resources = new Set();
                records.forEach(record => {
                    record.bubble((parent) => {
                        resources.add(parent);
                        return !record.isParent;
                    });
                });
                this.updateResourceTickCell(resources, false);
            }
        }
    }

    updateDisabled(disabled) {
        if (!this.isConfiguring) {
            if (disabled) {
                this.resourceTickStore.removeAll();
            }
            else {
                this.updateResourceTickCell();
            }
        }
    }

    //endregion

    updateResourceTickCell(resourceRecords = null, reset = true) {
        const
            me                             = this,
            { client, resourceTickStore }  = me,
            { timeAxis, visibleDateRange } = client;

        if (!me.disabled) {
            const
                firstTick = Math.floor(timeAxis.getTickFromDate(visibleDateRange.startDate)),
                lastTick  = Math.ceil(timeAxis.getTickFromDate(visibleDateRange.endDate)),
                ticks     = [];

            (resourceRecords && resourceRecords.size !== 0 ? resourceRecords : client.store.storage.allValues).forEach(record => {
                if (!record?.isParent) {
                    return;
                }

                for (let tick = firstTick; tick < lastTick; tick++) {
                    const
                        startDate = timeAxis.getDateFromTick(tick),
                        endDate   = timeAxis.getDateFromTick(tick + 1),
                        summary   = me.renderer({
                            startDate,
                            endDate,
                            resourceRecord : record,
                            eventStore     : client.eventStore,
                            resourceStore  : client.resourceStore,
                            timeline       : client
                        });

                    if (summary || summary === 0) {
                        ticks.push({
                            id         : `${tick}-${record.id}`,
                            startDate,
                            endDate,
                            value      : summary,
                            resourceId : record.id
                        });
                    }
                }
            });

            if (reset) {
                me.resourceTicksData = ticks;
            }
            else {
                const
                    { allValues } = resourceTickStore.storage,
                    ticksToRemove = [];

                for (const res of resourceRecords) {
                    for (const record of allValues) {
                        if (record.resourceId === res.id) {
                            ticksToRemove.push(record);
                        }
                    }
                }
                client.suspendRefresh();
                resourceTickStore.remove(ticksToRemove);
                resourceTickStore.add(ticks);
                client.resumeRefresh(false);
                client.refresh();
            }
        }
    }
}

GridFeatureManager.registerFeature(TreeSummary, false, ['Scheduler', 'SchedulerPro', 'Gantt']);
