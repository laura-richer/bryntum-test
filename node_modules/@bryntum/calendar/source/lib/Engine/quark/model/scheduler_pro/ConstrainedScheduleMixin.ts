import { AnyConstructor, Mixin } from '../../../../ChronoGraph/class/BetterMixin.js'
import { CalculationIterator } from '../../../../ChronoGraph/primitives/Calculation.js'
import { calculate, field } from '../../../../ChronoGraph/replica/Entity.js'
import { ConstraintInterval } from "../../../chrono/Conflict.js"
import { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js'
import { DateInterval, intersectIntervals } from '../../../scheduling/DateInterval.js'
import { ConstraintIntervalSide, Direction, Duration, EffectiveDirection } from '../../../scheduling/Types.js'
import { isDateFinite, MAX_DATE, MIN_DATE } from "../../../util/Constants.js"
import { ChronoPartOfProjectModelMixin } from "../mixin/ChronoPartOfProjectModelMixin.js"
import { BaseEventMixin } from "../scheduler_basic/BaseEventMixin.js"
import { HasSubEventsMixin } from "../scheduler_basic/HasSubEventsMixin.js"
import { ConstrainedEarlyEventMixin } from "./ConstrainedEarlyEventMixin.js"
import { SchedulerProProjectMixin } from "./SchedulerProProjectMixin.js"

//---------------------------------------------------------------------------------------------------------------------
export const calculateEffectiveStartDateConstraintInterval = function* (
    event                               : BaseEventMixin,
    startDateIntervalIntersection       : DateInterval,
    endDateIntervalIntersection         : DateInterval,
    duration                            : Duration,
    collectIntersectionMeta?            : boolean
) : CalculationIterator<DateInterval>
{
    if (endDateIntervalIntersection.isIntervalEmpty()) return endDateIntervalIntersection //EMPTY_INTERVAL

    // If intersection details collecting is enabled (need this when preparing a scheduling conflict info)

    if (collectIntersectionMeta && endDateIntervalIntersection.intersectionOf) {
        const reflectedIntervals : Set<DateInterval> = new Set()

        // Iterate over the intervals that took part in "endDateIntervalIntersection" building
        // and reflect each of them to task "End" side.
        // So we could compare each interval one by one.

        for (const interval of endDateIntervalIntersection.intersectionOf) {
            if (interval.isInfinite()) {
                reflectedIntervals.add(interval)
            }
            else {
                const startDate = interval.startDateIsFinite()
                    ? yield* event.calculateProjectedXDateWithDuration(interval.startDate, false, duration)
                    : interval.startDate

                const endDate   = interval.endDateIsFinite()
                    ? yield* event.calculateProjectedXDateWithDuration(interval.endDate, false, duration)
                    : interval.endDate

                const originInterval : ConstraintInterval   = interval as ConstraintInterval

                reflectedIntervals.add(originInterval.copyWith({
                    reflectionOf : originInterval,
                    side         : originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,
                    startDate,
                    endDate,
                }))
            }
        }

        // override intersectionOf with reflected intervals
        endDateIntervalIntersection.intersectionOf = reflectedIntervals
    }

    const startDate = endDateIntervalIntersection.startDateIsFinite()
        ? yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.startDate, false, duration)
        : null

    const endDate   = endDateIntervalIntersection.endDateIsFinite()
        ? yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.endDate, false, duration)
        : null

    return intersectIntervals(
        [
            startDateIntervalIntersection,
            ConstraintInterval.new({
                intersectionOf  : endDateIntervalIntersection.intersectionOf,
                startDate,
                endDate
            })
        ],
        collectIntersectionMeta
    )
}

export const calculateEffectiveEndDateConstraintInterval = function* (
    event                           : BaseEventMixin,
    startDateIntervalIntersection   : DateInterval,
    endDateIntervalIntersection     : DateInterval,
    duration                        : Duration,
    collectIntersectionMeta?        : boolean
) : CalculationIterator<DateInterval>
{
    if (startDateIntervalIntersection.isIntervalEmpty()) return startDateIntervalIntersection //EMPTY_INTERVAL

    // If intersection details collecting is enabled (need this when preparing a scheduling conflict info)

    if (collectIntersectionMeta) {
        const reflectedIntervals : Set<DateInterval> = new Set()

        // Iterate over the intervals that took part in "startDateIntervalIntersection" building
        // and reflect each of them to task "End" side.
        // So we could compare each interval one by one.

        for (const interval of startDateIntervalIntersection.intersectionOf) {

            // no need to reflect infinite intervals
            if (interval.isInfinite()) {
                reflectedIntervals.add(interval)
            }
            // reflect finite interval
            else {
                const startDate = interval.startDateIsFinite()
                    ? yield* event.calculateProjectedXDateWithDuration(interval.startDate, true, duration)
                    : interval.startDate

                const endDate   = interval.endDateIsFinite()
                    ? yield* event.calculateProjectedXDateWithDuration(interval.endDate, true, duration)
                    : interval.endDate

                const originInterval : ConstraintInterval   = interval as ConstraintInterval

                // Make a reflection of the interval
                reflectedIntervals.add(originInterval.copyWith({
                    reflectionOf : originInterval,
                    side         : originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,
                    startDate,
                    endDate,
                }))
            }
        }

        // override intersectionOf with reflected intervals
        startDateIntervalIntersection.intersectionOf = reflectedIntervals
    }

    const startDate = startDateIntervalIntersection.startDateIsFinite()
        ? yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.startDate, true, duration)
        : null

    const endDate   = startDateIntervalIntersection.endDateIsFinite()
        ? yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.endDate, true, duration)
        : null

    return intersectIntervals(
        [
            endDateIntervalIntersection,
            ConstraintInterval.new({
                reflectionOf    : startDate || endDate ? startDateIntervalIntersection as ConstraintInterval : undefined,
                intersectionOf  : startDate || endDate ? startDateIntervalIntersection.intersectionOf : undefined,
                startDate,
                endDate
            }),
        ],
        collectIntersectionMeta
    )
}


/**
 * Abstract schedule of the event. It just defines a position of the event, w/o specifying how it is calculated.
 */
export class EventScheduleMixin extends Mixin(
    [ ChronoPartOfProjectModelMixin ],
    (base : AnyConstructor<ChronoPartOfProjectModelMixin, typeof ChronoPartOfProjectModelMixin>) => {

    class EventScheduleMixin extends base {

        direction       : Direction                 = undefined

        phase           : 'phase1' | 'phase2'       = 'phase1'

        /**
         * The event, to which this schedule belongs. This property is immutable - it is assigned on creation
         * and can not be modified after.
         */
        event           : HasSubEventsMixin         = undefined

        /**
         * The start date of the event in this particular schedule.
         */
        @model_field(
            { type : 'date', persist : false, calculated : true },
            { lazy : true, converter : dateConverter, persistent : false }
        )
        startDate : Date

        /**
         * The end date of the event in this particular schedule.
         */
        @model_field(
            { type : 'date', persist : false, calculated : true  },
            { lazy : true, converter : dateConverter, persistent : false }
        )
        endDate : Date


        get project () : SchedulerProProjectMixin {
            return this.event?.project as SchedulerProProjectMixin
        }


        pick (event : this[ 'event' ]) : this {
            throw new Error("Implement me")
        }


        @calculate('startDate')
        * calculateStartDate () : CalculationIterator<Date> {
            throw new Error("Implement me")
        }


        @calculate('endDate')
        * calculateEndDate () : CalculationIterator<Date> {
            throw new Error("Implement me")
        }


        // Get rid of irrelevant fields, to speed up record creation a wee bit
        static setupFields (cls, meta) {
            // @ts-ignore
            super.setupFields(cls, meta)

            this.removeField('parentIndex')
            this.removeField('orderedParentIndex')
            this.removeField('parentId')
            this.removeField('expanded')
            this.removeField('readOnly')
        }
    }

    return EventScheduleMixin
}){}


/**
 * Schedule of the event. It may or may be not used as a final position of the event itself, depending on
 * scheduling direction and other data.
 *
 * Accumulates the constraints for start/end dates.
 */
export class ConstrainedScheduleMixin extends Mixin(
    [ EventScheduleMixin ],
    (base : AnyConstructor<EventScheduleMixin, typeof EventScheduleMixin>) => {

    class ConstrainedScheduleMixin extends base {
        direction       : Direction                 = Direction.Forward

        event           : ConstrainedEarlyEventMixin = undefined

        //--------------------------
        @field({ lazy : true })
        minChildrenStartDate : Date

        @field({ lazy : true })
        maxChildrenEndDate : Date


        // `ignoreEdgesFlow` is supposed to fix an edge case bug, see a comment in
        // Gantt/tests/engine/postponed-conflict.t.js#Should not freeze on specific editing scenario, when `totalSlack` column is added
        //--------------------------
        /**
         * An array of intervals, constraining the start date (as point in time) of this event
         */
        @field({ lazy : true, ignoreEdgesFlow : true })
        startDateConstraintIntervals : DateInterval[]

        /**
         * An array of intervals, constraining the end date (as point in time) of this event
         */
        @field({ lazy : true, ignoreEdgesFlow : true })
        endDateConstraintIntervals : DateInterval[]


        pick (event : this[ 'event' ]) : this {
            return event.earlyPreSchedule as this
        }


        // Skips non-working time if it's needed to the event
        * maybeSkipNonWorkingTime (date : Date, isForward : boolean = true, constraintInterval : DateInterval = null) : CalculationIterator<Date> {
            // We don't really need to skip non-working time for a summary task start/end dates.
            // It just reflects corresponding min/max values of its children
            if (yield* this.event.hasSubEvents()) return date

            let duration : Duration     = yield* this.event.calculateEffectiveDuration()

            let result : Date = date

            if (date && duration > 0) {

                result = yield* this.event.skipNonWorkingTime(date, isForward)

                // make sure the resulting date is inside the allowed constraint interval
                if (result && constraintInterval && !constraintInterval.containsDate(result)) {
                    result = date
                }
            }

            return result
        }


        * calculateEffectiveConstraintInterval (
            isStartDate : boolean,
            startDateConstraintIntervals : DateInterval[],
            endDateConstraintIntervals : DateInterval[],
            collectIntersectionMeta : boolean = false
        )
            : CalculationIterator<DateInterval>
        {
            const effectiveDurationToUse : Duration = yield* this.event.calculateEffectiveDuration()

            if (effectiveDurationToUse == null) {
                return null
            }

            const calculateIntervalFn   = isStartDate ? calculateEffectiveStartDateConstraintInterval : calculateEffectiveEndDateConstraintInterval

            const effectiveInterval : DateInterval  = yield* calculateIntervalFn(
                this.event,
                intersectIntervals(startDateConstraintIntervals, collectIntersectionMeta),
                intersectIntervals(endDateConstraintIntervals, collectIntersectionMeta),
                effectiveDurationToUse,
                collectIntersectionMeta
            )

            return effectiveInterval
        }


        /**
         * Calculation method for the [[startDateConstraintIntervals]]. Returns empty array by default.
         * Override this method to return some extra constraints for the start date.
         */
        @calculate('startDateConstraintIntervals')
        * calculateStartDateConstraintIntervals () : CalculationIterator<this[ 'startDateConstraintIntervals' ]> {
            return this.direction === Direction.Forward
                ? yield* this.event.calculateEarlyStartDateConstraintIntervals()
                : yield* this.event.calculateLateStartDateConstraintIntervals()
        }


        /**
         * Calculation method for the [[endDateConstraintIntervals]]. Returns empty array by default.
         * Override this method to return some extra constraints for the end date.
         */
        @calculate('endDateConstraintIntervals')
        * calculateEndDateConstraintIntervals () : CalculationIterator<this[ 'endDateConstraintIntervals' ]> {
            return this.direction === Direction.Forward
                ? yield* this.event.calculateEarlyEndDateConstraintIntervals()
                : yield* this.event.calculateLateEndDateConstraintIntervals()
        }


        * doCalculateEffectiveStartDateInterval (collectIntersectionMeta : boolean = false) : CalculationIterator<DateInterval> {
            const startDateConstraintIntervals : DateInterval[] = yield this.$.startDateConstraintIntervals
            const endDateConstraintIntervals : DateInterval[]   = yield this.$.endDateConstraintIntervals

            return yield* this.calculateEffectiveConstraintInterval(
                true,
                // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is
                // used as storage for `this.$.earlyStartDateConstraintIntervals`
                startDateConstraintIntervals.concat(yield this.event.$.startDateConstraintIntervals),
                endDateConstraintIntervals.concat(yield this.event.$.endDateConstraintIntervals),
                collectIntersectionMeta
            )
        }


        * doCalculateEffectiveEndDateInterval (collectIntersectionMeta : boolean = false) : CalculationIterator<DateInterval> {
            const startDateConstraintIntervals : DateInterval[] = yield this.$.startDateConstraintIntervals
            const endDateConstraintIntervals : DateInterval[]   = yield this.$.endDateConstraintIntervals

            return yield* this.calculateEffectiveConstraintInterval(
                false,
                // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is
                // used as storage for `this.$.earlyStartDateConstraintIntervals`
                startDateConstraintIntervals.concat(yield this.event.$.startDateConstraintIntervals),
                endDateConstraintIntervals.concat(yield this.event.$.endDateConstraintIntervals),
                collectIntersectionMeta
            )
        }


        /**
         * The method defines whether the provided child event should be
         * taken into account when calculating this summary event [[earlyStartDate]].
         * Child events roll up their [[earlyStartDate]] values to their summary tasks.
         * So a summary task [[earlyStartDate]] date gets equal to its minimal child [[earlyStartDate]].
         *
         * If the method returns `true` the child event is taken into account
         * and if the method returns `false` it's not.
         * By default, the method returns `true` to include all child events data.
         * @param child Child event to consider.
         * @returns `true` if the provided event should be taken into account, `false` if not.
         */
        * shouldRollupChildStartDate (child : ConstrainedEarlyEventMixin) : CalculationIterator<boolean> {
            return this.direction === Direction.Forward
                ? yield* this.event.shouldRollupChildEarlyStartDate(child)
                : yield* this.event.shouldRollupChildLateStartDate(child)
        }


        @calculate('minChildrenStartDate')
        * calculateMinChildrenStartDate () : CalculationIterator<Date> {
            let result = MAX_DATE

            const subEventsIterator : Iterable<ConstrainedEarlyEventMixin> = yield* this.event.subEventsIterable() as any

            for (const childEvent of subEventsIterator) {
                if (!(yield* this.shouldRollupChildStartDate(childEvent))) continue

                let childDate : Date

                if ((yield* childEvent.isManuallyScheduled()) && (yield* childEvent.hasSubEvents())) {
                    childDate = yield this.pick(childEvent).$.minChildrenStartDate
                }

                childDate = childDate || (yield this.pick(childEvent).$.startDate)

                if (childDate && childDate < result) result = childDate
            }

            return result.getTime() - MAX_DATE.getTime() ? result : null
        }


        /**
         * The method defines whether the provided child event should be
         * taken into account when calculating this summary event [[earlyEndDate]].
         * Child events roll up their [[earlyEndDate]] values to their summary tasks.
         * So a summary task [[earlyEndDate]] gets equal to its maximal child [[earlyEndDate]].
         *
         * If the method returns `true` the child event is taken into account
         * and if the method returns `false` it's not.
         * By default, the method returns `true` to include all child events data.
         * @param child Child event to consider.
         * @returns `true` if the provided event should be taken into account, `false` if not.
         */
        * shouldRollupChildEndDate (child : ConstrainedEarlyEventMixin) : CalculationIterator<boolean> {
            return this.direction === Direction.Forward
                ? yield* this.event.shouldRollupChildEarlyEndDate(child)
                : yield* this.event.shouldRollupChildLateEndDate(child)
        }


        @calculate('maxChildrenEndDate')
        * calculateMaxChildrenEndDate () : CalculationIterator<Date> {
            let result : Date = MIN_DATE

            const subEventsIterator : Iterable<ConstrainedEarlyEventMixin> = yield* this.event.subEventsIterable() as any

            for (const childEvent of subEventsIterator) {
                if (!(yield* this.shouldRollupChildEndDate(childEvent))) continue

                let childDate : Date

                if ((yield* childEvent.isManuallyScheduled()) && (yield* childEvent.hasSubEvents())) {
                    childDate = yield this.pick(childEvent).$.maxChildrenEndDate
                }

                childDate = childDate || (yield this.pick(childEvent).$.endDate)

                if (childDate && childDate > result) result = childDate
            }

            return result.getTime() - MIN_DATE.getTime() ? result : null
        }


        @calculate('startDate')
        * calculateStartDate () : CalculationIterator<Date> {
            let date : Date
            let effectiveInterval

            // Manually scheduled task treat its current start date as its early start date
            // in case of forward scheduling.
            // Late dates in that case are calculated the same way it happens for automatic tasks
            if (
                (yield* this.event.isManuallyScheduled())
                && (
                    !(yield this.project.$.autoScheduleManualTasksOnSecondPass)
                    || (yield this.event.$.effectiveDirection).direction === this.direction
                )
            ) {
                date = yield this.event.$.startDate
            }
            // Parent task calculate its early start date as minimal early start date of its children
            else if (yield* this.event.hasSubEvents()) {
                date = yield this.$.minChildrenStartDate
            }
            else if (!(yield* this.isConstrained())) {
                date = yield this.event.$.startDate
            }
            else {
                effectiveInterval = yield* this.doCalculateEffectiveStartDateInterval()

                if (effectiveInterval === null) {
                    return null
                }
                else if (effectiveInterval.isIntervalEmpty()) {
                    const res = yield* this.event.onEmptyEffectiveInterval('start', this)

                    if (res.kind === 'return') {
                        return res.value
                    }
                    else if (res.kind === 'resolved') {
                        effectiveInterval = res.value
                    }
                }
                else {
                    yield* this.event.onNonEmptyEffectiveInterval('start', this)
                }

                date = this.direction === Direction.Forward
                    ? isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null
                    : isDateFinite(effectiveInterval.endDate) ? effectiveInterval.endDate : null
            }

            return yield* this.maybeSkipNonWorkingTime(date, true, effectiveInterval)
        }


        @calculate('endDate')
        * calculateEndDate () : CalculationIterator<Date> {
            let date : Date
            let effectiveInterval

            // Manually scheduled task treat its current end date as its early end date
            // in case of forward scheduling.
            // Late dates in that case are calculated the same way it happens for automatic tasks
            if (
                (yield* this.event.isManuallyScheduled())
                && (
                    !(yield this.project.$.autoScheduleManualTasksOnSecondPass)
                    || (yield this.event.$.effectiveDirection).direction === this.direction
                )
            ) {
                date = yield this.event.$.endDate
            }
            // Parent task calculate its early end date as maximum early end date of its children
            else if (yield* this.event.hasSubEvents()) {
                date = yield this.$.maxChildrenEndDate
            }
            else if (!(yield* this.isConstrained())) {
                date = yield this.event.$.endDate
            }
            else {
                effectiveInterval = yield* this.doCalculateEffectiveEndDateInterval()

                if (effectiveInterval === null) {
                    return null
                }
                else if (effectiveInterval.isIntervalEmpty()) {
                    const res = yield* this.event.onEmptyEffectiveInterval('end', this)

                    if (res.kind === 'return') {
                        return res.value
                    }
                    else if (res.kind === 'resolved') {
                        effectiveInterval = res.value
                    }
                }
                else {
                    yield* this.event.onNonEmptyEffectiveInterval('end', this)
                }

                date = this.direction === Direction.Forward
                    ? isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null
                    : isDateFinite(effectiveInterval.endDate) ? effectiveInterval.endDate : null
            }

            return yield* this.maybeSkipNonWorkingTime(date, false, effectiveInterval)
        }


        * isConstrained () : CalculationIterator<boolean> {
            const eventStartDateIntervals : DateInterval[]          = yield this.event.$.startDateConstraintIntervals
            const eventEndDateIntervals : DateInterval[]            = yield this.event.$.endDateConstraintIntervals

            const startDateIntervals : DateInterval[]               = yield this.$.startDateConstraintIntervals
            const endDateIntervals : DateInterval[]                 = yield this.$.endDateConstraintIntervals

            return startDateIntervals?.length > 0
                || endDateIntervals?.length > 0
                || eventStartDateIntervals?.length > 0
                || eventEndDateIntervals?.length > 0
        }


        * isFirstPass () : CalculationIterator<boolean> {
            const projectDirection : EffectiveDirection     = yield this.getProject().$.effectiveDirection

            // this condition indicates 1st pass in the calculation ("early" for forward project, "late" for backward)
            return projectDirection.direction === this.direction
        }
    }

    return ConstrainedScheduleMixin
}){}
