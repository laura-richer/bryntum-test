var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Mixin } from "../../../../ChronoGraph/class/BetterMixin.js";
import { model_field } from "../../../chrono/ModelFieldAtom.js";
import { ChronoPartOfProjectModelMixin } from "../mixin/ChronoPartOfProjectModelMixin.js";
import { AbstractCalendarMixin } from "../AbstractCalendarMixin.js";
import { SchedulingIssueEffect, SchedulingIssueEffectResolution } from "../../../chrono/SchedulingIssueEffect.js";
import Localizable from "../../../../Core/localization/Localizable.js";
import Base from "../../../../Core/Base.js";
import { prototypeValue } from "../../../../ChronoGraph/util/Helpers.js";
import { format } from "../../../util/Functions.js";
import DateHelper from "../../../../Core/helper/DateHelper.js";
export const EmptyCalendarSymbol = Symbol('EmptyCalendarSymbol');
export var CalendarAvailabilityIssue;
(function (CalendarAvailabilityIssue) {
    CalendarAvailabilityIssue["Empty"] = "Empty";
    CalendarAvailabilityIssue["NoForward"] = "NoForward";
    CalendarAvailabilityIssue["NoBackward"] = "NoBackward";
})(CalendarAvailabilityIssue || (CalendarAvailabilityIssue = {}));
/**
 * The calendar for project scheduling, it is used to mark certain time intervals as "non-working" and ignore them during scheduling.
 *
 * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.
 */
export class BaseCalendarMixin extends Mixin([
    AbstractCalendarMixin,
    ChronoPartOfProjectModelMixin
], (base) => {
    class BaseCalendarMixin extends base {
        constructor() {
            super(...arguments);
            // this field intentionally made "model field", so that its updates are going through
            // all the Core's fields processing (and fires the appropriate events on the store)
            this.version = 1;
        }
        leaveProject() {
            this.project?.clearCombinationsWith(this);
            super.leaveProject();
        }
    }
    __decorate([
        model_field({}, { persistent: false })
    ], BaseCalendarMixin.prototype, "version", void 0);
    __decorate([
        model_field({ type: 'boolean', defaultValue: true })
    ], BaseCalendarMixin.prototype, "unspecifiedTimeIsWorking", void 0);
    __decorate([
        model_field()
    ], BaseCalendarMixin.prototype, "intervals", void 0);
    return BaseCalendarMixin;
}) {
}
/**
 * Class providing a human readable localized description of an [[EmptyCalendarEffect]] instance.
 */
export class EmptyCalendarEffectDescription extends Localizable(Base) {
    static get dateFormat() {
        return 'LLL';
    }
    static getDescription(effect) {
        let text = 'L{descriptionTpl}';
        let calendar;
        const invalidCalendarData = effect.getInvalidCalendar();
        if (invalidCalendarData) {
            calendar = invalidCalendarData[0];
            if (invalidCalendarData[1] !== CalendarAvailabilityIssue.Empty) {
                text = effect.isForward ? 'L{forwardDescriptionTpl}' : 'L{backwardDescriptionTpl}';
            }
        }
        else {
            text = 'L{noIntersectionDescriptionTpl}';
            calendar = effect.calendars[0];
        }
        return format(this.L(text), calendar.name || calendar.id, DateHelper.format(effect.date, this.dateFormat), 
        // @ts-ignore
        effect.event.name);
    }
}
EmptyCalendarEffectDescription.$name = 'EmptyCalendarEffectDescription';
/**
 * Special effect indicating that some calendar or calendars group is misconfigured
 * and do not provide any working period of time which makes its usage
 * impossible.
 */
export class EmptyCalendarEffect extends SchedulingIssueEffect {
    constructor() {
        super(...arguments);
        this.handler = EmptyCalendarSymbol;
    }
    getResolutions() {
        const calendar = this.getCalendar();
        return this._resolutions || (this._resolutions = [
            Use24hrsEmptyCalendarEffectResolution.new({ calendar }),
            Use8hrsEmptyCalendarEffectResolution.new({ calendar })
        ]);
    }

    /**
     * Returns the calendar that does not have any working periods specified.
     */
    getCalendar() {
        const invalidCalendarData = this.getInvalidCalendar();
        return invalidCalendarData ? invalidCalendarData[0] : this.calendars[0];
    }
    getInvalidCalendar() {
        const { calendars, date, isForward } = this;
        for (const calendar of calendars) {
            const skippingBackwardResult = calendar.skipNonWorkingTime(date, false);
            const skippingForwardResult = calendar.skipNonWorkingTime(date, true);
            if (isForward) {
                if (!(skippingForwardResult instanceof Date)) {
                    return [
                        calendar,
                        skippingBackwardResult instanceof Date ? CalendarAvailabilityIssue.NoForward : CalendarAvailabilityIssue.Empty
                    ];
                }
            }
            else {
                if (!(skippingBackwardResult instanceof Date)) {
                    return [
                        calendar,
                        skippingForwardResult instanceof Date ? CalendarAvailabilityIssue.NoBackward : CalendarAvailabilityIssue.Empty
                    ];
                }
            }
        }
    }
}
__decorate([
    prototypeValue('emptyCalendar')
], EmptyCalendarEffect.prototype, "type", void 0);
__decorate([
    prototypeValue(EmptyCalendarEffectDescription)
], EmptyCalendarEffect.prototype, "_descriptionBuilderClass", void 0);
/**
 * Base class for [[EmptyCalendarEffect]] resolutions.
 * The class has [[fixCalendarData]] method that pushes preconfigured `calendarData`
 * to the given [[calendar]]. The method is called in [[resolve]] method so for a subclass
 * it's enough just providing [[fixCalendarData|proper data]].
 */
export class BaseEmptyCalendarEffectResolution extends Localizable(SchedulingIssueEffectResolution) {
    static get configurable() {
        return {
            /**
             * Correct calendar data.
             * @property calendarData
             */
            calendarData: {
                intervals: [
                    { isWorking: true }
                ]
            }
        };
    }
    getDescription() {
        const { calendar } = this;
        return format(this.L('L{descriptionTpl}'), calendar.name || calendar.id);
    }
    /**
     * Fixes the provided calendar data by clearing its intervals
     * and then applying data specified in `calendarData` config.
     * @param calendar
     */
    fixCalendarData(calendar) {
        calendar.clearIntervals(true);
        // @ts-ignore
        Object.assign(calendar, this.calendarData);
        if (calendar.intervals?.length) {
            calendar.addIntervals(calendar.intervals);
        }
    }
    /**
     * Resolves the [[calendar]] by removing all its intervals and adding new `calendarData`.
     */
    resolve() {
        const { calendar } = this;
        this.fixCalendarData(calendar);
    }
}
BaseEmptyCalendarEffectResolution.$name = 'BaseEmptyCalendarEffectResolution';
/**
 * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by
 * replacing its data with standard __24 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.
 */
export class Use24hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {
    static get configurable() {
        return {
            calendarData: {
                unspecifiedTimeIsWorking: false,
                intervals: [
                    {
                        recurrentStartDate: 'on Mon',
                        recurrentEndDate: 'on Sat',
                        isWorking: true
                    }
                ]
            }
        };
    }
}
Use24hrsEmptyCalendarEffectResolution.$name = 'Use24hrsEmptyCalendarEffectResolution';
/**
 * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by
 * replacing its data with standard __8 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.
 */
export class Use8hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {
    static get configurable() {
        return {
            calendarData: {
                unspecifiedTimeIsWorking: false,
                intervals: [
                    {
                        recurrentStartDate: 'every weekday at 08:00',
                        recurrentEndDate: 'every weekday at 12:00',
                        isWorking: true
                    },
                    {
                        recurrentStartDate: 'every weekday at 13:00',
                        recurrentEndDate: 'every weekday at 17:00',
                        isWorking: true
                    }
                ]
            }
        };
    }
}
Use8hrsEmptyCalendarEffectResolution.$name = 'Use8hrsEmptyCalendarEffectResolution';
